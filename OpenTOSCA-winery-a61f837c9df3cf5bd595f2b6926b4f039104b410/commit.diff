diff --git a/.github/PULL_REQUEST_TEMPLATE.md b/.github/PULL_REQUEST_TEMPLATE.md
index 55536b938..3b0a85b53 100644
--- a/.github/PULL_REQUEST_TEMPLATE.md
+++ b/.github/PULL_REQUEST_TEMPLATE.md
@@ -1,6 +1,18 @@
-<!-- describe the changes you have made here: what, why, ... -->
+Use the following template for the PR title and delete this line: [WIP] Title of the thesis/work/target
 
-- [ ] Ensure that you followed http://eclipse.github.io/winery/dev/ToolChain#github---prepare-pull-request. Especially, we require **a single commit**
+<!-- Replace this placeholder by a short description of the aim -->
+
+- Start and end date: <!-- 2017-01-01 to 2017-08-01 -->
+- Contributor: <!-- full name plus GitHub name -- e.g., Lukas Harzenetter, @lharzenetter -->
+- Supervisor: <!-- full name plus GitHub name -- e.g., Karoline Saatkamp, @saatkamp -->
+
+<!-- 
+Replace this placeholder by a short description of the current state. What is done? What are the next steps?
+Please update this description regularly.
+-->
+
+- [ ] Ensure that you followed http://eclipse.github.io/winery/dev/ToolChain#github---prepare-pull-request.
+- [ ] Branch name checked. That means, the branch name starts with `thesis/`, `fix/`, ...
 - [ ] Ensure that the commit message is [a good commit message](https://github.com/joelparkerhenderson/git_commit_message)
 - [ ] Ensure to use auto format in **all** files
 - [ ] Ensure that you appear in `NOTICE` at Copyright Holders
diff --git a/.idea/codeStyles/Project.xml b/.idea/codeStyles/Project.xml
index 08cebcb26..60a9dd92d 100644
--- a/.idea/codeStyles/Project.xml
+++ b/.idea/codeStyles/Project.xml
@@ -24,6 +24,9 @@
       <option name="JD_KEEP_EMPTY_EXCEPTION" value="false" />
       <option name="JD_KEEP_EMPTY_RETURN" value="false" />
     </JavaCodeStyleSettings>
+    <MarkdownNavigatorCodeStyleSettings>
+      <option name="RIGHT_MARGIN" value="72" />
+    </MarkdownNavigatorCodeStyleSettings>
     <TypeScriptCodeStyleSettings version="0">
       <option name="FORCE_SEMICOLON_STYLE" value="true" />
       <option name="USE_DOUBLE_QUOTES" value="false" />
diff --git a/Dockerfile b/Dockerfile
index a69d8f9da..1e686aa39 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -1,16 +1,7 @@
 FROM maven:3-jdk-8 as builder
-
-RUN rm /dev/random && ln -s /dev/urandom /dev/random \
-    && apt-get update -qq && apt-get install -qqy \
-        unzip \
-        git \
-    && apt-get clean \
-    && rm -rf /var/lib/apt/lists/* \
-    && echo '{ "allow_root": true }' > /root/.bowerrc
-
 COPY . /tmp/winery
 WORKDIR /tmp/winery
-RUN mvn package -DskipTests
+RUN mvn package -DskipTests -Dmaven.javadoc.skip=true -B -V -q
 
 
 FROM tomcat:8.5.31
@@ -18,18 +9,29 @@ LABEL maintainer = "Oliver Kopp <kopp.dev@gmail.com>, Michael Wurster <miwurster
 
 ARG DOCKERIZE_VERSION=v0.3.0
 
+ENV WINERY_HOSTNAME localhost
+ENV WINERY_PORT 8080
+ENV WINERY_REPOSITORY_PROVIDER xml
+ENV WINERY_REPOSITORY_PATH "/repository"
 ENV WINERY_REPOSITORY_URL ""
 ENV WINERY_HEAP_MAX 2048m
 ENV WINERY_JMX_ENABLED ""
-ENV CONTAINER_HOSTNAME localhost
-ENV CONTAINER_PORT 1337
 ENV WORKFLOWMODELER_HOSTNAME localhost
 ENV WORKFLOWMODELER_PORT 8080
 ENV TOPOLOGYMODELER_HOSTNAME localhost
 ENV TOPOLOGYMODELER_PORT 8080
-ENV WINERY_REPOSITORY_PATH "/var/opentosca/repository"
-ENV WINERY_HOSTNAME localhost
-ENV WINERY_PORT 8080
+ENV CONTAINER_HOSTNAME localhost
+ENV CONTAINER_PORT 1337
+ENV WINERY_FEATURE_ACCOUNTABILITY false
+ENV WINERY_FEATURE_TEST_COMPLETION false
+ENV WINERY_FEATURE_TEST_COMPLIANCE false
+ENV WINERY_FEATURE_FREEZE_DEFROST false
+ENV WINERY_FEATURE_MANAGEMENT_ENRICHMENT false
+ENV WINERY_FEATURE_NFV false
+ENV WINERY_FEATURE_PATTERN_REFINEMENT false
+ENV WINERY_FEATURE_PROBLEM_DETECTION false
+ENV WINERY_FEATURE_SPLITTING false
+ENV WINERY_FEATURE_TEST_REFINEMENT false
 
 RUN rm /dev/random && ln -s /dev/urandom /dev/random \
     && curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | bash \
diff --git a/LICENSE.spdx b/LICENSE.spdx
index 73d7dbfcf..f21d4799f 100644
--- a/LICENSE.spdx
+++ b/LICENSE.spdx
@@ -1,5 +1,5 @@
 SPDXVersion: SPDX-2.1
-PackageName: Eclipse Winery
-PackageOriginator: Eclipse Foundation
-PackageHomePage: https://github.com/ecipse/winery
+PackageName: OpenTOSCA Winery
+PackageOriginator: University of Stuttgart
+PackageHomePage: https://github.com/OpenTOSCA/winery
 PackageLicenseDeclared: Apache-2.0 OR EPL-2.0
diff --git a/README.md b/README.md
index 64e7a5193..3489c61fe 100644
--- a/README.md
+++ b/README.md
@@ -1,19 +1,34 @@
-# Eclipse Winery
+# Eclipse Winery – OpenTOSCA fork
 
+[![Build Status](https://travis-ci.org/OpenTOSCA/winery.svg?branch=ustutt)](https://travis-ci.org/OpenTOSCA/winery)
 [![License](https://img.shields.io/badge/License-EPL%202.0-blue.svg)](https://opensource.org/licenses/EPL-2.0)
 [![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
 
-Winery is a Web-based environment to graphically model TOSCA topologies and plans managing these topologies.
-It is an Eclipse project and thus support is available through its project page <https://eclipse.org/winery>.
-Winery is also part of the OpenTOSCA ecosystem where more information is available at <http://www.opentosca.org>.
-
-**The code and the linked libraries are NOT approved by Eclipse Legal.**
+This is a fork of [Eclipse Winery](https://github.com/eclipse/winery) and might include current research results not yet approved by Eclipse legal.
+Find out more about the OpenTOSCA eco system at [www.opentosca.org](http://www.opentosca.org/).
 
 **There was no security of Eclipse Winey. There might be [remote code execution vulnerabilities](https://github.com/mbechler/marshalsec). Thus, when hosting Eclipse Winery, make it accessible to turstworthy parties only.**
 
 Both development and user documentation is rendered at <https://eclipse.github.io/winery/>.
 The source for the documentation can be found at [docs/](docs).
 
+## Differences to Eclipse Winery
+
+The branch `ustutt` differs from eclipse/winery in the following files:
+
+- [.github/PULL_REQUEST_TEMPLATE.md](.github/PULL_REQUEST_TEMPLATE.md) - extended for USTUTT students
+- [README.md](README.md) - This text file + disclaimer
+- [LICENSE.spdx](LICENSE.spdx) - Update OpenTOSCA specifics
+
+One can find out the differences between the `ustutt` branch of OpenTOSCA/winery and the `master` branch of eclipse/winery by executing the following command:
+
+    git fetch --all
+    git difftool upstream/master origin/ustutt
+
+Precondition:
+   
+    git remote add upstream https://github.com/eclipse/winery.git
+
 ## Running Winery
 
 ### Running via Docker
@@ -73,6 +88,15 @@ The next steps are:
     * Compliance Rules
 * See https://github.com/eclipse/winery/issues
 
+## Haftungsausschluss
+
+Dies ist ein Forschungsprototyp.
+Die Haftung für entgangenen Gewinn, Produktionsausfall, Betriebsunterbrechung, entgangene Nutzungen, Verlust von Daten und Informationen, Finanzierungsaufwendungen sowie sonstige Vermögens- und Folgeschäden ist, außer in Fällen von grober Fahrlässigkeit, Vorsatz und Personenschäden ausgeschlossen.
+
+## Disclaimer of Warranty
+
+Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE.
+You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.
 
 ## Acknowledgements
 
diff --git a/docker/winery.yml.tpl b/docker/winery.yml.tpl
index a43d10ac3..e84148164 100644
--- a/docker/winery.yml.tpl
+++ b/docker/winery.yml.tpl
@@ -1,15 +1,15 @@
 ui:
   features:
-    accountability: true
-    completion: true
-    compliance: true
-    freezeAndDefrost: true
-    managementFeatureEnrichment: true
-    nfv: true
-    patternRefinement: true
-    problemDetection: true
-    splitting: true
-    testRefinement: true
+    accountability: {{ .Env.WINERY_FEATURE_ACCOUNTABILITY }}
+    completion: {{ .Env.WINERY_FEATURE_TEST_COMPLETION }}
+    compliance: {{ .Env.WINERY_FEATURE_TEST_COMPLIANCE }}
+    freezeAndDefrost: {{ .Env.WINERY_FEATURE_FREEZE_DEFROST }}
+    managementFeatureEnrichment: {{ .Env.WINERY_FEATURE_MANAGEMENT_ENRICHMENT }}
+    nfv: {{ .Env.WINERY_FEATURE_NFV }}
+    patternRefinement: {{ .Env.WINERY_FEATURE_PATTERN_REFINEMENT }}
+    problemDetection: {{ .Env.WINERY_FEATURE_PROBLEM_DETECTION }}
+    splitting: {{ .Env.WINERY_FEATURE_SPLITTING }}
+    testRefinement: {{ .Env.WINERY_FEATURE_TEST_REFINEMENT }}
   endpoints:
     container: http://{{ .Env.CONTAINER_HOSTNAME }}:{{ .Env.CONTAINER_PORT }}
     workflowmodeler: http://{{ .Env.WORKFLOWMODELER_HOSTNAME }}:{{ .Env.WORKFLOWMODELER_PORT }}/winery-workflowmodeler
@@ -17,7 +17,7 @@ ui:
     repositoryApiUrl: http://{{ .Env.WINERY_HOSTNAME }}:{{ .Env.WINERY_PORT }}/winery
     repositoryUiUrl: http://{{ .Env.WINERY_HOSTNAME }}:{{ .Env.WINERY_PORT }}/#
 repository:
-  provider: file
+  provider: {{ .Env.WINERY_REPOSITORY_PROVIDER }}
   repositoryRoot: {{ .Env.WINERY_REPOSITORY_PATH }}
   git:
     clientSecret: secret
diff --git a/org.eclipse.winery.bpmn4tosca.converter.tobpel/src/main/java/org/eclipse/winery/bpmn2bpel/planwriter/ManagementTaskTemplateWrapper.java b/org.eclipse.winery.bpmn4tosca.converter.tobpel/src/main/java/org/eclipse/winery/bpmn2bpel/planwriter/ManagementTaskTemplateWrapper.java
index 5766b19bb..c7252c991 100644
--- a/org.eclipse.winery.bpmn4tosca.converter.tobpel/src/main/java/org/eclipse/winery/bpmn2bpel/planwriter/ManagementTaskTemplateWrapper.java
+++ b/org.eclipse.winery.bpmn4tosca.converter.tobpel/src/main/java/org/eclipse/winery/bpmn2bpel/planwriter/ManagementTaskTemplateWrapper.java
@@ -13,13 +13,17 @@
  *******************************************************************************/
 package org.eclipse.winery.bpmn2bpel.planwriter;
 
-import org.eclipse.winery.bpmn2bpel.model.ManagementTask;
-import org.eclipse.winery.bpmn2bpel.model.param.Parameter;
-import org.eclipse.winery.bpmn2bpel.model.param.TopologyParameter;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
 
 import javax.xml.namespace.QName;
-import java.util.*;
 
+import org.eclipse.winery.bpmn2bpel.model.ManagementTask;
+import org.eclipse.winery.bpmn2bpel.model.param.Parameter;
+import org.eclipse.winery.bpmn2bpel.model.param.TopologyParameter;
 
 /**
  * Add convenience methods to the {@link ManagementTask} that can be used in the Velocity template.
diff --git a/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/Enums.java b/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/Enums.java
new file mode 100644
index 000000000..9fcc4e679
--- /dev/null
+++ b/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/Enums.java
@@ -0,0 +1,48 @@
+/*******************************************************************************
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+
+package org.eclipse.winery.common;
+
+public abstract class Enums {
+
+    /**
+     * A utility method for all enums for string to enum conversion
+     *
+     * @param c     the Enum type
+     * @param value value as case insensitive string
+     * @return The corresponding enum, or null
+     */
+    public static <T extends Enum<T>> T valueOf(final Class<T> c, final String value) {
+        return valueOf(c, value, null);
+    }
+
+    /**
+     * A utility method for all enums for string-to-enum conversion
+     *
+     * @param c            the Enum type
+     * @param value        value as case insensitive string
+     * @param defaultValue a public value
+     * @return The corresponding enum, or null
+     */
+    public static <T extends Enum<T>> T valueOf(final Class<T> c, final String value, final T defaultValue) {
+        if (c != null && value != null) {
+            try {
+                return Enum.valueOf(c, value.trim().toUpperCase());
+            } catch (final IllegalArgumentException e) {
+                return defaultValue;
+            }
+        }
+        return defaultValue;
+    }
+}
diff --git a/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/StringEncodedAndDecoded.java b/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/StringEncodedAndDecoded.java
index 49ebb0179..a1ef69a58 100644
--- a/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/StringEncodedAndDecoded.java
+++ b/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/StringEncodedAndDecoded.java
@@ -13,17 +13,14 @@
  *******************************************************************************/
 package org.eclipse.winery.common;
 
-
 /**
- * Meta class to handle things, where a String (URI, NCName, ...) may be
- * URLencoded
+ * Meta class to handle things, where a String (URI, NCName, ...) may be URLencoded
  */
 public class StringEncodedAndDecoded implements Comparable<StringEncodedAndDecoded> {
 
     private String decoded = null;
     private String encoded = null;
 
-
     /**
      * @param uri        the URI to store
      * @param URLencoded true iff the given URI is URLencoded
@@ -73,8 +70,7 @@ public int compareTo(StringEncodedAndDecoded o) {
     }
 
     /**
-     * Compares with the given object.
-     * Equality checking is made based on the decoded String
+     * Compares with the given object. Equality checking is made based on the decoded String
      */
     @Override
     public boolean equals(Object o) {
diff --git a/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/Util.java b/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/Util.java
index 4bf27695f..286cb6077 100644
--- a/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/Util.java
+++ b/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/Util.java
@@ -270,11 +270,11 @@ public static String getURLpathFragmentForCollection(Class<? extends TExtensible
 
     public static String getEverythingBetweenTheLastDotAndBeforeId(Class<? extends GenericId> cls) {
         String res = cls.getName();
-        // Everything between the last "." and before "Id" is the Type
+//        // Everything between the last "." and before "Id" is the Type
         int dotIndex = res.lastIndexOf('.');
         assert (dotIndex >= 0);
         return res.substring(dotIndex + 1, res.length() - "Id".length());
-    }
+}
 
     public static String getTypeForElementId(Class<? extends ToscaElementId> idClass) {
         return Util.getEverythingBetweenTheLastDotAndBeforeId(idClass);
@@ -315,10 +315,15 @@ public static String getRootPathFragment(Class<? extends DefinitionsChildId> idC
         } else {
             res = "";
         }
-        res = res + Util.getTypeForComponentId(idClass);
+        res = res + getFolderName(idClass);
+        res = res + "/";
+        return res;
+    }
+    
+    public static String getFolderName(Class<? extends DefinitionsChildId> idClass) {
+        String res = Util.getTypeForComponentId(idClass);
         res = res.toLowerCase();
         res = res + "s";
-        res = res + "/";
         return res;
     }
 
diff --git a/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/configuration/Environments.java b/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/configuration/Environments.java
index 00b53af0a..d14677471 100644
--- a/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/configuration/Environments.java
+++ b/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/configuration/Environments.java
@@ -31,6 +31,7 @@
 public final class Environments {
 
     private static final Logger LOGGER = LoggerFactory.getLogger(Environments.class);
+
     private static RepositoryConfigurationObject repositoryConfigurationObject;
     private static GitConfigurationObject gitConfigurationObject;
     private static UiConfigurationObject uiConfigurationObject;
@@ -38,7 +39,7 @@
     private Environments() {
     }
 
-    static void clearInstances() {
+    public static void clearInstances() {
         repositoryConfigurationObject = null;
         gitConfigurationObject = null;
         uiConfigurationObject = null;
@@ -125,7 +126,7 @@ public static FileBasedRepositoryConfiguration getFilebasedRepositoryConfigurati
      *
      * @return an instance of GitBasedRepositoryConfiguration
      */
-    public static Optional<GitBasedRepositoryConfiguration> getGitBasedRepsitoryConfiguration() {
+    public static Optional<GitBasedRepositoryConfiguration> getGitBasedRepositoryConfiguration() {
         final FileBasedRepositoryConfiguration filebasedRepositoryConfiguration = getFilebasedRepositoryConfiguration();
         return Optional.of(new GitBasedRepositoryConfiguration(getGitConfig().isAutocommit(), filebasedRepositoryConfiguration));
     }
diff --git a/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/configuration/FileBasedRepositoryConfiguration.java b/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/configuration/FileBasedRepositoryConfiguration.java
index b82f24dfa..50d19f247 100644
--- a/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/configuration/FileBasedRepositoryConfiguration.java
+++ b/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/configuration/FileBasedRepositoryConfiguration.java
@@ -22,8 +22,8 @@
 
 public class FileBasedRepositoryConfiguration {
 
-    // may be null, because org.eclipse.winery.repository.backend.filebased.FilebasedRepository() determines the location automatically if no path exists
     private Path repositoryPath = null;
+    private RepositoryConfigurationObject.RepositoryProvider repositoryProvider;
 
     /**
      * There are no required values for the configuration
@@ -32,11 +32,18 @@ public FileBasedRepositoryConfiguration() {
     }
 
     public FileBasedRepositoryConfiguration(@NonNull Path repositoryPath) {
+        this(repositoryPath, Environments.getRepositoryConfig().getProvider());
+    }
+
+    private FileBasedRepositoryConfiguration(@NonNull Path repositoryPath, RepositoryConfigurationObject.RepositoryProvider repositoryProvider) {
         this.repositoryPath = Objects.requireNonNull(repositoryPath);
+        this.repositoryProvider = Objects.requireNonNull(repositoryProvider);
     }
 
-    public FileBasedRepositoryConfiguration(@NonNull FileBasedRepositoryConfiguration fileBasedRepositoryConfiguration) {
-        this.repositoryPath = Objects.requireNonNull(fileBasedRepositoryConfiguration).repositoryPath;
+    public FileBasedRepositoryConfiguration(@NonNull FileBasedRepositoryConfiguration configuration) {
+        Objects.requireNonNull(configuration);
+        this.repositoryPath = Objects.requireNonNull(configuration.repositoryPath);
+        this.repositoryProvider = Objects.requireNonNull(configuration.repositoryProvider);
     }
 
     public Optional<Path> getRepositoryPath() {
@@ -46,4 +53,12 @@ public FileBasedRepositoryConfiguration(@NonNull FileBasedRepositoryConfiguratio
     public void setRepositoryPath(@NonNull Path repositoryPath) {
         this.repositoryPath = Objects.requireNonNull(repositoryPath);
     }
+
+    public RepositoryConfigurationObject.RepositoryProvider getRepositoryProvider() {
+        return repositoryProvider;
+    }
+
+    public void setRepositoryProvider(RepositoryConfigurationObject.RepositoryProvider repositoryProvider) {
+        this.repositoryProvider = repositoryProvider;
+    }
 }
diff --git a/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/configuration/GitConfigurationObject.java b/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/configuration/GitConfigurationObject.java
index 0681efcc1..9e0dc3b77 100644
--- a/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/configuration/GitConfigurationObject.java
+++ b/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/configuration/GitConfigurationObject.java
@@ -17,6 +17,7 @@
 import org.apache.commons.configuration2.YAMLConfiguration;
 
 public class GitConfigurationObject extends AbstractConfigurationObject {
+
     private final String key = "repository.git.";
     private String clientSecret;
     private String password;
diff --git a/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/configuration/RepositoryConfigurationObject.java b/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/configuration/RepositoryConfigurationObject.java
index 7215a5855..76e67e476 100644
--- a/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/configuration/RepositoryConfigurationObject.java
+++ b/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/configuration/RepositoryConfigurationObject.java
@@ -22,17 +22,27 @@
 import org.apache.commons.io.FileUtils;
 
 public class RepositoryConfigurationObject extends AbstractConfigurationObject {
+
     private final String key = "repository.";
     private GitConfigurationObject gitConfiguration;
     private String repositoryRoot;
-    private String provider;
+    private RepositoryProvider provider;
     private YAMLConfiguration configuration;
 
+    public enum RepositoryProvider {
+        FILE, YAML
+    }
+
     RepositoryConfigurationObject(YAMLConfiguration configuration) {
         this.repositoryRoot = configuration.getString(key + "repositoryRoot");
-        this.setProvider(configuration.getString(key + "provider"));
-        this.setGitConfiguration(Environments.getGitConfig());
         this.configuration = configuration;
+        this.setGitConfiguration(Environments.getGitConfig());
+        String provider = Environment.getConfiguration().getString(key + "provider");
+        if (provider.equalsIgnoreCase(RepositoryProvider.YAML.name())) {
+            this.setProvider(RepositoryProvider.YAML);
+        } else {
+            this.setProvider(RepositoryProvider.FILE);
+        }
     }
 
     @Override
@@ -44,7 +54,7 @@ void save() {
     }
 
     /**
-     * Returns the path to the repositiory saved in the configuration file.
+     * Returns the path to the repository saved in the configuration file.
      *
      * @return path to configuration
      */
@@ -70,11 +80,11 @@ public void setGitConfiguration(GitConfigurationObject gitConfiguration) {
         this.gitConfiguration = gitConfiguration;
     }
 
-    public String getProvider() {
+    public RepositoryConfigurationObject.RepositoryProvider getProvider() {
         return provider;
     }
 
-    public void setProvider(String provider) {
+    public void setProvider(RepositoryProvider provider) {
         this.provider = provider;
     }
 }
diff --git a/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/configuration/UiConfigurationObject.java b/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/configuration/UiConfigurationObject.java
index b5a605abd..61ee6bdc5 100644
--- a/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/configuration/UiConfigurationObject.java
+++ b/org.eclipse.winery.common/src/main/java/org/eclipse/winery/common/configuration/UiConfigurationObject.java
@@ -17,6 +17,8 @@
 import java.util.HashMap;
 import java.util.Iterator;
 
+import org.eclipse.winery.common.Enums;
+
 import org.apache.commons.configuration2.YAMLConfiguration;
 
 /**
@@ -25,8 +27,8 @@
  */
 public class UiConfigurationObject extends AbstractConfigurationObject {
 
-    HashMap<String, Boolean> features;
-    HashMap<String, String> endpoints;
+    private HashMap<String, Boolean> features;
+    private HashMap<String, String> endpoints;
     private final String key = "ui";
     private final String featurePrefix = key + ".features.";
     private final String endpointPrefix = key + ".endpoints.";
@@ -44,6 +46,12 @@ public UiConfigurationObject() {
         Iterator<String> endpointIterator = configuration.getKeys(endpointPrefix);
         featureIterator.forEachRemaining(key -> features.put(key.replace(featurePrefix, ""), configuration.getBoolean((key))));
         endpointIterator.forEachRemaining(key -> endpoints.put(key.replace(endpointPrefix, ""), configuration.getString(key)));
+        if (RepositoryConfigurationObject.RepositoryProvider.YAML.equals(Environments.getRepositoryConfig().getProvider())) {
+            features.put(RepositoryConfigurationObject.RepositoryProvider.YAML.name().toLowerCase(), true);
+        } else {
+            // closed-world assumption. Apparently..
+            features.put(RepositoryConfigurationObject.RepositoryProvider.YAML.name().toLowerCase(), false);
+        }
         this.features = features;
         this.endpoints = endpoints;
         this.configuration = configuration;
@@ -59,8 +67,12 @@ public UiConfigurationObject() {
 
     @Override
     void save() {
-        this.features.keySet().forEach(property -> configuration.setProperty(featurePrefix + property, this.features.get(property)));
-        this.endpoints.keySet().forEach(property -> configuration.setProperty(endpointPrefix + property, this.endpoints.get(property)));
+        this.features.keySet().stream()
+            .filter(p -> !RepositoryConfigurationObject.RepositoryProvider.YAML
+                .equals(Enums.valueOf(RepositoryConfigurationObject.RepositoryProvider.class, p))
+            ).forEach(property -> configuration.setProperty(featurePrefix + property, this.features.get(property)));
+        this.endpoints.keySet()
+            .forEach(property -> configuration.setProperty(endpointPrefix + property, this.endpoints.get(property)));
         Environment.save();
     }
 }
diff --git a/org.eclipse.winery.compliance/src/test/java/org/eclipse/winery/compliance/ToscaGraphIsomorphismTest.java b/org.eclipse.winery.compliance/src/test/java/org/eclipse/winery/compliance/ToscaGraphIsomorphismTest.java
index 4e1b27795..50a3f2d28 100644
--- a/org.eclipse.winery.compliance/src/test/java/org/eclipse/winery/compliance/ToscaGraphIsomorphismTest.java
+++ b/org.eclipse.winery.compliance/src/test/java/org/eclipse/winery/compliance/ToscaGraphIsomorphismTest.java
@@ -29,6 +29,7 @@
 import javax.xml.bind.Marshaller;
 import javax.xml.namespace.QName;
 
+import org.eclipse.winery.common.configuration.FileBasedRepositoryConfiguration;
 import org.eclipse.winery.common.ids.definitions.ComplianceRuleId;
 import org.eclipse.winery.common.ids.definitions.DefinitionsChildId;
 import org.eclipse.winery.common.ids.definitions.NodeTypeId;
@@ -50,7 +51,6 @@
 import org.eclipse.winery.repository.backend.BackendUtils;
 import org.eclipse.winery.repository.backend.RepositoryFactory;
 import org.eclipse.winery.repository.backend.filebased.FilebasedRepository;
-import org.eclipse.winery.common.configuration.FileBasedRepositoryConfiguration;
 import org.eclipse.winery.topologygraph.matching.ToscaIsomorphismMatcher;
 import org.eclipse.winery.topologygraph.model.ToscaEdge;
 import org.eclipse.winery.topologygraph.model.ToscaGraph;
diff --git a/org.eclipse.winery.frontends/app/topologymodeler/src/app/canvas/canvas.component.html b/org.eclipse.winery.frontends/app/topologymodeler/src/app/canvas/canvas.component.html
index 751024d45..5169e2ec5 100644
--- a/org.eclipse.winery.frontends/app/topologymodeler/src/app/canvas/canvas.component.html
+++ b/org.eclipse.winery.frontends/app/topologymodeler/src/app/canvas/canvas.component.html
@@ -1,5 +1,5 @@
 <!--
- * Copyright (c) 2017-2018 Contributors to the Eclipse Foundation
+ * Copyright (c) 2017-2019 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -47,6 +47,7 @@
                      (handleNodeClickedActions)="handleNodeClickedActions($event)"
                      (updateSelectedNodes)="updateSelectedNodes()"
                      (unmarkConnections)="unmarkConnections()"
+                     (relationshipTemplateIdClicked)="onClickRelationshipTemplateName($event)"
                      (sendNodeData)="toggleModalHandler($event)">
         </winery-node>
     </div>
@@ -64,7 +65,7 @@
         <form #capForm="ngForm" id="addCapForm" enctype="multipart/form-data">
             <fieldset>
 
-                <div class="form-group" id="capIdGroup">
+                <div *wineryRepositoryHideOnFeature="'yaml'" class="form-group" id="capIdGroup">
                     <label for="capId" class="control-label">Id:</label>
                     <input [(ngModel)]="capabilities.capId"
                            id="capId"
@@ -157,17 +158,29 @@
         <button type="button" id="cancelCapabilities" class="btn btn-default"
                 (click)="closeAndResetCapabilities(); capForm.reset()">Cancel
         </button>
+
         <button *ngIf="!showCurrentCapability; else deleteCapButton"
-                (click)="saveCapabilityToModel(); capForm.reset()" type="button" id="addCapbtn" class="btn btn-primary"
+                (click)="saveCapabilityToModel(); capForm.reset()" type="button" id="addCapbtn"
+                class="btn btn-primary"
                 [disabled]="!capForm.form.valid || duplicateId">Add
         </button>
+
         <ng-template #deleteCapButton>
-            <button type="button" id="updateCapabilitiesBtn" (click)="updateCaps(); capForm.reset()"
-                    class="btn btn-primary" [disabled]="!capForm.form.valid || duplicateId">Update
-            </button>
-            <button (click)="deleteCapability(); capForm.reset()" type="button" id="deleteCapbtn"
-                    class="btn btn-primary">Delete
-            </button>
+            <div *wineryRepositoryHideOnFeature="'yaml'">
+                <button type="button" id="updateCapabilitiesBtn" (click)="updateCaps(); capForm.reset()"
+                        class="btn btn-primary" [disabled]="!capForm.form.valid || duplicateId">Update
+                </button>
+                <button  (click)="deleteCapability(); capForm.reset()"
+                        type="button"
+                        id="deleteCapbtn"
+                        class="btn btn-primary">Delete
+                </button>
+            </div>
+            <div *wineryRepositoryShowOnFeature="'yaml'">
+                <button type="button" (click)="updateCaps(); capForm.reset()"
+                        class="btn btn-primary"> Update
+                </button>
+            </div>
         </ng-template>
     </winery-modal-footer>
 </winery-modal>
@@ -335,26 +348,31 @@
             <div class="card">
                 <div class="card-header" id="headingOne">
                     <h5 class="mb-0">
-                        <button class="btn btn-link"  (click)="this.threatModalTab='create'">Create New Threat</button>
+                        <button class="btn btn-link" (click)="this.threatModalTab='create'">Create New Threat</button>
                     </h5>
                 </div>
 
-                <div id="collapseOne" class="collapse" [class.show]="this.threatModalTab==='create'" >
+                <div id="collapseOne" class="collapse" [class.show]="this.threatModalTab==='create'">
                     <div class="card-body">
                         <form (ngSubmit)="this.createNewThreat()">
                             <div class="form-group row">
                                 <label for="text" class="col-sm-4 col-form-label">Threat name</label>
                                 <div class="col-sm-8">
-                                    <input type="text" class="form-control" id="name" name="name" required [(ngModel)]="this.threatModelingData.threatCreation.name">
+                                    <input type="text" class="form-control" id="name" name="name" required
+                                           [(ngModel)]="this.threatModelingData.threatCreation.name">
                                 </div>
                             </div>
                             <div class="form-group row">
                                 <label for="text" class="col-sm-4 col-form-label">Description</label>
-                                <div class="col-sm-8"><textarea class="form-control" id="description" name="description" required [(ngModel)]="this.threatModelingData.threatCreation.description"></textarea></div>
+                                <div class="col-sm-8"><textarea class="form-control" id="description" name="description"
+                                                                required
+                                                                [(ngModel)]="this.threatModelingData.threatCreation.description"></textarea>
+                                </div>
                             </div>
                             <div class="form-group row">
                                 <label for="stride" class="col-sm-4 col-form-label">STRIDE</label>
-                                <div class="col-sm-8"><select class="form-control" id="stride"  name="stride" [(ngModel)]="this.threatModelingData.threatCreation.stride">
+                                <div class="col-sm-8"><select class="form-control" id="stride" name="stride"
+                                                              [(ngModel)]="this.threatModelingData.threatCreation.stride">
                                     <option>Spoofing</option>
                                     <option>Tampering</option>
                                     <option>Repudiation</option>
@@ -366,7 +384,8 @@ <h5 class="mb-0">
                             <div class="form-group row">
                                 <label for="severity" class="col-sm-4 col-form-label">Severity</label>
                                 <div class="col-sm-8">
-                                    <select class="form-control" id="severity"  name="severity" [(ngModel)]="this.threatModelingData.threatCreation.severity">
+                                    <select class="form-control" id="severity" name="severity"
+                                            [(ngModel)]="this.threatModelingData.threatCreation.severity">
                                         <option>Low</option>
                                         <option>Middle</option>
                                         <option>High</option>
@@ -381,20 +400,25 @@ <h5 class="mb-0">
             <div class="card">
                 <div class="card-header" id="headingTwo">
                     <h5 class="mb-0">
-                        <button class="btn btn-link collapsed" (click)="this.threatModalTab='mitigations'">Available Mitigations</button>
+                        <button class="btn btn-link collapsed" (click)="this.threatModalTab='mitigations'">Available
+                            Mitigations
+                        </button>
                     </h5>
                 </div>
                 <div id="collapseTwo" class="collapse" [class.show]="this.threatModalTab==='mitigations'">
                     <div class="card-body">
                         <p>Click on a Mitigation to directly add it to the topology</p>
-                        <button class="btn btn-primary" style="margin-right:10px;margin-bottom:10px" *ngFor="let mitigation of this.threatModelingData.mitigations" (click)="addMitigationToTopology(mitigation)">{{mitigation.localName}}</button>
+                        <button class="btn btn-primary" style="margin-right:10px;margin-bottom:10px"
+                                *ngFor="let mitigation of this.threatModelingData.mitigations"
+                                (click)="addMitigationToTopology(mitigation)">{{mitigation.localName}}</button>
                     </div>
                 </div>
             </div>
             <div class="card">
                 <div class="card-header" id="headingThree">
                     <h5 class="mb-0">
-                        <button class="btn btn-link collapsed" (click)="this.threatModalTab='catalog'">Threat Catalog</button>
+                        <button class="btn btn-link collapsed" (click)="this.threatModalTab='catalog'">Threat Catalog
+                        </button>
                     </h5>
                 </div>
                 <div id="collapseThree" class="collapse" [class.show]="this.threatModalTab==='catalog'">
@@ -404,8 +428,10 @@ <h5 class="mb-0">
                                 <h5 class="">{{threat.templateName}}</h5>
                                 <p>{{threat.properties.description}}</p>
                                 <div class="pull-right">
-                                    <span class="badge badge-pill badge-warning" style="margin-right: 10px;">{{threat.properties.strideClassification}}</span>
-                                    <span class="badge badge-pill badge-danger" style="">{{threat.properties.severity}}</span>
+                                    <span class="badge badge-pill badge-warning"
+                                          style="margin-right: 10px;">{{threat.properties.strideClassification}}</span>
+                                    <span class="badge badge-pill badge-danger"
+                                          style="">{{threat.properties.severity}}</span>
                                 </div>
                             </li>
                         </ul>
@@ -415,7 +441,8 @@ <h5 class="">{{threat.templateName}}</h5>
         </div>
     </winery-modal-body>
     <winery-modal-footer [showDefaultButtons]="false">
-        <button type="button" id="cancelThreatModeling" class="btn btn-primary" (click)="closeThreatModeling()">Cancel</button>
+        <button type="button" id="cancelThreatModeling" class="btn btn-primary" (click)="closeThreatModeling()">Cancel
+        </button>
     </winery-modal-footer>
 </winery-modal>
 
diff --git a/org.eclipse.winery.frontends/app/topologymodeler/src/app/canvas/canvas.component.ts b/org.eclipse.winery.frontends/app/topologymodeler/src/app/canvas/canvas.component.ts
index 0306fa567..b75240498 100644
--- a/org.eclipse.winery.frontends/app/topologymodeler/src/app/canvas/canvas.component.ts
+++ b/org.eclipse.winery.frontends/app/topologymodeler/src/app/canvas/canvas.component.ts
@@ -43,7 +43,6 @@ import { align, toggleModalType } from '../models/enums';
 import { QName } from '../models/qname';
 import { ImportTopologyModalData } from '../models/importTopologyModalData';
 import { ImportTopologyService } from '../services/import-topology.service';
-import { ReqCapService } from '../services/req-cap.service';
 import { SplitMatchTopologyService } from '../services/split-match-topology.service';
 import { PlaceComponentsService } from '../services/placement.service';
 import { DifferenceStates, VersionUtils } from '../models/ToscaDiff';
@@ -55,6 +54,9 @@ import { ThreatCreation } from '../models/threatCreation';
 import { TopologyTemplateUtil } from '../models/topologyTemplateUtil';
 import { ReqCapRelationshipService } from '../services/req-cap-relationship.service';
 import { TPolicy } from '../models/policiesModalData';
+import { WineryRepositoryConfigurationService } from '../../../../tosca-management/src/app/wineryFeatureToggleModule/WineryRepositoryConfiguration.service';
+import { RequirementDefinitionModel } from '../models/requirementDefinitonModel';
+import { CapabilityDefinitionModel } from '../models/capabilityDefinitionModel';
 
 @Component({
     selector: 'winery-canvas',
@@ -160,10 +162,10 @@ export class CanvasComponent implements OnInit, OnDestroy, OnChanges, AfterViewI
                 private existsService: ExistsService,
                 private splitMatchService: SplitMatchTopologyService,
                 private placementService: PlaceComponentsService,
-                private reqCapService: ReqCapService,
                 private errorHandler: ErrorHandlerService,
                 private reqCapRelationshipService: ReqCapRelationshipService,
-                private notify: ToastrService) {
+                private notify: ToastrService,
+                private configuration: WineryRepositoryConfigurationService) {
         this.newJsPlumbInstance = this.jsPlumbService.getJsPlumbInstance();
         this.newJsPlumbInstance.setContainer('container');
 
@@ -370,14 +372,14 @@ export class CanvasComponent implements OnInit, OnDestroy, OnChanges, AfterViewI
                     try {
                         // request all valid requirement types for that node type for display as name select options in
                         // the modal
-                        this.reqCapService.requestRequirementDefinitionsOfNodeType(currentNodeData.type).subscribe(data => {
-                            this.requirements.reqDefinitionNames = [];
-                            this.requirements.reqDefinitionName = '';
-                            for (const reqType of data) {
-                                const qNameOfType = new QName(reqType.requirementType);
-                                this.requirements.reqDefinitionNames.push(qNameOfType.localName);
-                            }
-                        });
+                        const data = this.getRequirementDefinitionsOfNodeType(currentNodeData.type);
+                        this.requirements.reqDefinitionNames = [];
+                        this.requirements.reqDefinitionName = '';
+
+                        for (const reqType of data) {
+                            const qNameOfType = new QName(reqType.requirementType);
+                            this.requirements.reqDefinitionNames.push(qNameOfType.localName);
+                        }
                     } catch (e) {
                         this.requirements.requirements = '';
                     }
@@ -452,14 +454,14 @@ export class CanvasComponent implements OnInit, OnDestroy, OnChanges, AfterViewI
                     try {
                         // request all valid capability types for that node type for display as name select options in
                         // the modal
-                        this.reqCapService.requestCapabilityDefinitionsOfNodeType(currentNodeData.type).subscribe(data => {
-                            this.capabilities.capDefinitionNames = [];
-                            this.capabilities.capDefinitionName = '';
-                            for (const capType of data) {
-                                const qNameOfType = new QName(capType.capabilityType);
-                                this.capabilities.capDefinitionNames.push(qNameOfType.localName);
-                            }
-                        });
+                        const data = this.getCapabilityDefinitionsOfNodeType(currentNodeData.type);
+                        this.capabilities.capDefinitionNames = [];
+                        this.capabilities.capDefinitionName = '';
+                        for (const capType of data) {
+                            const qNameOfType = new QName(capType.capabilityType);
+                            this.capabilities.capDefinitionNames.push(qNameOfType.localName);
+                        }
+
                     } catch (e) {
                         this.capabilities.capabilities = '';
                     }
@@ -469,6 +471,45 @@ export class CanvasComponent implements OnInit, OnDestroy, OnChanges, AfterViewI
         }
     }
 
+    getCapabilityDefinitionsOfNodeType(nodeType: string): CapabilityDefinitionModel[] {
+        const match = this.entityTypes.unGroupedNodeTypes
+            .filter(nt => nt.qName === nodeType)
+            .filter(nt =>
+                nt.full &&
+                nt.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation &&
+                nt.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation.length > 0 &&
+                nt.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].capabilityDefinitions &&
+                nt.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].capabilityDefinitions.capabilityDefinition &&
+                nt.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].capabilityDefinitions.capabilityDefinition.length > 0
+            );
+
+        if (match && match.length > 0) {
+            return match[0].full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].capabilityDefinitions.capabilityDefinition;
+        }
+
+        return [];
+    }
+
+    getRequirementDefinitionsOfNodeType(nodeType: string): RequirementDefinitionModel[] {
+        const match = this.entityTypes.unGroupedNodeTypes
+            .filter(nt => nt.qName === nodeType)
+            .filter(nt =>
+                nt.full &&
+                nt.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation &&
+                nt.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation.length > 0 &&
+                nt.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].requirementDefinitions &&
+                nt.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].requirementDefinitions.requirementDefinition &&
+                nt.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].requirementDefinitions.requirementDefinition.length > 0
+            );
+
+        if (match && match.length > 0) {
+            return match[0].full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].requirementDefinitions.requirementDefinition;
+        }
+
+        return [];
+
+    }
+
     /**
      * This function sets the capability default KV properties
      */
@@ -885,9 +926,31 @@ export class CanvasComponent implements OnInit, OnDestroy, OnChanges, AfterViewI
         const storeRelationshipsLength = currentRelationships.length;
         if (storeRelationshipsLength !== localRelationshipsCopyLength) {
             const difference = storeRelationshipsLength - localRelationshipsCopyLength;
+
             if (difference === 1) {
                 this.handleNewRelationship(currentRelationships);
             } else if (difference > 0 || difference < 0) {
+                if (this.configuration.isYaml() && difference < 0) {
+                    // a relationship is deleted. reset the associated source requirement
+                    const deletedRels = this.allRelationshipTemplates.filter(rel => currentRelationships.every(curRel => curRel.id !== rel.id));
+                    deletedRels.forEach(deletedRel => {
+                        const reqId = deletedRel.sourceElement.ref;
+                        const sourceNodeTemplate = this.allNodeTemplates
+                            .find(nt =>
+                                nt.requirements &&
+                                nt.requirements.requirement
+                                && nt.requirements.requirement.some(req => req.id === reqId));
+                        const requirementModel: RequirementModel = sourceNodeTemplate.requirements.requirement
+                            .find(req => req.id === reqId);
+                        const requirementDefinition: RequirementDefinitionModel = this.getRequirementDefinitionsOfNodeType(sourceNodeTemplate.type)
+                            .find(reqDef => reqDef.name === requirementModel.name);
+                        requirementModel.capability = requirementDefinition.capability;
+                        requirementModel.relationship = requirementDefinition.relationship;
+                        requirementModel.node = requirementDefinition.node;
+
+                    });
+
+                }
                 this.allRelationshipTemplates = currentRelationships;
                 this.allRelationshipTemplates.forEach(relTemplate => this.manageRelationships(relTemplate));
             }
@@ -1344,6 +1407,12 @@ export class CanvasComponent implements OnInit, OnDestroy, OnChanges, AfterViewI
                         this.hideSidebar();
                     }
                     selectedNodeSideBarVisible = true;
+                    const toDelete = this.newJsPlumbInstance.getConnections().filter(conn => conn.sourceId === node.nodeTemplate.id ||
+                        conn.targetId === node.nodeTemplate.id);
+                    toDelete.forEach(conn => {
+                        this.ngRedux.dispatch(this.actions.deleteRelationshipTemplate(conn.id));
+                        this.newJsPlumbInstance.deleteConnection(conn);
+                    });
                     this.newJsPlumbInstance.deleteConnectionsForElement(node.nodeTemplate.id);
                     this.newJsPlumbInstance.removeAllEndpoints(node.nodeTemplate.id);
                     this.newJsPlumbInstance.removeFromAllPosses(node.nodeTemplate.id);
@@ -1613,7 +1682,8 @@ export class CanvasComponent implements OnInit, OnDestroy, OnChanges, AfterViewI
                     ],
                 });
                 this.dragSourceInfos = dragSourceInfo;
-                this.targetNodes = this.getAllCapabilities();
+                this.targetNodes = this.getAllCapabilityIds();
+
                 if (this.targetNodes.length > 0) {
                     this.newJsPlumbInstance.makeTarget(this.targetNodes);
                     this.newJsPlumbInstance.targetEndpointDefinitions = {};
@@ -1624,7 +1694,7 @@ export class CanvasComponent implements OnInit, OnDestroy, OnChanges, AfterViewI
         }
     }
 
-    getAllCapabilities() {
+    getAllCapabilityIds() {
         const capIds: string[] = [];
         this.allNodeTemplates.forEach(node => {
             if (node.capabilities) {
@@ -1803,6 +1873,28 @@ export class CanvasComponent implements OnInit, OnDestroy, OnChanges, AfterViewI
                 return true;
             }
         });
+
+        // if in YAML mode, automatically add all requirement and capability definitions to the node template!
+        if (this.configuration.isYaml()) {
+            this.newNode.requirements = { requirement: [] };
+            this.newNode.capabilities = { capability: [] };
+            const reqData = this.getRequirementDefinitionsOfNodeType(this.newNode.type);
+            if (reqData) {
+                reqData.forEach(reqDef => {
+                    const reqModel = RequirementModel.fromRequirementDefinition(reqDef);
+                    reqModel.id = `${this.newNode.id}_${reqModel.name}`;
+                    this.newNode.requirements.requirement.push(reqModel);
+                });
+            }
+            const capData = this.getCapabilityDefinitionsOfNodeType(this.newNode.type);
+            if (capData) {
+                capData.forEach(capDef => {
+                    const capModel = CapabilityModel.fromCapabilityDefinitionModel(capDef);
+                    capModel.id = `${this.newNode.id}_${capModel.name}`;
+                    this.newNode.capabilities.capability.push(capModel);
+                });
+            }
+        }
     }
 
     /**
@@ -1873,6 +1965,12 @@ export class CanvasComponent implements OnInit, OnDestroy, OnChanges, AfterViewI
         });
     }
 
+    onClickRelationshipTemplateName(clickedRelTemplateId: string): void {
+        const currentRelTemplate = this.allRelationshipTemplates.find(rel => rel.id === clickedRelTemplateId);
+        const connection = this.newJsPlumbInstance.getAllConnections().find(conn => conn.id === clickedRelTemplateId);
+        this.onClickJsPlumbConnection(connection, currentRelTemplate);
+    }
+
     /**
      * Sets the sidebar up for a new node, makes it visible, sets a type and adds a click listener to this relationship
      * @param conn            The JSPlumb connection
@@ -2093,10 +2191,11 @@ export class CanvasComponent implements OnInit, OnDestroy, OnChanges, AfterViewI
                 this.jsPlumbBindConnection = true;
                 if (this.dragSourceInfos) {
                     const sourceNode = info.sourceId;
-                    const sourceElement = this.dragSourceInfos.dragSource.id;
-                    const targetElement = info.targetId.substring(info.targetId.indexOf('.') + 1);
+                    const requirementId = this.dragSourceInfos.dragSource.id;
+                    const capabilityId: string = info.targetId.substring(info.targetId.indexOf('.') + 1);
                     const currentTypeValid = this.entityTypes.relationshipTypes.some(relType => relType.qName === this.selectedRelationshipType.qName);
                     const currentSourceIdValid = this.allNodeTemplates.some(node => node.id === sourceNode);
+
                     if (sourceNode && currentTypeValid && currentSourceIdValid) {
                         const prefix = this.backendService.configuration.relationshipPrefix;
                         const relName = this.selectedRelationshipType.name;
@@ -2106,10 +2205,26 @@ export class CanvasComponent implements OnInit, OnDestroy, OnChanges, AfterViewI
                         do {
                             relationshipId = prefix + '_' + relName + '_' + relNumber++;
                         } while (this.allRelationshipTemplates.find(value => value.id === relationshipId));
-                        if (this.searchTypeAndCheckForCompatibility(this.getCapability(targetElement))) {
+                        const capModel: CapabilityModel = this.getCapability(capabilityId);
+                        const reqModel: RequirementModel = this.dragSourceInfos.dragSource;
+                        const sourceNodeTypeString: string = this.allNodeTemplates
+                            .filter(nodeTemplate => nodeTemplate.id === this.dragSourceInfos.nodeId)
+                            .map(nodeTemplate => nodeTemplate.type)[0];
+                        const targetNodeTypeString: string = this.allNodeTemplates
+                            .filter(nodeTemplate => nodeTemplate.id === info.targetId.substring(0, info.targetId.indexOf('.')))
+                            .map(nodeTemplate => nodeTemplate.type)[0];
+                        const capDef: CapabilityDefinitionModel = this.getCapabilityDefinitionsOfNodeType(targetNodeTypeString)
+                            .filter(current => current.name === capModel.name)[0];
+                        const reqDef: RequirementDefinitionModel = this.getRequirementDefinitionsOfNodeType(sourceNodeTypeString)
+                            .filter(current => current.name === reqModel.name)[0];
+
+                        if (this.checkReqCapCompatibility(reqDef, capDef, capModel, new QName(sourceNodeTypeString), new QName(targetNodeTypeString))) {
+                            reqModel.capability = capModel.name;
+                            reqModel.relationship = relationshipId;
+                            reqModel.node = info.targetId.substring(0, info.targetId.indexOf('.'));
                             const newRelationship = new TRelationshipTemplate(
-                                { ref: sourceElement },
-                                { ref: targetElement },
+                                { ref: requirementId },
+                                { ref: capabilityId },
                                 this.selectedRelationshipType.name,
                                 relationshipId,
                                 this.selectedRelationshipType.qName,
@@ -2127,7 +2242,7 @@ export class CanvasComponent implements OnInit, OnDestroy, OnChanges, AfterViewI
                             }
                         }
                         this.dragSourceActive = false;
-                        this.resetDragSource(sourceElement);
+                        this.resetDragSource(requirementId);
                     }
                     this.unbindConnection();
                     this.revalidateContainer();
@@ -2136,13 +2251,13 @@ export class CanvasComponent implements OnInit, OnDestroy, OnChanges, AfterViewI
         }
     }
 
-    getCapability(targetElement: string) {
+    getCapability(capabilityId: string): CapabilityModel {
         let capability: any = null;
         this.allNodeTemplates.forEach(node => {
             if (node.capabilities) {
                 if (node.capabilities.capability) {
                     node.capabilities.capability.forEach(cap => {
-                        if (cap.id === targetElement) {
+                        if (cap.id === capabilityId) {
                             capability = cap;
                         }
                     });
@@ -2152,11 +2267,29 @@ export class CanvasComponent implements OnInit, OnDestroy, OnChanges, AfterViewI
         return capability;
     }
 
+    checkReqCapCompatibility(reqDefinition: RequirementDefinitionModel, capDefinition: CapabilityDefinitionModel,
+                             cap: CapabilityModel, sourceNodeType: QName, targetNodeType: QName) {
+        if (this.configuration.isYaml()) {
+            // we assume the relationship type is correct
+            // check the conditions set by the requirement definition
+            if (this.matchType(reqDefinition.node, targetNodeType.qName, this.entityTypes.unGroupedNodeTypes) &&
+                this.matchType(reqDefinition.capability, capDefinition.capabilityType, this.entityTypes.capabilityTypes)) {
+                // todo check for the conditions set by the capability definition/type (valid_source_types)
+                return true;
+            } else {
+                this.notify.warning('The Selected Requirement and Capability are not Compatible');
+                return false;
+            }
+        } else {
+            return this.searchTypeAndCheckForCompatibility(cap);
+        }
+    }
+
     /**
      * check for compatibility of Requirement and Capability
-     * @param dragTargetInfo
+     * @param capability the capability model (assignment) to validate
      */
-    searchTypeAndCheckForCompatibility(capability: any) {
+    searchTypeAndCheckForCompatibility(capability: CapabilityModel) {
         let requiredTargetType = '';
 
         this.entityTypes.requirementTypes.some(req => {
@@ -2165,29 +2298,27 @@ export class CanvasComponent implements OnInit, OnDestroy, OnChanges, AfterViewI
                 return true;
             }
         });
-        return this.checkForCompatibility(requiredTargetType, capability);
+        return this.matchType(requiredTargetType, capability.type, this.entityTypes.capabilityTypes);
     }
 
     /**
-     * check recursive if the target or a parent of its Capability matches
-     * @param requiredTargetType
-     * @param targetOrParent
+     * check recursively if the target entity type (or any of its parents) match the required entity type
+     * @param requiredType
+     * @param targetElementType
+     * @param targetElementTypeSet
      */
-    checkForCompatibility(requiredTargetType: any, targetOrParent: any) {
-        let parentCapType: any;
-        if (requiredTargetType === targetOrParent.type) {
+    matchType(requiredType: string, targetElementType: string, targetElementTypeSet: EntityType[]) {
+        if (requiredType === targetElementType) {
             return true;
         } else {
-            this.entityTypes.capabilityTypes.some(cap => {
-                if (cap.qName === targetOrParent.type) {
-                    parentCapType = cap.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].derivedFrom;
-                    return true;
-                }
-            });
-            if (parentCapType) {
-                return this.checkForCompatibility(requiredTargetType, parentCapType);
+            const parentType = targetElementTypeSet
+                .filter(type => type.qName === targetElementType)
+                .map(type => type.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].derivedFrom);
+
+            if (parentType && parentType.length > 0 && parentType[0]) {
+                return this.matchType(requiredType, parentType[0].type, targetElementTypeSet);
             }
-            this.notify.warning('The selected Requirement and Capability are not Compatible');
+
             return false;
         }
     }
diff --git a/org.eclipse.winery.frontends/app/topologymodeler/src/app/enricher/enricher.component.ts b/org.eclipse.winery.frontends/app/topologymodeler/src/app/enricher/enricher.component.ts
index 28c19ff49..40da72ea7 100644
--- a/org.eclipse.winery.frontends/app/topologymodeler/src/app/enricher/enricher.component.ts
+++ b/org.eclipse.winery.frontends/app/topologymodeler/src/app/enricher/enricher.component.ts
@@ -23,6 +23,7 @@ import { TTopologyTemplate } from '../models/ttopology-template';
 import { TopologyTemplateUtil } from '../models/topologyTemplateUtil';
 import { EnricherService } from './enricher.service';
 import { Enrichment, FeatureEntity } from './enrichmentEntity';
+import { WineryRepositoryConfigurationService } from '../../../../tosca-management/src/app/wineryFeatureToggleModule/WineryRepositoryConfiguration.service';
 
 @Component({
     selector: 'winery-enricher',
@@ -40,6 +41,7 @@ export class EnricherComponent {
                 private actions: TopologyRendererActions,
                 private wineryActions: WineryActions,
                 private alert: ToastrService,
+                private configurationService: WineryRepositoryConfigurationService,
                 private enricherService: EnricherService) {
         this.ngRedux.select(state => state.topologyRendererState)
             .subscribe(currentButtonsState => this.checkButtonsState(currentButtonsState));
@@ -205,7 +207,7 @@ export class EnricherComponent {
      * @param data: topology template that was updated
      */
     private enrichmentApplied(data: TTopologyTemplate) {
-        TopologyTemplateUtil.updateTopologyTemplate(this.ngRedux, this.wineryActions, data);
+        TopologyTemplateUtil.updateTopologyTemplate(this.ngRedux, this.wineryActions, data, this.configurationService.isYaml());
         // reset available features since they are no longer valid
         this.availableFeatures = null;
         this.alert.success('Updated Topology Template!');
diff --git a/org.eclipse.winery.frontends/app/topologymodeler/src/app/models/capabilityDefinitionModel.ts b/org.eclipse.winery.frontends/app/topologymodeler/src/app/models/capabilityDefinitionModel.ts
new file mode 100644
index 000000000..84b32c02b
--- /dev/null
+++ b/org.eclipse.winery.frontends/app/topologymodeler/src/app/models/capabilityDefinitionModel.ts
@@ -0,0 +1,23 @@
+/*******************************************************************************
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+export class CapabilityDefinitionModel {
+    public constraints: any;
+    public name: string;
+    public capabilityType: string;
+    public lowerBound: string;
+    public upperBound: string;
+    public documentation: any;
+    public any: any[];
+    public otherAttributes: any;
+}
diff --git a/org.eclipse.winery.frontends/app/topologymodeler/src/app/models/capabilityModel.ts b/org.eclipse.winery.frontends/app/topologymodeler/src/app/models/capabilityModel.ts
index fe20858fe..32fe0c0ac 100644
--- a/org.eclipse.winery.frontends/app/topologymodeler/src/app/models/capabilityModel.ts
+++ b/org.eclipse.winery.frontends/app/topologymodeler/src/app/models/capabilityModel.ts
@@ -12,6 +12,8 @@
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  ********************************************************************************/
 
+import { CapabilityDefinitionModel } from './capabilityDefinitionModel';
+
 /**
  * Encompasses the capability model
  */
@@ -24,6 +26,17 @@ export class CapabilityModel {
     public type: string;
     public properties?: any;
 
+    static fromCapabilityDefinitionModel(def: CapabilityDefinitionModel): CapabilityModel {
+        const result = new CapabilityModel();
+        result.any = def.any;
+        result.documentation = def.documentation;
+        result.name = def.name;
+        result.otherAttributes = def.otherAttributes;
+        result.type = def.capabilityType;
+
+        return result;
+    }
+
     constructor() {
     }
 }
diff --git a/org.eclipse.winery.frontends/app/topologymodeler/src/app/models/requirementDefinitonModel.ts b/org.eclipse.winery.frontends/app/topologymodeler/src/app/models/requirementDefinitonModel.ts
new file mode 100644
index 000000000..92823b722
--- /dev/null
+++ b/org.eclipse.winery.frontends/app/topologymodeler/src/app/models/requirementDefinitonModel.ts
@@ -0,0 +1,30 @@
+/*******************************************************************************
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+
+export class RequirementDefinitionModel {
+    public constraints: any;
+    public name: string;
+    public requirementType?: string;
+    public lowerBound?: string;
+    public upperBound?: string;
+    public capability?: string;
+    public node?: string;
+    public relationship?: string;
+    public documentation: any;
+    public any: any[];
+    public otherAttributes: any;
+
+    constructor() {
+    }
+}
diff --git a/org.eclipse.winery.frontends/app/topologymodeler/src/app/models/requirementModel.ts b/org.eclipse.winery.frontends/app/topologymodeler/src/app/models/requirementModel.ts
index 21cbdcbd8..368dbece7 100644
--- a/org.eclipse.winery.frontends/app/topologymodeler/src/app/models/requirementModel.ts
+++ b/org.eclipse.winery.frontends/app/topologymodeler/src/app/models/requirementModel.ts
@@ -1,5 +1,5 @@
 /********************************************************************************
- * Copyright (c) 2017-2018 Contributors to the Eclipse Foundation
+ * Copyright (c) 2017-2019 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -12,17 +12,37 @@
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  ********************************************************************************/
 
+import { RequirementDefinitionModel } from './requirementDefinitonModel';
+
 /**
  * Encompasses the requirement model
  */
 export class RequirementModel {
     public any: any;
     public documentation: any;
-    public id: string;
+    public id?: string;
     public name: string;
     public otherAttributes: any;
-    public type: string;
+    public type?: string;
     public properties?: any;
+    public capability?: string;
+    public node?: string;
+    public relationship?: string;
+
+
+    static fromRequirementDefinition(def: RequirementDefinitionModel): RequirementModel {
+        const result = new RequirementModel();
+        result.any = def.any;
+        result.documentation = def.documentation;
+        result.name = def.name;
+        result.otherAttributes = def.otherAttributes;
+        result.type = def.requirementType;
+        result.capability = def.capability;
+        result.node = def.node;
+        result.relationship = def.relationship;
+
+        return result;
+    }
 
     constructor() {
     }
diff --git a/org.eclipse.winery.frontends/app/topologymodeler/src/app/models/topologyTemplateUtil.ts b/org.eclipse.winery.frontends/app/topologymodeler/src/app/models/topologyTemplateUtil.ts
index 07f6f7b9a..cb029f5cf 100644
--- a/org.eclipse.winery.frontends/app/topologymodeler/src/app/models/topologyTemplateUtil.ts
+++ b/org.eclipse.winery.frontends/app/topologymodeler/src/app/models/topologyTemplateUtil.ts
@@ -18,13 +18,17 @@ import { Visuals } from './visuals';
 import { NgRedux } from '@angular-redux/store';
 import { IWineryState } from '../redux/store/winery.store';
 import { WineryActions } from '../redux/actions/winery.actions';
+import { CapabilityDefinitionModel } from './capabilityDefinitionModel';
+import { EntityTypesModel } from './entityTypesModel';
+import { CapabilityModel } from './capabilityModel';
 
 export class TopologyTemplateUtil {
 
     static HORIZONTAL_OFFSET_FOR_NODES_WITHOUT_COORDINATES = 350;
     static VERTICAL_OFFSET_FOR_NODES_WITHOUT_COORDINATES = 200;
 
-    static createTNodeTemplateFromObject(node: TNodeTemplate, nodeVisuals: Visuals[], state?: DifferenceStates): TNodeTemplate {
+    static createTNodeTemplateFromObject(node: TNodeTemplate, nodeVisuals: Visuals[],
+                                         isYaml: boolean, types: EntityTypesModel, state?: DifferenceStates): TNodeTemplate {
         const nodeVisualsObject = this.getNodeVisualsForNodeTemplate(node.type, nodeVisuals, state);
         let properties;
         if (node.properties) {
@@ -62,6 +66,37 @@ export class TopologyTemplateUtil {
             }
         }
 
+        // for Yaml, we add missing capabilities, find their types, and fix their ids, we also fix requirement ids (to avoid duplicates)
+        if (isYaml) {
+            if (!types) {
+                // todo ensure entity types model is always available. See TopologyTemplateUtil.updateTopologyTemplate
+                console.error('The required entity types model is not available! Unexpected behavior');
+            }
+            // look for missing capabilities and add them
+            const capDefs = this.getCapabilityDefinitionsOfNodeType(node.type, types);
+
+            if (!node.capabilities || !node.capabilities.capability) {
+                node.capabilities = { capability: [] };
+            }
+            capDefs.forEach(def => {
+                const capAssignments = node.capabilities.capability.filter(capAssignment => capAssignment.name === def.name);
+                let cap;
+
+                if (capAssignments.length > 0) {
+                    cap = capAssignments[0];
+                } else {
+                    cap = CapabilityModel.fromCapabilityDefinitionModel(def);
+                    node.capabilities.capability.push(cap);
+                }
+
+                cap.id = `${node.id}_${cap.name}`;
+            });
+
+            if (node.requirements && node.requirements.requirement) {
+                node.requirements.requirement.forEach(req => req.id = `${node.id}_${req.name}`);
+            }
+        }
+
         return new TNodeTemplate(
             properties ? properties : {},
             node.id,
@@ -83,6 +118,27 @@ export class TopologyTemplateUtil {
         );
     }
 
+    static getCapabilityDefinitionsOfNodeType(nodeType: string, entityTypes: EntityTypesModel): CapabilityDefinitionModel[] {
+        const allNodeTypes = [];
+        entityTypes.groupedNodeTypes.forEach(group => group.children.forEach(nt => allNodeTypes.push(nt)));
+        const match = allNodeTypes
+            .filter(nt => nt.id === nodeType)
+            .filter(nt =>
+                nt.full &&
+                nt.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation &&
+                nt.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation.length > 0 &&
+                nt.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].capabilityDefinitions &&
+                nt.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].capabilityDefinitions.capabilityDefinition &&
+                nt.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].capabilityDefinitions.capabilityDefinition.length > 0
+            );
+
+        if (match && match.length > 0) {
+            return match[0].full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].capabilityDefinitions.capabilityDefinition;
+        }
+
+        return [];
+    }
+
     static createTRelationshipTemplateFromObject(relationship: TRelationshipTemplate, state?: DifferenceStates) {
         return new TRelationshipTemplate(
             relationship.sourceElement,
@@ -115,7 +171,7 @@ export class TopologyTemplateUtil {
         }
     }
 
-    static initNodeTemplates(nodeTemplateArray: Array<TNodeTemplate>, nodeVisuals: Visuals[],
+    static initNodeTemplates(nodeTemplateArray: Array<TNodeTemplate>, nodeVisuals: Visuals[], isYaml: boolean, types: EntityTypesModel,
                              topologyDifferences?: [ToscaDiff, TTopologyTemplate]): Array<TNodeTemplate> {
         const nodeTemplates: TNodeTemplate[] = [];
         if (nodeTemplateArray.length > 0) {
@@ -127,7 +183,7 @@ export class TopologyTemplateUtil {
                 }
                 const state = topologyDifferences ? DifferenceStates.UNCHANGED : null;
                 nodeTemplates.push(
-                    TopologyTemplateUtil.createTNodeTemplateFromObject(node, nodeVisuals, state)
+                    TopologyTemplateUtil.createTNodeTemplateFromObject(node, nodeVisuals, isYaml, types, state)
                 );
             });
         }
@@ -144,52 +200,91 @@ export class TopologyTemplateUtil {
     static getDefaultPropertiesFromEntityTypes(name: string, entities: EntityType[]): any {
         for (const element of entities) {
             if (element.name === name) {
-                // if any is defined with at least one element it's a KV property, sets default values if there aren't
-                // any in the node template
-                if (element.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].any) {
-                    if (element.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].any.length > 0 &&
-                        element.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].any[0].propertyDefinitionKVList) {
-                        const properties = {
-                            kvproperties: TopologyTemplateUtil.setKVProperties(element)
-                        };
-                        return properties;
-                    }
-                    // if propertiesDefinition is defined it's a XML property
-                } else if (element.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].propertiesDefinition
+                // if propertiesDefinition is defined it's a XML property
+                if (element.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].propertiesDefinition
                     && element.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].propertiesDefinition.element) {
-                    const properties = {
+                    return {
                         any: element.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].propertiesDefinition.element
                     };
-                    return properties;
+                } else { // otherwise KV properties or no properties at all
+                    let inheritedProperties = {};
+                    if (this.hasParentType(element)) {
+                        let parent = element.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].derivedFrom.typeRef;
+                        let continueFlag;
 
-                } else {
-                    // else no properties
-                    return null;
+                        while (parent) {
+                            continueFlag = false;
+                            for (const parentElement of entities) {
+                                if (parentElement.qName === parent) {
+                                    if (this.hasKVPropDefinition(parentElement)) {
+                                        inheritedProperties = {
+                                            ...inheritedProperties, ...TopologyTemplateUtil.setKVProperties(parentElement)
+                                        };
+                                    }
+                                    if (this.hasParentType(parentElement)) {
+                                        parent = parentElement.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].derivedFrom.typeRef;
+                                        continueFlag = true;
+                                    }
+                                    break;
+                                }
+                            }
+                            if (continueFlag) {
+                                continue;
+                            }
+                            parent = null;
+                        }
+                    }
+
+                    let typeProperties = {};
+                    if (this.hasKVPropDefinition(element)) {
+                        typeProperties = TopologyTemplateUtil.setKVProperties(element);
+                    }
+
+                    const mergedProperties = { ...inheritedProperties, ...typeProperties };
+
+                    return {
+                        kvproperties: { ...mergedProperties }
+                    };
                 }
             }
         }
     }
 
+    static hasKVPropDefinition(element: EntityType): boolean {
+        return (element && element.full &&
+            element.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].any &&
+            element.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].any.length > 0 &&
+            element.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].any[0].propertyDefinitionKVList
+        );
+    }
+
+    static hasParentType(element: EntityType): boolean {
+        return (element && element.full
+            && element.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0]
+            && element.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].derivedFrom
+        );
+    }
+
     /**
      * This function sets KV properties
      * @param any type: the element type, e.g. capabilityType, requirementType etc.
      * @returns newKVProperties: KV Properties as Object
      */
     static setKVProperties(type: any): any {
-        let newKVProperies;
+        const newKVProperies = {};
         const kvProperties = type.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].any[0].propertyDefinitionKVList;
         for (const obj of kvProperties) {
             const key = obj.key;
             let value;
-            if (!obj.value) {
-                value = '';
+            if (!obj.value && obj.defaultValue) {
+                value = obj.defaultValue;
+            } else if (!obj.value) {
+                // TODO quick hack: set a "system" default
+                value = 'N/A';
             } else {
                 value = obj.value;
             }
-            const keyValuePair = {
-                [key]: value
-            };
-            newKVProperies = { ...newKVProperies, ...keyValuePair };
+            newKVProperies[key] = value;
         }
         return newKVProperies;
     }
@@ -209,7 +304,7 @@ export class TopologyTemplateUtil {
         return relationshipTemplates;
     }
 
-    static updateTopologyTemplate(ngRedux: NgRedux<IWineryState>, wineryActions: WineryActions, topology: TTopologyTemplate) {
+    static updateTopologyTemplate(ngRedux: NgRedux<IWineryState>, wineryActions: WineryActions, topology: TTopologyTemplate, isYaml: boolean) {
         const wineryState = ngRedux.getState().wineryState;
 
         // Required because if the palette is open, the last node inserted will be bound to the mouse movement.
@@ -224,7 +319,7 @@ export class TopologyTemplateUtil {
                 relationship => ngRedux.dispatch(wineryActions.deleteRelationshipTemplate(relationship.id))
             );
 
-        TopologyTemplateUtil.initNodeTemplates(topology.nodeTemplates, wineryState.nodeVisuals)
+        TopologyTemplateUtil.initNodeTemplates(topology.nodeTemplates, wineryState.nodeVisuals, isYaml, null)
             .forEach(
                 node => ngRedux.dispatch(wineryActions.saveNodeTemplate(node))
             );
diff --git a/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/capabilities/capabilities.component.html b/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/capabilities/capabilities.component.html
index c0f5d2f41..2805c3400 100644
--- a/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/capabilities/capabilities.component.html
+++ b/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/capabilities/capabilities.component.html
@@ -1,5 +1,5 @@
 <!--
- * Copyright (c) 2017-2018 Contributors to the Eclipse Foundation
+ * Copyright (c) 2017-2019 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -21,9 +21,11 @@
     </winery-toscatype-table>
 </div>
 
-<div *ngIf="!capabilitiesExist" style="color: dimgray; text-align: center">
+<div *ngIf="!capabilities || capabilities.length == 0" style="color: dimgray; text-align: center">
     <span>No capabilities defined <br> for this Node Template.</span></div>
 
-<div *ngIf="!readonly" (click)="toggleModal($event);" class="btn btn-sm btn-modal" style="display: block;">
-    Add new Capability
+<div *wineryRepositoryHideOnFeature="'yaml'">
+    <div *ngIf="!readonly" (click)="toggleModal($event);" class="btn btn-sm btn-modal" style="display: block;">
+        Add new Capability
+    </div>
 </div>
diff --git a/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/capabilities/capabilities.component.ts b/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/capabilities/capabilities.component.ts
index ab9ce26e7..14e71e845 100644
--- a/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/capabilities/capabilities.component.ts
+++ b/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/capabilities/capabilities.component.ts
@@ -1,5 +1,5 @@
 /********************************************************************************
- * Copyright (c) 2017-2018 Contributors to the Eclipse Foundation
+ * Copyright (c) 2017-2019 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -20,6 +20,8 @@ import { IWineryState } from '../../redux/store/winery.store';
 import { Subscription } from 'rxjs';
 import { CapabilityModel } from '../../models/capabilityModel';
 import { ToscaTypes } from '../../../../../tosca-management/src/app/model/enums';
+import { WineryRepositoryConfigurationService } from '../../../../../tosca-management/src/app/wineryFeatureToggleModule/WineryRepositoryConfiguration.service';
+import { ReqCapModalType, ShowReqCapModalEventData } from '../toscatype-table/showReqCapModalEventData';
 
 @Component({
     selector: 'winery-capabilities',
@@ -44,7 +46,7 @@ export class CapabilitiesComponent implements OnInit, OnChanges, OnDestroy {
     subscription: Subscription;
     currentCapability: CapabilityModel;
 
-    constructor(private ngRedux: NgRedux<IWineryState>) {
+    constructor(private ngRedux: NgRedux<IWineryState>, private configuration: WineryRepositoryConfigurationService) {
         this.toggleModalHandler = new EventEmitter();
         this.subscription = this.ngRedux.select(state => state.wineryState.currentJsonTopology.nodeTemplates)
             .subscribe(currentNodes => this.updateCaps());
@@ -74,15 +76,14 @@ export class CapabilitiesComponent implements OnInit, OnChanges, OnDestroy {
 
     /**
      * Propagates the click event to node.component, where the capabilities modal gets opened.
-     * @param $event
+     * @param event the id of the capability that was clicked.
      */
-    public toggleModal($event) {
+    public toggleModal(event: ShowReqCapModalEventData) {
         this.currentCapability = null;
-        const currentCapId = $event.srcElement.textContent;
 
         if (this.capabilities) {
             this.capabilities.some(cap => {
-                if (cap.id === currentCapId) {
+                if (cap.id === event.id) {
                     this.currentCapability = cap;
                     return true;
                 }
@@ -91,7 +92,7 @@ export class CapabilitiesComponent implements OnInit, OnChanges, OnDestroy {
             this.capabilities = [];
         }
 
-        if ($event.srcElement.innerText === 'Add new') {
+        if (event.operation === ReqCapModalType.AddNew) {
             this.currentNodeData.currentCapability = null;
         } else {
             this.currentNodeData.currentCapability = this.currentCapability;
diff --git a/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/node.component.html b/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/node.component.html
index 5e841e86c..a52b3db60 100644
--- a/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/node.component.html
+++ b/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/node.component.html
@@ -115,17 +115,19 @@
         </div>
     </ng-template>
 
-    <div class="endpointContainer center-block row" style="border: 0; box-shadow: none"
-         *ngIf="connectorEndpointVisible && !readonly"
-         (mouseover)="makeSource($event)">
-        <div class="btn-group-vertical btn-group-sm center-block" role="group" id={{dragSource}}
-             (mousedown)="passCurrentType($event)">
-            <button *ngFor="let rel of entityTypes.relationshipTypes"
-                    type="button" class="btn btn-sm btn-outline-secondary btn-block"
-                    [style.border-color]="this.nodeTemplate?.color" [style.color]="rel.color"
-                    style="font-size: x-small;">
-                <i class="fa fa-arrow-circle-o-right" aria-hidden="true" style="padding-left: 1em;"></i> {{rel.id}}
-            </button>
+    <div *wineryRepositoryHideOnFeature="'yaml'">
+        <div class="endpointContainer center-block row" style="border: 0; box-shadow: none"
+             *ngIf="connectorEndpointVisible && !readonly"
+             (mouseover)="makeSource($event)">
+            <div class="btn-group-vertical btn-group-sm center-block" role="group" id={{dragSource}}
+                 (mousedown)="passCurrentType($event)">
+                <button *ngFor="let rel of entityTypes.relationshipTypes"
+                        type="button" class="btn btn-sm btn-outline-secondary btn-block"
+                        [style.border-color]="this.nodeTemplate?.color" [style.color]="rel.color"
+                        style="font-size: x-small;">
+                    <i class="fa fa-arrow-circle-o-right" aria-hidden="true" style="padding-left: 1em;"></i> {{rel.id}}
+                </button>
+            </div>
         </div>
     </div>
 
@@ -189,6 +191,7 @@
             <winery-requirements
                 [readonly]="readonly"
                 (toggleModalHandler)="sendToggleAction($event)"
+                (relationshipTemplateIdClicked)="onRelationshipTemplateIdClicked($event)"
                 [currentNodeData]="{entityTypes: entityTypes,
                                     nodeTemplate: nodeTemplate,
                                     currentNodePart: 'REQUIREMENTS'}">
diff --git a/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/node.component.ts b/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/node.component.ts
index e8ebbeef0..fc48844e9 100644
--- a/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/node.component.ts
+++ b/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/node.component.ts
@@ -23,7 +23,6 @@ import { EntityType, TNodeTemplate } from '../models/ttopology-template';
 import { QName } from '../models/qname';
 import { PropertyDefinitionType, urlElement } from '../models/enums';
 import { BackendService } from '../services/backend.service';
-import { isNullOrUndefined } from 'util';
 import { GroupedNodeTypeModel } from '../models/groupedNodeTypeModel';
 import { EntityTypesModel } from '../models/entityTypesModel';
 import { TopologyRendererState } from '../redux/reducers/topologyRenderer.reducer';
@@ -92,6 +91,7 @@ export class NodeComponent implements OnInit, AfterViewInit, OnDestroy, DoCheck
     @Output() saveNodeRequirements: EventEmitter<any>;
     @Output() sendPaletteStatus: EventEmitter<any>;
     @Output() sendNodeData: EventEmitter<any>;
+    @Output() relationshipTemplateIdClicked: EventEmitter<string>;
 
     @ViewChild('versionModal') versionModal: VersionsComponent;
     previousPosition: any;
@@ -128,6 +128,7 @@ export class NodeComponent implements OnInit, AfterViewInit, OnDestroy, DoCheck
         this.saveNodeRequirements = new EventEmitter();
         this.sendPaletteStatus = new EventEmitter();
         this.sendNodeData = new EventEmitter();
+        this.relationshipTemplateIdClicked = new EventEmitter<string>();
     }
 
     /**
@@ -151,13 +152,17 @@ export class NodeComponent implements OnInit, AfterViewInit, OnDestroy, DoCheck
         groupedNodeTypes.some(nameSpace => {
             nameSpace.children.some(nodeTypeVar => {
                 if (nodeTypeVar.id === type) {
+                    const node = nodeTypeVar.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0];
                     // if PropertiesDefinition doesn't exist then it must be of type NONE
-                    if (isNullOrUndefined(nodeTypeVar.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].propertiesDefinition)) {
+                    if (!node.propertiesDefinition && node.derivedFrom) {
+                        // check all parents; property definition types
+                        propertyDefinitionTypeAssigned = this.checkParentPropertyDefinitions(node.derivedFrom.typeRef);
+                    } else if (!node.propertiesDefinition) {
                         this.propertyDefinitionType = PropertyDefinitionType.NONE;
                         propertyDefinitionTypeAssigned = true;
                     } else {
                         // if no XML element inside PropertiesDefinition then it must be of type Key Value
-                        if (!nodeTypeVar.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0].propertiesDefinition.element) {
+                        if (!node.propertiesDefinition.element) {
                             this.propertyDefinitionType = PropertyDefinitionType.KV;
                             propertyDefinitionTypeAssigned = true;
                         } else {
@@ -175,6 +180,36 @@ export class NodeComponent implements OnInit, AfterViewInit, OnDestroy, DoCheck
         });
     }
 
+    checkParentPropertyDefinitions(parentType: string): boolean {
+        let parentFound = false;
+        this.entityTypes.unGroupedNodeTypes.forEach(entry => {
+            if (entry.qName === parentType) {
+                parentFound = true;
+                const node = entry.full.serviceTemplateOrNodeTypeOrNodeTypeImplementation[0];
+                if (!node.propertiesDefinition && node.derivedFrom) {
+                    this.checkParentPropertyDefinitions(node.derivedFrom.typeRef);
+                } else if (!node.propertiesDefinition) {
+                    this.propertyDefinitionType = PropertyDefinitionType.NONE;
+                    return true;
+                } else {
+                    if (!node.propertiesDefinition.element) {
+                        this.propertyDefinitionType = PropertyDefinitionType.KV;
+                    } else {
+                        this.propertyDefinitionType = PropertyDefinitionType.XML;
+                    }
+                    return true;
+                }
+            }
+        });
+
+        if (!parentFound) {
+            this.propertyDefinitionType = PropertyDefinitionType.NONE;
+            return true;
+        }
+
+        return true;
+    }
+
     /**
      * Angular lifecycle event.
      */
@@ -230,6 +265,10 @@ export class NodeComponent implements OnInit, AfterViewInit, OnDestroy, DoCheck
         }
     }
 
+    onRelationshipTemplateIdClicked(id: string) {
+        this.relationshipTemplateIdClicked.emit(id);
+    }
+
     /**
      * Triggered when opening a modal to send node data to the canvas for handling the addition of modal data.
      */
diff --git a/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/requirements/requirements.component.html b/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/requirements/requirements.component.html
index 121a5ad0d..c47509da1 100644
--- a/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/requirements/requirements.component.html
+++ b/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/requirements/requirements.component.html
@@ -12,20 +12,23 @@
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
 -->
 
-<div id="requirementDiv" *ngIf="requirementsExist">
+<div id="requirementDiv" *ngIf="requirements?.length">
     <winery-toscatype-table
         [toscaType]="toscaTypes.RequirementType"
         [currentNodeData]="currentNodeData"
         [toscaTypeData]="requirements"
         [entityTypes]="entityTypes"
+        (relationshipTemplateIdClicked)="onRelationshipTemplateIdClicked($event)"
         (showClickedReqOrCapModal)="toggleModal($event)">
     </winery-toscatype-table>
 </div>
 
-<div *ngIf="!requirementsExist" style="color: dimgray; text-align: center">
+<div *ngIf="!requirements || requirements.length == 0" style="color: dimgray; text-align: center">
     <span>No requirements defined <br> for this Node Template.</span></div>
 
-<div *ngIf="!readonly" (click)="toggleModal($event);" class="btn btn-sm btn-modal" style="display: block;">
-    Add new Requirement
+<div *wineryRepositoryHideOnFeature="'yaml'">
+    <div *ngIf="!readonly" (click)="toggleModal($event);" class="btn btn-sm btn-modal" style="display: block;">
+        Add new Requirement
+    </div>
 </div>
 
diff --git a/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/requirements/requirements.component.ts b/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/requirements/requirements.component.ts
index 9321ab546..c2dd7b25a 100644
--- a/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/requirements/requirements.component.ts
+++ b/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/requirements/requirements.component.ts
@@ -1,5 +1,5 @@
 /********************************************************************************
- * Copyright (c) 2017-2018 Contributors to the Eclipse Foundation
+ * Copyright (c) 2017-2019 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -34,6 +34,7 @@ export class RequirementsComponent implements OnInit, OnChanges, OnDestroy {
     readonly toscaTypes = ToscaTypes;
 
     @Output() toggleModalHandler: EventEmitter<any>;
+    @Output() relationshipTemplateIdClicked: EventEmitter<string>;
     @Input() readonly: boolean;
     @Input() currentNodeData: any;
     requirements: any[] = [];
@@ -45,8 +46,9 @@ export class RequirementsComponent implements OnInit, OnChanges, OnDestroy {
 
     constructor(private ngRedux: NgRedux<IWineryState>) {
         this.toggleModalHandler = new EventEmitter();
+        this.relationshipTemplateIdClicked = new EventEmitter<string>();
         this.subscription = this.ngRedux.select(state => state.wineryState.currentJsonTopology.nodeTemplates)
-            .subscribe(currentNodes => this.updateReqs());
+            .subscribe(() => this.updateReqs());
     }
 
     /**
@@ -71,6 +73,10 @@ export class RequirementsComponent implements OnInit, OnChanges, OnDestroy {
         }
     }
 
+    public onRelationshipTemplateIdClicked(id: string) {
+        this.relationshipTemplateIdClicked.emit(id);
+    }
+
     /**
      * Propagates the click event to node.component, where requirements modal gets opened.
      * @param $event
diff --git a/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/toscatype-table/showReqCapModalEventData.ts b/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/toscatype-table/showReqCapModalEventData.ts
new file mode 100644
index 000000000..8c77d072c
--- /dev/null
+++ b/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/toscatype-table/showReqCapModalEventData.ts
@@ -0,0 +1,27 @@
+/*******************************************************************************
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+export class ShowReqCapModalEventData {
+    public id: string;
+    public operation: ReqCapModalType;
+
+    constructor(id: string, operation: number) {
+        this.id = id;
+        this.operation = operation;
+    }
+}
+
+export enum ReqCapModalType {
+    AddNew,
+    Edit
+}
diff --git a/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/toscatype-table/toscatype-table.component.css b/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/toscatype-table/toscatype-table.component.css
index ba7304112..33c461728 100644
--- a/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/toscatype-table/toscatype-table.component.css
+++ b/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/toscatype-table/toscatype-table.component.css
@@ -23,7 +23,7 @@ table {
 th {
     background-color: #CFD8DC;
     color: #000;
-    text-align: center;
+    text-align: left;
 }
 
 th, td {
@@ -31,6 +31,7 @@ th, td {
     border-left: 0;
     border-right: 0;
     border-bottom: 1px solid #ddd;
+    padding-left: 2px;
 }
 
 tr {
diff --git a/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/toscatype-table/toscatype-table.component.html b/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/toscatype-table/toscatype-table.component.html
index a0119205e..6513dac01 100644
--- a/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/toscatype-table/toscatype-table.component.html
+++ b/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/toscatype-table/toscatype-table.component.html
@@ -70,51 +70,150 @@
     </tbody>
 </table>
 
-<table *ngIf="toscaType === toscaTypes.CapabilityType || toscaType === toscaTypes.RequirementType"
-       class="toscatype-table">
-    <thead>
-    <tr>
-        <th *ngIf="toscaType === toscaTypes.CapabilityType" width="25px"></th>
-        <th>Endpoint</th>
-        <th>Id</th>
-        <th>Name</th>
-        <th *ngIf="toscaType === toscaTypes.RequirementType"></th>
-    </tr>
-    </thead>
-    <tbody>
-    <tr *ngFor="let reqOrCap of currentToscaTypeData">
-        <td *ngIf="toscaType === toscaTypes.CapabilityType" class="toscatype-table-td">
-            <button type="button" class="reqCap-button btn btn-sm btn-outline-secondary btn-block"
-                    style="font-size: x-small;" id="{{currentNodeData.nodeTemplate.id +'.'+ reqOrCap.id}}">
-                <i class="fa fa-dot-circle-o" aria-hidden="true"></i> {{""}}
-            </button>
-        </td>
-        <td class="toscatype-table-td"
-            [class.cell-with-comment]="isEllipsisActive(reqOrCapType)">
-            <div #reqOrCapType (click)="clickReqOrCapType(reqOrCap.type)">{{ reqOrCap.type | localname }}</div>
-            <span class="cell-comment">{{ reqOrCap.type | localname }}</span>
-        </td>
-        <td class="toscatype-table-td"
-            [class.cell-with-comment]="isEllipsisActive(reqOrCapName)">
-            <div #reqOrCapName (click)="showExistingReqOrCapModal($event)">{{ reqOrCap.id }}</div>
-            <span class="cell-comment">{{ reqOrCap.name }}</span>
-        </td>
-        <td class="toscatype-table-td"
-            [class.cell-with-comment]="isEllipsisActive(reqOrCapRef)">
-            <div #reqOrCapRef (click)="clickReqOrCapRef(reqOrCap.name)">{{ reqOrCap.name }}</div>
-            <span class="cell-comment">{{ reqOrCap.name }}</span>
-        </td>
-        <td *ngIf="toscaType === toscaTypes.RequirementType" class="toscatype-table-td">
-            <div (mousedown)="passCurrentType($event);
+<div *ngIf="toscaType === toscaTypes.CapabilityType || toscaType === toscaTypes.RequirementType">
+
+    <table *wineryRepositoryHideOnFeature="'yaml'"
+           class="toscatype-table">
+        <thead>
+        <tr>
+            <th *ngIf="toscaType === toscaTypes.CapabilityType" width="25px"></th>
+            <th>Endpoint</th>
+            <th>Id</th>
+            <th>Name</th>
+            <th *ngIf="toscaType === toscaTypes.RequirementType"></th>
+        </tr>
+        </thead>
+        <tbody>
+        <tr *ngFor="let reqOrCap of currentToscaTypeData">
+            <td *ngIf="toscaType === toscaTypes.CapabilityType" class="toscatype-table-td">
+                <button type="button" class="reqCap-button btn btn-sm btn-outline-secondary btn-block"
+                        style="font-size: x-small;" id="{{currentNodeData.nodeTemplate.id +'.'+ reqOrCap.id}}">
+                    <i class="fa fa-dot-circle-o" aria-hidden="true"></i> {{""}}
+                </button>
+            </td>
+            <td class="toscatype-table-td"
+                [class.cell-with-comment]="isEllipsisActive(reqOrCapType)">
+                <div #reqOrCapType (click)="clickReqOrCapType(reqOrCap.type)">{{ reqOrCap.type | localname }}</div>
+                <span class="cell-comment">{{ reqOrCap.type | localname }}</span>
+            </td>
+            <td class="toscatype-table-td"
+                [class.cell-with-comment]="isEllipsisActive(reqOrCapName)">
+                <div #reqOrCapName
+                     (click)="showExistingReqOrCapModal(reqOrCap.id, editOperation)">{{ reqOrCap.id }}</div>
+                <span class="cell-comment">{{ reqOrCap.name }}</span>
+            </td>
+            <td class="toscatype-table-td"
+                [class.cell-with-comment]="isEllipsisActive(reqOrCapRef)">
+                <div #reqOrCapRef (click)="clickReqOrCapRef(reqOrCap.name)">{{ reqOrCap.name }}</div>
+                <span class="cell-comment">{{ reqOrCap.name }}</span>
+            </td>
+            <td *ngIf="toscaType === toscaTypes.RequirementType" class="toscatype-table-td">
+                <div (mousedown)="passCurrentType($event);
             reqCapRelationshipService.createSourceInfo(this.currentNodeData, reqOrCap);">
-                <div class="btn-group-vertical center-block" role="group" id={{dragSource}}>
-                    <button *ngFor="let rel of entityTypes.relationshipTypes"
-                            type="button" class="reqCap-button btn btn-sm btn-outline-secondary btn-block"
-                            style="font-size: xx-small;">{{rel.id}}
-                    </button>
+                    <div class="btn-group-vertical center-block" role="group" id={{dragSource}} style="width: 100%;">
+                        <button *ngFor="let rel of entityTypes.relationshipTypes"
+                                type="button" class="reqCap-button btn btn-sm btn-outline-secondary btn-block"
+                                style="font-size: xx-small;">{{rel.id}}
+                        </button>
+                    </div>
                 </div>
-            </div>
-        </td>
-    </tr>
-    </tbody>
-</table>
+            </td>
+        </tr>
+        </tbody>
+    </table>
+
+    <div *wineryRepositoryShowOnFeature="'yaml'">
+        <table *ngIf="toscaType === toscaTypes.RequirementType"
+               class="toscatype-table">
+            <thead>
+            <tr>
+                <th>Name</th>
+                <th>Current Relationship</th>
+                <th>Possible Relationships</th>
+            </tr>
+            </thead>
+            <tbody>
+            <tr *ngFor="let req of currentToscaTypeData">
+                <td class="toscatype-table-td"
+                    [class.cell-with-comment]="isEllipsisActive(reqRef)">
+                    <div #reqRef (click)="clickYamlReqRef()">{{ req.name }}</div>
+                    <span class="cell-comment">{{ req.name }}</span>
+                </td>
+                <td class="toscatype-table-td" *ngIf="req.relationship"
+                    [class.cell-with-comment]="isEllipsisActive(reqRelationship)">
+                    <div #reqRelationship (click)="clickYamlRelationshipTemplateId(req.relationship, req)">{{req.relationship}}</div>
+                    <span class="cell-comment">{{ req.relationship }}</span>
+                </td>
+                <td class="toscatype-table-td" *ngIf="!req.relationship"> N/A</td>
+                <td class="toscatype-table-td" *ngIf="isRequirementFulfilled(req); else newRelationship">
+
+                    <div class="btn-group-vertical center-block" role="group" id={{dragSource}}
+                         style="width: 100%;">
+                        <button *ngFor="let rel of getAllowedRelationshipTypes(req)"
+                                [disabled]="true"
+                                type="button" class="reqCap-button btn btn-sm btn-outline-secondary btn-block"
+                                style="font-size: xx-small; ">{{rel.id}}
+                        </button>
+                    </div>
+
+                </td>
+                <ng-template #newRelationship>
+                    <td class="toscatype-table-td">
+                        <div (mousedown)="passCurrentType($event);
+            reqCapRelationshipService.createSourceInfo(this.currentNodeData, req);">
+                            <div class="btn-group-vertical center-block" role="group" id={{dragSource}}
+                                 style="width: 100%;">
+                                <button *ngFor="let rel of getAllowedRelationshipTypes(req)"
+                                        type="button" class="reqCap-button btn btn-sm btn-outline-secondary btn-block"
+                                        style="font-size: xx-small;">{{rel.id}}
+                                </button>
+                            </div>
+                        </div>
+                    </td>
+                </ng-template>
+            </tr>
+            </tbody>
+        </table>
+
+        <table *ngIf="toscaType === toscaTypes.CapabilityType"
+               class="toscatype-table">
+            <thead>
+            <tr>
+                <th *ngIf="toscaType === toscaTypes.CapabilityType" width="25px"></th>
+                <th>Name</th>
+                <th>Type</th>
+                <th>Actions</th>
+            </tr>
+            </thead>
+            <tbody>
+            <tr *ngFor="let cap of currentToscaTypeData">
+                <td class="toscatype-table-td">
+                    <button type="button" class="reqCap-button btn btn-sm btn-outline-secondary btn-block"
+                            style="font-size: x-small;" id="{{currentNodeData.nodeTemplate.id +'.'+ cap.id}}">
+                        <i class="fa fa-dot-circle-o" aria-hidden="true"></i> {{''}}
+                    </button>
+                </td>
+                <td class="toscatype-table-td" [class.cell-with-comment]="isEllipsisActive(capName)">
+                    <div #capName (click)="clickYamlCapRef()">{{ cap.name }}</div>
+                    <span class="cell-comment">{{ cap.name }}</span>
+                </td>
+                <td class="toscatype-table-td"
+                    [class.cell-with-comment]="isEllipsisActive(capType)">
+                    <div #capType (click)="clickReqOrCapType(cap.type)">{{ cap.type | localname }}</div>
+                    <span class="cell-comment">{{ cap.type }}</span>
+                </td>
+                <td class="toscatype-table-td">
+                    <div class="btn-group-vertical center-block" role="group" style="width: 100%"
+                         (click)="showExistingReqOrCapModal(cap.id, editOperation)">
+                        <button type="button" class="reqCap-button btn btn-sm btn-outline-secondary btn-block"
+                                style="font-size: xx-small;">
+                            Edit
+                        </button>
+                    </div>
+                </td>
+            </tr>
+            </tbody>
+        </table>
+    </div>
+</div>
+
diff --git a/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/toscatype-table/toscatype-table.component.ts b/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/toscatype-table/toscatype-table.component.ts
index da15322a7..8d3ab4ce8 100644
--- a/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/toscatype-table/toscatype-table.component.ts
+++ b/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/toscatype-table/toscatype-table.component.ts
@@ -21,6 +21,11 @@ import { BackendService } from '../../services/backend.service';
 import { EntityTypesModel } from '../../models/entityTypesModel';
 import { ReqCapRelationshipService } from '../../services/req-cap-relationship.service';
 import { ToscaTypes } from '../../../../../tosca-management/src/app/model/enums';
+import { WineryRepositoryConfigurationService } from '../../../../../tosca-management/src/app/wineryFeatureToggleModule/WineryRepositoryConfiguration.service';
+import { ReqCapModalType, ShowReqCapModalEventData } from './showReqCapModalEventData';
+import { RequirementModel } from '../../models/requirementModel';
+import { RequirementDefinitionModel } from '../../models/requirementDefinitonModel';
+import { VisualEntityType } from '../../models/ttopology-template';
 
 @Component({
     selector: 'winery-toscatype-table',
@@ -29,6 +34,8 @@ import { ToscaTypes } from '../../../../../tosca-management/src/app/model/enums'
 })
 export class ToscatypeTableComponent implements OnInit, OnChanges {
 
+    readonly editOperation = ReqCapModalType.Edit;
+    readonly newOperation = ReqCapModalType.AddNew;
     readonly toscaTypes = ToscaTypes;
     readonly tableType = TableType;
 
@@ -38,7 +45,8 @@ export class ToscatypeTableComponent implements OnInit, OnChanges {
     @Input() entityTypes: EntityTypesModel;
 
     // Event emitter for showing the modal of a clicked capability or requirement id
-    @Output() showClickedReqOrCapModal: EventEmitter<any>;
+    @Output() showClickedReqOrCapModal: EventEmitter<ShowReqCapModalEventData>;
+    @Output() relationshipTemplateIdClicked: EventEmitter<string>;
 
     currentToscaTypeData;
     currentToscaType;
@@ -46,8 +54,10 @@ export class ToscatypeTableComponent implements OnInit, OnChanges {
 
     constructor(private entitiesModalService: EntitiesModalService,
                 private backendService: BackendService,
-                private reqCapRelationshipService: ReqCapRelationshipService) {
+                private reqCapRelationshipService: ReqCapRelationshipService,
+                private configurationService: WineryRepositoryConfigurationService) {
         this.showClickedReqOrCapModal = new EventEmitter();
+        this.relationshipTemplateIdClicked = new EventEmitter<string>();
     }
 
     ngOnInit() {
@@ -62,7 +72,7 @@ export class ToscatypeTableComponent implements OnInit, OnChanges {
         }
     }
 
-    isEllipsisActive(cell) {
+    isEllipsisActive(cell): boolean {
         return (cell.offsetWidth < cell.scrollWidth);
     }
 
@@ -150,11 +160,12 @@ export class ToscatypeTableComponent implements OnInit, OnChanges {
 
     /**
      * This modal handler gets triggered upon clicking on a capability or requirement id in the table
-     * @param clickEvent - this holds the information about the click event, needed for determining which element was
-     *     clicked
+     * @param id - the id of the rea/cap that was clicked.
+     * @param operation the type of the requested operation.
      */
-    showExistingReqOrCapModal(clickEvent: any): void {
-        this.showClickedReqOrCapModal.emit(clickEvent);
+    showExistingReqOrCapModal(id: string, operation: ReqCapModalType): void {
+        const event = new ShowReqCapModalEventData(id, operation);
+        this.showClickedReqOrCapModal.emit(event);
     }
 
     /**
@@ -164,18 +175,78 @@ export class ToscatypeTableComponent implements OnInit, OnChanges {
      */
     clickReqOrCapRef(reqOrCapRef: string) {
         let clickedDefinition;
+        let url;
         if (this.toscaType === this.toscaTypes.RequirementType) {
             clickedDefinition = definitionType.RequirementDefinitions;
         } else {
             clickedDefinition = definitionType.CapabilityDefinitions;
         }
-        const url = this.backendService.configuration.uiURL
+
+        url = this.backendService.configuration.uiURL
             + urlElement.NodeTypeURL
             + encodeURIComponent(encodeURIComponent(this.getNamespace(this.currentNodeData.nodeTemplate.type)))
             + '/' + this.getLocalName(this.currentNodeData.nodeTemplate.type) + clickedDefinition;
+
+        window.open(url, '_blank');
+    }
+
+    clickYamlReqRef(): void {
+        const url = this.backendService.configuration.uiURL
+            + urlElement.NodeTypeURL
+            + this.getNamespace(this.currentNodeData.nodeTemplate.type)
+            + '/' + this.getLocalName(this.currentNodeData.nodeTemplate.type)
+            + '/requirementdefinitionsyaml/';
+
+        window.open(url, '_blank');
+    }
+
+    clickYamlCapRef(): void {
+        const url = this.backendService.configuration.uiURL
+            + urlElement.NodeTypeURL
+            + this.getNamespace(this.currentNodeData.nodeTemplate.type)
+            + '/' + this.getLocalName(this.currentNodeData.nodeTemplate.type)
+            + definitionType.CapabilityDefinitions;
+
         window.open(url, '_blank');
     }
 
+    clickYamlRelationshipTemplateId(id: string, req: RequirementModel) {
+        // the id might not belong to a relationship template if the requirement is not yet fulfilled.
+        if (this.isRequirementFulfilled(req)) {
+            this.relationshipTemplateIdClicked.emit(id);
+        }
+    }
+
+    private getRequirementDefinition(req: RequirementModel): RequirementDefinitionModel {
+        const nodeTypeString = this.currentNodeData.nodeTemplate.type;
+        return this.entityTypes.unGroupedNodeTypes
+            .find(nt => nt.qName === nodeTypeString)
+            .full
+            .serviceTemplateOrNodeTypeOrNodeTypeImplementation[0]
+            .requirementDefinitions
+            .requirementDefinition
+            .find((reqDef: RequirementDefinitionModel) => reqDef.name === req.name);
+    }
+
+    getAllowedRelationshipTypes(req: RequirementModel): VisualEntityType[] {
+        const reqDef: RequirementDefinitionModel = this.getRequirementDefinition(req);
+        // if the requirement definition specifies a requirement type, then it is the only one allowed
+        if (reqDef.relationship) {
+            return this.entityTypes.relationshipTypes.filter(rt => rt.qName === reqDef.relationship);
+        }
+        // otherwise, all types are allowed
+        return this.entityTypes.relationshipTypes;
+    }
+
+    isRequirementFulfilled(req: RequirementModel) {
+        if (req.node) {
+            // if the node value of the requirement model is a node type (rather than a node template), then it is not yet fulfilled.
+            return !this.entityTypes.unGroupedNodeTypes.some(nt => nt.qName === req.node);
+        }
+        // this should never happen..
+        return false;
+    }
+
     /**
      * Gets triggered upon clicking on a capability or requirement type in the table, links to the defined type in the
      * management UI
@@ -189,7 +260,7 @@ export class ToscatypeTableComponent implements OnInit, OnChanges {
             clickedType = urlElement.CapabilityTypeURL;
         }
         const url = this.backendService.configuration.uiURL
-            + '#' + clickedType
+            + clickedType
             + encodeURIComponent(encodeURIComponent(this.getNamespace(reqOrCapType)))
             + '/' + this.getLocalName(reqOrCapType);
         window.open(url, '_blank');
diff --git a/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/versions/versions.component.ts b/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/versions/versions.component.ts
index 81f01e2f9..0532f8ea3 100644
--- a/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/versions/versions.component.ts
+++ b/org.eclipse.winery.frontends/app/topologymodeler/src/app/node/versions/versions.component.ts
@@ -26,6 +26,7 @@ import { WineryActions } from '../../redux/actions/winery.actions';
 import { PropertyDiffList } from '../../models/propertyDiffList';
 import { Utils } from '../../../../../tosca-management/src/app/wineryUtils/utils';
 import { WineryVersion } from '../../../../../tosca-management/src/app/model/wineryVersion';
+import { WineryRepositoryConfigurationService } from '../../../../../tosca-management/src/app/wineryFeatureToggleModule/WineryRepositoryConfiguration.service';
 
 @Component({
     selector: 'winery-versions',
@@ -66,6 +67,7 @@ export class VersionsComponent implements OnInit {
                 private updateService: UpdateService,
                 private errorHandler: ErrorHandlerService,
                 private ngRedux: NgRedux<IWineryState>,
+                private configurationService: WineryRepositoryConfigurationService,
                 private wineryActions: WineryActions) {
     }
 
@@ -150,7 +152,7 @@ export class VersionsComponent implements OnInit {
     }
 
     updateTopology(topology: TTopologyTemplate) {
-        TopologyTemplateUtil.updateTopologyTemplate(this.ngRedux, this.wineryActions, topology);
+        TopologyTemplateUtil.updateTopologyTemplate(this.ngRedux, this.wineryActions, topology, this.configurationService.isYaml());
     }
 
     showKVComparison() {
diff --git a/org.eclipse.winery.frontends/app/topologymodeler/src/app/palette/palette.component.ts b/org.eclipse.winery.frontends/app/topologymodeler/src/app/palette/palette.component.ts
index d14bb354c..436d9ce86 100644
--- a/org.eclipse.winery.frontends/app/topologymodeler/src/app/palette/palette.component.ts
+++ b/org.eclipse.winery.frontends/app/topologymodeler/src/app/palette/palette.component.ts
@@ -141,9 +141,9 @@ export class PaletteComponent implements OnDestroy {
         const nodeVisuals: Visuals = TopologyTemplateUtil.getNodeVisualsForNodeTemplate(newIdTypeColorProperties.type, this.entityTypes.nodeVisuals);
         const newNode: TNodeTemplate = new TNodeTemplate(
             newIdTypeColorProperties.properties,
-            newIdTypeColorProperties.id,
+            this.removeVersionIdentifier(newIdTypeColorProperties.id),
             newIdTypeColorProperties.type,
-            child.text,
+            this.removeVersionIdentifier(child.text),
             1,
             1,
             nodeVisuals,
@@ -160,6 +160,15 @@ export class PaletteComponent implements OnDestroy {
         this.ngRedux.dispatch(this.actions.saveNodeTemplate(newNode));
     }
 
+    /**
+     * strips versioning substring
+     * @param name
+     * @return result
+     */
+    removeVersionIdentifier(name: string): string {
+        return name.replace(/_([a-zA-Z0-9\.\-]*)(-w[0-9]+)(-wip[0-9]+)?/g, '');
+    }
+
     /**
      * Generates a new unique node id, type, color and properties
      * @param name
@@ -179,6 +188,7 @@ export class PaletteComponent implements OnDestroy {
                 name = name.replace(/\s+/g, '');
                 if (name === typeOfCurrentNode) {
                     const idOfCurrentNode = this.allNodeTemplates[i].id;
+                    name = this.removeVersionIdentifier(name);
                     const numberOfNewInstance = parseInt(idOfCurrentNode.substring(name.length + 1), 10) + 1;
                     let newId;
                     if (numberOfNewInstance) {
diff --git a/org.eclipse.winery.frontends/app/topologymodeler/src/app/problemDetection/problemDetection.component.ts b/org.eclipse.winery.frontends/app/topologymodeler/src/app/problemDetection/problemDetection.component.ts
index 8e4352fdf..0af0468bc 100644
--- a/org.eclipse.winery.frontends/app/topologymodeler/src/app/problemDetection/problemDetection.component.ts
+++ b/org.eclipse.winery.frontends/app/topologymodeler/src/app/problemDetection/problemDetection.component.ts
@@ -25,6 +25,7 @@ import { SolutionInputData } from './solutionEntity';
 import { TTopologyTemplate } from '../models/ttopology-template';
 import { TopologyTemplateUtil } from '../models/topologyTemplateUtil';
 import { WineryActions } from '../redux/actions/winery.actions';
+import { WineryRepositoryConfigurationService } from '../../../../tosca-management/src/app/wineryFeatureToggleModule/WineryRepositoryConfiguration.service';
 
 @Component({
     selector: 'winery-problem-detection',
@@ -47,6 +48,7 @@ export class ProblemDetectionComponent {
                 private wineryActions: WineryActions,
                 private problemDetectionService: ProblemDetectionService,
                 private alert: ToastrService,
+                private configurationService: WineryRepositoryConfigurationService,
                 private backendService: BackendService) {
         this.ngRedux.select(state => state.topologyRendererState)
             .subscribe(currentButtonsState => this.checkButtonsState(currentButtonsState));
@@ -131,7 +133,7 @@ export class ProblemDetectionComponent {
     }
 
     private solutionApplied(data: TTopologyTemplate) {
-        TopologyTemplateUtil.updateTopologyTemplate(this.ngRedux, this.wineryActions, data);
+        TopologyTemplateUtil.updateTopologyTemplate(this.ngRedux, this.wineryActions, data, this.configurationService.isYaml());
         this.loading = false;
     }
 }
diff --git a/org.eclipse.winery.frontends/app/topologymodeler/src/app/refinementSidebar/refinementSidebar.component.ts b/org.eclipse.winery.frontends/app/topologymodeler/src/app/refinementSidebar/refinementSidebar.component.ts
index 86458cbbb..c3f5c6735 100644
--- a/org.eclipse.winery.frontends/app/topologymodeler/src/app/refinementSidebar/refinementSidebar.component.ts
+++ b/org.eclipse.winery.frontends/app/topologymodeler/src/app/refinementSidebar/refinementSidebar.component.ts
@@ -19,6 +19,7 @@ import { IWineryState } from '../redux/store/winery.store';
 import { TopologyRendererActions } from '../redux/actions/topologyRenderer.actions';
 import { WineryActions } from '../redux/actions/winery.actions';
 import { TopologyTemplateUtil } from '../models/topologyTemplateUtil';
+import { WineryRepositoryConfigurationService } from '../../../../tosca-management/src/app/wineryFeatureToggleModule/WineryRepositoryConfiguration.service';
 
 @Component({
     selector: 'winery-refinement',
@@ -43,6 +44,7 @@ export class RefinementSidebarComponent implements OnDestroy {
                 private rendererActions: TopologyRendererActions,
                 private wineryActions: WineryActions,
                 private webSocketService: RefinementWebSocketService,
+                private configurationService: WineryRepositoryConfigurationService,
                 private backendService: BackendService) {
     }
 
@@ -97,7 +99,7 @@ export class RefinementSidebarComponent implements OnDestroy {
             }
 
             if (value.currentTopology) {
-                TopologyTemplateUtil.updateTopologyTemplate(this.ngRedux, this.wineryActions, value.currentTopology);
+                TopologyTemplateUtil.updateTopologyTemplate(this.ngRedux, this.wineryActions, value.currentTopology, this.configurationService.isYaml());
             } else {
                 this.openModelerFor(value.serviceTemplateContainingRefinements.xmlId.decoded,
                     value.serviceTemplateContainingRefinements.namespace.decoded,
diff --git a/org.eclipse.winery.frontends/app/topologymodeler/src/app/services/req-cap.service.ts b/org.eclipse.winery.frontends/app/topologymodeler/src/app/services/req-cap.service.ts
deleted file mode 100644
index fb1b99504..000000000
--- a/org.eclipse.winery.frontends/app/topologymodeler/src/app/services/req-cap.service.ts
+++ /dev/null
@@ -1,63 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2018 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
- * which is available at https://www.apache.org/licenses/LICENSE-2.0.
- *
- * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
- *******************************************************************************/
-
-import { Injectable } from '@angular/core';
-import { definitionType, urlElement } from '../models/enums';
-import { QName } from '../models/qname';
-import { Observable } from 'rxjs/Rx';
-import { HttpClient, HttpHeaders } from '@angular/common/http';
-import { BackendService } from './backend.service';
-
-@Injectable()
-export class ReqCapService {
-    // Logic for fetching the requirement, capability definitions of a node type
-    readonly options = {
-        headers: new HttpHeaders({
-            'Accept': 'application/json'
-        })
-    };
-
-    constructor(private http: HttpClient, private backendService: BackendService) {
-    }
-
-    /**
-     * Requests all requirement definitions of a node type from the backend
-     * @param   nodeType - the node type of the node template
-     * @returns
-     */
-    requestRequirementDefinitionsOfNodeType(nodeType: string): Observable<any> {
-        const qName = new QName(nodeType);
-        const url = this.backendService.configuration.repositoryURL
-            + urlElement.NodeTypeURL
-            + encodeURIComponent(encodeURIComponent(qName.nameSpace))
-            + '/' + qName.localName
-            + definitionType.RequirementDefinitions;
-        return this.http.get(url, this.options);
-    }
-
-    /**
-     * Requests all capability definitions of a node type from the backend
-     * @param   nodeType - the node type of the node template
-     * @returns
-     */
-    requestCapabilityDefinitionsOfNodeType(nodeType: string): Observable<any> {
-        const qName = new QName(nodeType);
-        const url = this.backendService.configuration.repositoryURL
-            + urlElement.NodeTypeURL
-            + encodeURIComponent(encodeURIComponent(qName.nameSpace)) + '/'
-            + qName.localName
-            + definitionType.CapabilityDefinitions;
-        return this.http.get(url, this.options);
-    }
-}
diff --git a/org.eclipse.winery.frontends/app/topologymodeler/src/app/services/statefulAnnotations.service.ts b/org.eclipse.winery.frontends/app/topologymodeler/src/app/services/statefulAnnotations.service.ts
index 04b1640b1..e0ad90c55 100644
--- a/org.eclipse.winery.frontends/app/topologymodeler/src/app/services/statefulAnnotations.service.ts
+++ b/org.eclipse.winery.frontends/app/topologymodeler/src/app/services/statefulAnnotations.service.ts
@@ -22,6 +22,7 @@ import { ErrorHandlerService } from './error-handler.service';
 import { WineryActions } from '../redux/actions/winery.actions';
 import { TopologyRendererActions } from '../redux/actions/topologyRenderer.actions';
 import { ToastrService } from 'ngx-toastr';
+import { WineryRepositoryConfigurationService } from '../../../../tosca-management/src/app/wineryFeatureToggleModule/WineryRepositoryConfiguration.service';
 
 interface TopologyAndErrorList {
     errorList: string[];
@@ -36,6 +37,7 @@ export class StatefulAnnotationsService {
                 private http: HttpClient,
                 private actions: WineryActions,
                 private rendererActions: TopologyRendererActions,
+                private configurationService: WineryRepositoryConfigurationService,
                 private alert: ToastrService,
                 private errorHandler: ErrorHandlerService) {
         this.ngRedux.select(state => state.topologyRendererState.buttonsState.determineStatefulComponents)
@@ -71,7 +73,8 @@ export class StatefulAnnotationsService {
 
         this.http.get<TTopologyTemplate>(url)
             .subscribe(
-                data => TopologyTemplateUtil.updateTopologyTemplate(this.ngRedux, this.actions, data),
+                data =>
+                    TopologyTemplateUtil.updateTopologyTemplate(this.ngRedux, this.actions, data, this.configurationService.isYaml()),
                 error => this.errorHandler.handleError(error)
             );
     }
@@ -87,7 +90,7 @@ export class StatefulAnnotationsService {
         this.http.get<TopologyAndErrorList>(url)
             .subscribe(
                 data => {
-                    TopologyTemplateUtil.updateTopologyTemplate(this.ngRedux, this.actions, data.topologyTemplate);
+                    TopologyTemplateUtil.updateTopologyTemplate(this.ngRedux, this.actions, data.topologyTemplate, this.configurationService.isYaml());
                     if (data.errorList && data.errorList.length > 0) {
                         this.alert.warning(
                             'There were no freeze operations found for some stateful components!',
diff --git a/org.eclipse.winery.frontends/app/topologymodeler/src/app/topology-renderer/topology-renderer.component.ts b/org.eclipse.winery.frontends/app/topologymodeler/src/app/topology-renderer/topology-renderer.component.ts
index 694049cb3..1245a354c 100644
--- a/org.eclipse.winery.frontends/app/topologymodeler/src/app/topology-renderer/topology-renderer.component.ts
+++ b/org.eclipse.winery.frontends/app/topologymodeler/src/app/topology-renderer/topology-renderer.component.ts
@@ -24,6 +24,7 @@ import { ILoaded } from '../services/loaded.service';
 import { Subscription } from 'rxjs';
 import { TopologyTemplateUtil } from '../models/topologyTemplateUtil';
 import { EntityTypesModel } from '../models/entityTypesModel';
+import { WineryRepositoryConfigurationService } from '../../../../tosca-management/src/app/wineryFeatureToggleModule/WineryRepositoryConfiguration.service';
 
 /**
  * This is the parent component of the canvas and navbar component.
@@ -54,7 +55,8 @@ export class TopologyRendererComponent implements OnInit, OnDestroy {
     constructor(private ngRedux: NgRedux<IWineryState>,
                 private actions: WineryActions,
                 vcr: ViewContainerRef,
-                private notify: ToastrService) {
+                private notify: ToastrService,
+                private configuration: WineryRepositoryConfigurationService) {
         this.subscriptions.push(this.ngRedux.select(state => state.wineryState.hideNavBarAndPaletteState)
             .subscribe(hideNavBar => this.hideNavBarState = hideNavBar));
     }
@@ -96,7 +98,8 @@ export class TopologyRendererComponent implements OnInit, OnDestroy {
 
                 if (node.state === DifferenceStates.REMOVED) {
                     current = this.oldTopology.nodeTemplates.find(item => item.id === node.element);
-                    current = TopologyTemplateUtil.createTNodeTemplateFromObject(current, this.entityTypes.nodeVisuals, node.state);
+                    current = TopologyTemplateUtil.createTNodeTemplateFromObject(current, this.entityTypes.nodeVisuals,
+                        this.configuration.isYaml(), this.entityTypes, node.state);
                     this.nodeTemplates.push(current);
                 } else {
                     current.state = node.state;
diff --git a/org.eclipse.winery.frontends/app/topologymodeler/src/app/winery.component.ts b/org.eclipse.winery.frontends/app/topologymodeler/src/app/winery.component.ts
index 03843ad05..756130db0 100644
--- a/org.eclipse.winery.frontends/app/topologymodeler/src/app/winery.component.ts
+++ b/org.eclipse.winery.frontends/app/topologymodeler/src/app/winery.component.ts
@@ -253,7 +253,8 @@ export class WineryComponent implements OnInit, AfterViewInit {
 
     initTopologyTemplate(nodeTemplateArray: Array<TNodeTemplate>, relationshipTemplateArray: Array<TRelationshipTemplate>) {
         // init node templates
-        this.nodeTemplates = TopologyTemplateUtil.initNodeTemplates(nodeTemplateArray, this.entityTypes.nodeVisuals, this.topologyDifferences);
+        this.nodeTemplates = TopologyTemplateUtil.initNodeTemplates(nodeTemplateArray, this.entityTypes.nodeVisuals,
+            this.configurationService.isYaml(), this.entityTypes, this.topologyDifferences);
         // init relationship templates
         this.relationshipTemplates = TopologyTemplateUtil.initRelationTemplates(relationshipTemplateArray, this.topologyDifferences);
     }
diff --git a/org.eclipse.winery.frontends/app/topologymodeler/src/app/winery.module.ts b/org.eclipse.winery.frontends/app/topologymodeler/src/app/winery.module.ts
index 1b20afefa..22f262264 100644
--- a/org.eclipse.winery.frontends/app/topologymodeler/src/app/winery.module.ts
+++ b/org.eclipse.winery.frontends/app/topologymodeler/src/app/winery.module.ts
@@ -39,7 +39,6 @@ import { TypeaheadModule } from 'ngx-bootstrap/typeahead';
 import { ExistsService } from './services/exists.service';
 import { EntitiesModalService } from './canvas/entities-modal/entities-modal.service';
 import { ImportTopologyService } from './services/import-topology.service';
-import { ReqCapService } from './services/req-cap.service';
 import { SplitMatchTopologyService } from './services/split-match-topology.service';
 import { ErrorHandlerService } from './services/error-handler.service';
 import { PopoverModule } from 'ngx-bootstrap/popover';
@@ -101,7 +100,6 @@ import { ReqCapRelationshipService } from './services/req-cap-relationship.servi
         ExistsService,
         EntitiesModalService,
         ImportTopologyService,
-        ReqCapService,
         SplitMatchTopologyService,
         ErrorHandlerService,
         StatefulAnnotationsService,
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/admin/edmmMappings/edmmMappings.component.html b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/admin/edmmMappings/edmmMappings.component.html
index 182bc9b39..da3b0ac96 100644
--- a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/admin/edmmMappings/edmmMappings.component.html
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/admin/edmmMappings/edmmMappings.component.html
@@ -29,7 +29,7 @@
     <winery-modal-body>
         <form>
             <div class="form-group">
-                <label for="edmmType" class="control-label">TOSCA Type</label>
+                <label for="toscaType" class="control-label">TOSCA Type</label>
                 <ng-select id="toscaType" [items]="typesSelect"
                            (selected)="toscaTypeSelected($event)">
                 </ng-select>
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/capabilityTypes/validSourceTypes/validSourceTypes.component.css b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/capabilityTypes/validSourceTypes/validSourceTypes.component.css
new file mode 100644
index 000000000..e69de29bb
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/capabilityTypes/validSourceTypes/validSourceTypes.component.html b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/capabilityTypes/validSourceTypes/validSourceTypes.component.html
new file mode 100644
index 000000000..2cd247d96
--- /dev/null
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/capabilityTypes/validSourceTypes/validSourceTypes.component.html
@@ -0,0 +1,58 @@
+<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+  ~ Copyright (c) 2019 Contributors to the Eclipse Foundation
+  ~
+  ~ See the NOTICE file(s) distributed with this work for additional
+  ~ information regarding copyright ownership.
+  ~
+  ~ This program and the accompanying materials are made available under the
+  ~ terms of the Eclipse Public License 2.0 which is available at
+  ~ http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+  ~ which is available at https://www.apache.org/licenses/LICENSE-2.0.
+  ~
+  ~ SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
+<div [class.hidden]="!loading">
+    <winery-loader></winery-loader>
+</div>
+<div *ngIf="!loading">
+    <div class="right">
+        <button class="btn btn-primary" name="save" (click)="saveToServer()"
+                [disabled]="!sharedData?.currentVersion?.editable">
+            Save
+        </button>
+    </div>
+
+    <winery-table title="Valid Source Types"
+                  [columns]="columns"
+                  [data]="validSourceTypes?.nodes"
+                  (addBtnClicked)="onAddClick()"
+                  (removeBtnClicked)="onRemoveClicked($event)">
+    </winery-table>
+
+</div>
+
+
+<ng-template #addModal>
+    <winery-modal-header [title]="'Add Valid Source Type'" [modalRef]="addModalRef">
+    </winery-modal-header>
+    <winery-modal-body>
+        <form>
+            <div class="form-group">
+                <label for="validNodeTypes" class="control-label">Node Types</label>
+                <ng-select id="validNodeTypes"
+                           [disabled]="!sharedData?.currentVersion?.editable"
+                           [items]="currentNodeTypes"
+                           (selected)="onSelectedValueChanged($event)"
+                           [active]="initialActiveItem"
+                >
+                </ng-select>
+            </div>
+
+        </form>
+    </winery-modal-body>
+    <winery-modal-footer [modalRef]="addModalRef"
+                         [okButtonLabel]="'Add'"
+                         [disableOkButton]="!initialActiveItem"
+                         (onOk)="onAddValidSourceType()">
+    </winery-modal-footer>
+</ng-template>
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/capabilityTypes/validSourceTypes/validSourceTypes.component.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/capabilityTypes/validSourceTypes/validSourceTypes.component.ts
new file mode 100644
index 000000000..0513cec45
--- /dev/null
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/capabilityTypes/validSourceTypes/validSourceTypes.component.ts
@@ -0,0 +1,154 @@
+/*******************************************************************************
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+
+import { Component, OnInit, ViewChild } from '@angular/core';
+import { ValidSourceTypesService } from './validSourceTypes.service';
+import { WineryTableColumn } from '../../../wineryTableModule/wineryTable.component';
+import { InstanceService } from '../../instance.service';
+import { WineryNotificationService } from '../../../wineryNotificationModule/wineryNotification.service';
+import { SelectData } from '../../../model/selectData';
+import { ValidSourceTypesApiData } from './validSourceTypesApiData';
+import { HttpErrorResponse } from '@angular/common/http';
+import { BsModalRef, BsModalService, ModalDirective } from 'ngx-bootstrap';
+import { QName } from '../../../model/qName';
+import { forkJoin } from 'rxjs';
+import { QNameApiData } from '../../../model/qNameApiData';
+
+@Component({
+    templateUrl: 'validSourceTypes.component.html',
+    styleUrls: [
+        'validSourceTypes.component.css'
+    ],
+    providers: [
+        ValidSourceTypesService
+    ]
+})
+export class ValidSourceTypesComponent implements OnInit {
+    loading: boolean;
+    currentNodeTypes: SelectData[];
+    allNodeTypes: SelectData[];
+    initialActiveItem: Array<SelectData>;
+    currentSelectedItem: QNameApiData;
+    validSourceTypes: ValidSourceTypesApiData = new ValidSourceTypesApiData();
+    @ViewChild('addModal') addModal: ModalDirective;
+    addModalRef: BsModalRef;
+    columns: Array<WineryTableColumn> = [
+        { title: 'Name', name: 'localname', sort: true },
+        { title: 'Namespace', name: 'namespace', sort: true }
+    ];
+
+    constructor(public sharedData: InstanceService,
+                private service: ValidSourceTypesService,
+                private notify: WineryNotificationService,
+                private modalService: BsModalService) {
+    }
+
+    ngOnInit(): void {
+        this.loading = true;
+        forkJoin(
+            this.service.getAvailableValidSourceTypes(),
+            this.service.getValidSourceTypes()
+        ).subscribe(
+            ([available, current]) => {
+                this.loading = false;
+                this.handleNodeTypesData(available);
+                this.handleValidSourceTypesData(current);
+            },
+            error => this.handleError(error)
+        );
+    }
+
+    saveToServer() {
+        this.loading = true;
+        this.service
+            .saveValidSourceTypes(this.validSourceTypes)
+            .subscribe(() => {
+                    this.loading = false;
+                    this.notify.success('Saved changes.');
+                },
+                error => this.handleError(error));
+    }
+
+    onAddValidSourceType() {
+        this.validSourceTypes.nodes.push(this.currentSelectedItem);
+        this.handleValidSourceTypesChanged();
+    }
+
+    onAddClick() {
+        this.addModalRef = this.modalService.show(this.addModal);
+    }
+
+    onRemoveClicked(selected: QNameApiData) {
+        if (selected) {
+            this.validSourceTypes.nodes = this.validSourceTypes.nodes.filter(item => item !== selected);
+            this.handleValidSourceTypesChanged();
+        }
+    }
+
+    onSelectedValueChanged(value: SelectData) {
+        if (value.id !== null && value.id !== undefined) {
+            this.currentSelectedItem = QNameApiData.fromQName(QName.stringToQName(value.id));
+        } else {
+            this.currentSelectedItem = null;
+        }
+    }
+
+    handleValidSourceTypesChanged() {
+        if (this.allNodeTypes) {
+            this.currentNodeTypes = this.allNodeTypes
+                .map(parentNode => {
+                    if (parentNode.children) {
+                        const children = parentNode.children.filter(node => {
+                            const asQName = QName.stringToQName(node.id);
+                            const existing: QNameApiData = this.validSourceTypes.nodes.find(qname => qname.localname === asQName.localPart
+                                && qname.namespace === asQName.namespace);
+                            return existing === null || existing === undefined;
+                        });
+
+                        return { id: parentNode.id, text: parentNode.text, children: children };
+                    }
+
+                    return null;
+                })
+                .filter(item => item !== null);
+
+            if (this.currentNodeTypes !== null
+                && this.currentNodeTypes !== undefined
+                && this.currentNodeTypes.length > 0
+                && this.currentNodeTypes[0].children.length > 0) {
+                this.initialActiveItem = [this.currentNodeTypes[0].children[0]];
+                this.onSelectedValueChanged(this.initialActiveItem[0]);
+            }
+        }
+    }
+
+    handleNodeTypesData(nodeTypes: SelectData[]) {
+        this.allNodeTypes = nodeTypes;
+        this.currentNodeTypes = this.allNodeTypes;
+    }
+
+    handleValidSourceTypesData(data: ValidSourceTypesApiData) {
+        if (data.nodes === null || data.nodes === undefined) {
+            data.nodes = [];
+        }
+        this.validSourceTypes = data;
+        this.handleValidSourceTypesChanged();
+    }
+
+    private handleError(error: HttpErrorResponse): void {
+        this.loading = false;
+        this.notify.error(error.message, 'Error');
+    }
+
+}
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/capabilityTypes/validSourceTypes/validSourceTypes.module.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/capabilityTypes/validSourceTypes/validSourceTypes.module.ts
new file mode 100644
index 000000000..257e2e844
--- /dev/null
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/capabilityTypes/validSourceTypes/validSourceTypes.module.ts
@@ -0,0 +1,45 @@
+/*******************************************************************************
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+
+import { NgModule } from '@angular/core';
+import { CommonModule } from '@angular/common';
+import { BrowserModule } from '@angular/platform-browser';
+import { SelectModule } from 'ng2-select';
+import { FormsModule } from '@angular/forms';
+import { RouterModule } from '@angular/router';
+import { WineryLoaderModule } from '../../../wineryLoader/wineryLoader.module';
+import { WineryQNameSelectorModule } from '../../../wineryQNameSelector/wineryQNameSelector.module';
+import { ValidSourceTypesComponent } from './validSourceTypes.component';
+import { WineryModalModule } from '../../../wineryModalModule/winery.modal.module';
+import { WineryTableModule } from '../../../wineryTableModule/wineryTable.module';
+
+@NgModule({
+    imports: [
+        CommonModule,
+        BrowserModule,
+        SelectModule,
+        FormsModule,
+        CommonModule,
+        RouterModule,
+        WineryLoaderModule,
+        WineryQNameSelectorModule,
+        WineryModalModule,
+        WineryTableModule
+    ],
+    exports: [ValidSourceTypesComponent],
+    declarations: [ValidSourceTypesComponent],
+    providers: [],
+})
+export class ValidSourceTypesModule {
+}
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/capabilityTypes/validSourceTypes/validSourceTypes.service.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/capabilityTypes/validSourceTypes/validSourceTypes.service.ts
new file mode 100644
index 000000000..0722f524d
--- /dev/null
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/capabilityTypes/validSourceTypes/validSourceTypes.service.ts
@@ -0,0 +1,55 @@
+/*******************************************************************************
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+import { HttpClient } from '@angular/common/http';
+import { InstanceService } from '../../instance.service';
+import { Injectable } from '@angular/core';
+import { Observable } from 'rxjs';
+import { ValidSourceTypesApiData } from './validSourceTypesApiData';
+import { backendBaseURL } from '../../../configuration';
+import { SelectData } from '../../../model/selectData';
+import { ToscaTypes } from '../../../model/enums';
+
+@Injectable()
+export class ValidSourceTypesService {
+    private readonly path: string;
+
+    constructor(private http: HttpClient,
+                private instanceService: InstanceService) {
+        this.path = this.instanceService.path;
+    }
+
+    getValidSourceTypes(): Observable<ValidSourceTypesApiData> {
+        return this.http.get<ValidSourceTypesApiData>(backendBaseURL + this.path + '/constraints');
+    }
+
+    getAvailableValidSourceTypes(): Observable<SelectData[]> {
+        const url = backendBaseURL + '/' + ToscaTypes.NodeType + '?grouped=angularSelect&dev=true/';
+
+        return this.http.get<SelectData[]>(url);
+    }
+
+    getValidSourceTypesForCapabilityDefinition(type: string): Observable<ValidSourceTypesApiData> {
+        const path = '/' + ToscaTypes.CapabilityType + type;
+        return this.http.get<ValidSourceTypesApiData>(backendBaseURL + path + '/constraints');
+    }
+
+    saveValidSourceTypes(v: ValidSourceTypesApiData): Observable<any> {
+        return this.http.put<any>(backendBaseURL + this.path + '/constraints', v);
+    }
+
+    saveValidSourceTypesForCapabilityDefinition(type: string, v: ValidSourceTypesApiData): Observable<any> {
+        const path = '/' + ToscaTypes.CapabilityType + type;
+        return this.http.put<any>(backendBaseURL + path + '/constraints', v);
+    }
+}
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/capabilityTypes/validSourceTypes/validSourceTypesApiData.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/capabilityTypes/validSourceTypes/validSourceTypesApiData.ts
new file mode 100644
index 000000000..a7c692a4c
--- /dev/null
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/capabilityTypes/validSourceTypes/validSourceTypesApiData.ts
@@ -0,0 +1,18 @@
+/*******************************************************************************
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+import { QNameApiData } from '../../../model/qNameApiData';
+
+export class ValidSourceTypesApiData {
+    nodes: QNameApiData[] = [];
+}
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/instance.component.html b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/instance.component.html
index 509aeff5d..3ddfc9d8f 100644
--- a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/instance.component.html
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/instance.component.html
@@ -1,5 +1,5 @@
 <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-  ~ Copyright (c) 2017-2018 Contributors to the Eclipse Foundation
+  ~ Copyright (c) 2017-2019 Contributors to the Eclipse Foundation
   ~
   ~ See the NOTICE file(s) distributed with this work for additional
   ~ information regarding copyright ownership.
@@ -19,7 +19,8 @@
     <i class="fa fa-ban"></i>
     <span>&nbsp;&nbsp;You cannot edit this version! To edit this component, add a new version.</span>
 </alert>
-<div *ngIf="!(loadingVersions || loadingData); else loader" class="mainContentContainer {{ toscaComponent.toscaType | toscaTypeToCamelCase}}">
+<div *ngIf="!(loadingVersions || loadingData); else loader"
+     class="mainContentContainer {{ toscaComponent.toscaType | toscaTypeToCamelCase}}">
     <winery-instance-header
         [imageUrl]="imageUrl"
         [toscaComponent]="toscaComponent"
@@ -28,6 +29,7 @@
         [typeUrl]="typeUrl"
         [typeId]="typeId"
         [subMenu]="availableTabs"
+        [subMenuLinks]="availableTabsLinks"
         (deleteConfirmed)="deleteComponent();">
     </winery-instance-header>
     <div class="middle" id="ccontainer">
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/instance.component.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/instance.component.ts
index f35f21038..1eedd171b 100644
--- a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/instance.component.ts
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/instance.component.ts
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2017-2018 Contributors to the Eclipse Foundation
+ * Copyright (c) 2017-2019 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -27,6 +27,7 @@ import { ToscaComponent } from '../model/toscaComponent';
 import { Utils } from '../wineryUtils/utils';
 import { WineryVersion } from '../model/wineryVersion';
 import { HttpErrorResponse } from '@angular/common/http';
+import { WineryRepositoryConfigurationService } from '../wineryFeatureToggleModule/WineryRepositoryConfiguration.service';
 
 @Component({
     templateUrl: 'instance.component.html',
@@ -38,6 +39,7 @@ import { HttpErrorResponse } from '@angular/common/http';
 export class InstanceComponent implements OnDestroy {
 
     availableTabs: string[];
+    availableTabsLinks: string[];
     toscaComponent: ToscaComponent;
     versions: WineryVersion[];
     typeUrl: string;
@@ -54,7 +56,9 @@ export class InstanceComponent implements OnDestroy {
     constructor(private route: ActivatedRoute,
                 private router: Router,
                 private service: InstanceService,
-                private notify: WineryNotificationService, private existService: ExistService) {
+                private notify: WineryNotificationService,
+                private configurationService: WineryRepositoryConfigurationService,
+                private existService: ExistService) {
         this.routeSub = this.route
             .data
             .subscribe(data => {
@@ -88,6 +92,16 @@ export class InstanceComponent implements OnDestroy {
                     }
 
                     this.availableTabs = this.service.getSubMenuByResource();
+                    this.availableTabsLinks = this.availableTabs.map(item => {
+                        let link = `./${item.toLowerCase().replace(/ /g, '')}`;
+
+                        if (link === './requirementdefinitions' && configurationService.isYaml()) {
+                            link += 'yaml';
+                        }
+
+                        return link;
+                    });
+
                 },
                 error => this.handleError(error)
             );
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/instance.service.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/instance.service.ts
index ffa4c1b78..970bb6766 100644
--- a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/instance.service.ts
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/instance.service.ts
@@ -44,13 +44,17 @@ export class InstanceService {
 
         switch (this.toscaComponent.toscaType) {
             case ToscaTypes.NodeType:
-                subMenu = ['README', 'LICENSE', 'Appearance', 'Instance States', 'Interfaces', 'Implementations', 'Tags',
-                    'Requirement Definitions', 'Capability Definitions', 'Properties Definition',
-                    'Inheritance', 'Documentation', 'XML'];
+                subMenu = ['README', 'LICENSE', 'Appearance', 'Instance States', 'Interfaces', 'Implementations',
+                    'Requirement Definitions', 'Capability Definitions', 'Properties Definition', 'Inheritance'];
+                if (!this.configurationService.configuration.features.yaml) {
+                    subMenu.push('Tags', 'Documentation', 'XML');
+                }
                 break;
             case ToscaTypes.ServiceTemplate:
-                subMenu = ['README', 'LICENSE', 'Topology Template', 'Plans', 'Selfservice Portal',
-                    'Boundary Definitions', 'Tags', 'Constraint Checking', 'Documentation', 'XML'];
+                subMenu = ['README', 'LICENSE', 'Topology Template'];
+                if (!this.configurationService.configuration.features.yaml) {
+                    subMenu.push('Plans', 'Selfservice Portal', 'Boundary Definitions', 'Tags', 'Constraint Checking', 'Documentation', 'XML');
+                }
                 if (this.configurationService.configuration.features.nfv) {
                     subMenu.push('Threat Modeling');
                 }
@@ -70,7 +74,11 @@ export class InstanceService {
                 subMenu = ['README', 'LICENSE', 'Required Capability Type', 'Properties Definition', 'Inheritance', 'Documentation', 'XML'];
                 break;
             case ToscaTypes.CapabilityType:
-                subMenu = ['README', 'LICENSE', 'Properties Definition', 'Inheritance', 'Documentation', 'XML'];
+                if (this.configurationService.isYaml()) {
+                    subMenu = ['README', 'LICENSE', 'Properties Definition', 'Inheritance', 'Constraints', 'Documentation'];
+                } else {
+                    subMenu = ['README', 'LICENSE', 'Properties Definition', 'Inheritance', 'Documentation', 'XML'];
+                }
                 break;
             case ToscaTypes.NodeTypeImplementation:
                 subMenu = ['README', 'LICENSE', 'Implementation Artifacts', 'Deployment Artifacts', 'Inheritance', 'Documentation', 'XML'];
@@ -107,6 +115,11 @@ export class InstanceService {
                     subMenu.push('1 to 1 EDMM Mappings', 'EDMM Type Mappings');
                 }
         }
+
+        if (this.configurationService.isYaml()) {
+            subMenu = subMenu.filter(item => item !== 'XML');
+        }
+
         return subMenu;
     }
 
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/instanceHeader/instanceHeader.component.html b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/instanceHeader/instanceHeader.component.html
index fd3d1f716..8a95e2669 100644
--- a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/instanceHeader/instanceHeader.component.html
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/instanceHeader/instanceHeader.component.html
@@ -1,5 +1,5 @@
 <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-  ~ Copyright (c) 2017-2018 Contributors to the Eclipse Foundation
+  ~ Copyright (c) 2017-2019 Contributors to the Eclipse Foundation
   ~
   ~ See the NOTICE file(s) distributed with this work for additional
   ~ information regarding copyright ownership.
@@ -53,9 +53,9 @@
         </div>
     </div>
     <div class="subMenu">
-        <a *ngFor="let item of subMenu"
+        <a *ngFor="let item of subMenu; index as i"
            class="styledTabMenuButton styledTabMenuButton2ndlevel"
-           [routerLink]="['./' + item | lowercase | removeWhiteSpaces ]"
+           [routerLink]="subMenuLinks[i]"
            [routerLinkActive]="'selected'"
            (click)="selectedTab = item">
             <div class="left"></div>
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/instanceHeader/instanceHeader.component.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/instanceHeader/instanceHeader.component.ts
index b63478783..a53625e8a 100644
--- a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/instanceHeader/instanceHeader.component.ts
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/instanceHeader/instanceHeader.component.ts
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2017-2018 Contributors to the Eclipse Foundation
+ * Copyright (c) 2017-2019 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -41,6 +41,7 @@ export class InstanceHeaderComponent implements OnInit {
     @Input() typeId: string;
     @Input() typeOf: string;
     @Input() subMenu: string[];
+    @Input() subMenuLinks: string[];
     @Input() imageUrl: string;
     @Output() deleteConfirmed: EventEmitter<any> = new EventEmitter();
 
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/capabilityOrRequirementDefinitions/capOrReqDef.component.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/capabilityOrRequirementDefinitions/capOrReqDef.component.ts
index 8579e563f..7090a44a8 100644
--- a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/capabilityOrRequirementDefinitions/capOrReqDef.component.ts
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/capabilityOrRequirementDefinitions/capOrReqDef.component.ts
@@ -11,50 +11,52 @@
  *
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  *******************************************************************************/
-import {Component, Input, OnInit, ViewChild} from '@angular/core';
-import {isNullOrUndefined} from 'util';
-import {CapabilityOrRequirementDefinitionsService} from './capOrReqDef.service';
-import {
-    CapabilityOrRequirementDefinition,
-    CapOrRegDefinitionsResourceApiData,
-    CapOrReqDefinition,
-    Constraint
-} from './capOrReqDefResourceApiData';
-import {CapOrRegDefinitionsTableData} from './CapOrReqDefTableData';
-import {NameAndQNameApiData, NameAndQNameApiDataList} from '../../../wineryQNameSelector/wineryNameAndQNameApiData';
-import {Router} from '@angular/router';
-import {WineryTableColumn} from '../../../wineryTableModule/wineryTable.component';
-import {TypeWithShortName} from '../../admin/typesWithShortName/typeWithShortName.service';
-import {SelectData} from '../../../model/selectData';
-import {WineryNotificationService} from '../../../wineryNotificationModule/wineryNotification.service';
-import {ModalDirective} from 'ngx-bootstrap';
-import {SpinnerWithInfinityComponent} from '../../../winerySpinnerWithInfinityModule/winerySpinnerWithInfinity.component';
-import {InstanceService} from '../../instance.service';
+import { Component, Input, OnInit, ViewChild } from '@angular/core';
+import { isNullOrUndefined } from 'util';
+import { CapabilityOrRequirementDefinitionsService } from './capOrReqDef.service';
+import { CapabilityOrRequirementDefinition, CapOrRegDefinitionsResourceApiData, CapOrReqDefinition, Constraint } from './capOrReqDefResourceApiData';
+import { CapOrRegDefinitionsTableData } from './CapOrReqDefTableData';
+import { NameAndQNameApiData, NameAndQNameApiDataList } from '../../../wineryQNameSelector/wineryNameAndQNameApiData';
+import { Router } from '@angular/router';
+import { WineryTableColumn } from '../../../wineryTableModule/wineryTable.component';
+import { TypeWithShortName } from '../../admin/typesWithShortName/typeWithShortName.service';
+import { SelectData } from '../../../model/selectData';
+import { WineryNotificationService } from '../../../wineryNotificationModule/wineryNotification.service';
+import { BsModalRef, BsModalService, ModalDirective } from 'ngx-bootstrap';
+import { SpinnerWithInfinityComponent } from '../../../winerySpinnerWithInfinityModule/winerySpinnerWithInfinity.component';
+import { InstanceService } from '../../instance.service';
 import { HttpErrorResponse } from '@angular/common/http';
+import { ValidSourceTypesService } from '../../capabilityTypes/validSourceTypes/validSourceTypes.service';
+import { QName } from '../../../model/qName';
 
 @Component({
     selector: 'winery-instance-cap-or-req-definitions',
     templateUrl: 'capOrReqDef.html',
     styleUrls: ['capOrReqDef.style.css'],
     providers: [
-        CapabilityOrRequirementDefinitionsService
+        CapabilityOrRequirementDefinitionsService, ValidSourceTypesService
     ]
 })
 export class CapOrReqDefComponent implements OnInit {
-
     columns: Array<WineryTableColumn> = [
-        {title: 'Name', name: 'name'},
-        {title: 'Type', name: 'type'},
-        {title: 'Lower Bound', name: 'lowerBound'},
-        {title: 'Upper Bound', name: 'upperBound'},
-        {title: 'Constraints', name: 'constraints', sort: false},
+        { title: 'Name', name: 'name' },
+        { title: 'Type', name: 'type' },
+        { title: 'Lower Bound', name: 'lowerBound' },
+        { title: 'Upper Bound', name: 'upperBound' },
+        { title: 'Constraints', name: 'constraints', sort: false },
+    ];
+
+    addCapabilityColumns: Array<WineryTableColumn> = [
+        { title: 'Name', name: 'localPart', sort: true },
+        { title: 'Namespace', name: 'namespace', sort: true }
     ];
 
     elementToRemove: CapOrRegDefinitionsTableData = null;
     loading = true;
     resourceApiData: CapOrRegDefinitionsResourceApiData = null;
     tableData: Array<CapOrRegDefinitionsTableData> = [];
-    capabilityTypesList: NameAndQNameApiDataList = {classes: null};
+    validSourceTypesTableData: QName[] = [];
+    capabilityTypesList: NameAndQNameApiDataList = { classes: null };
     capOrReqDefToBeAdded: CapOrReqDefinition = null;
     noneSelected = true;
 
@@ -78,21 +80,27 @@ export class CapOrReqDefComponent implements OnInit {
     activeCapOrRegDefinition: CapabilityOrRequirementDefinition;
     activeConstraint: Constraint;
     constraintTypes: Array<TypeWithShortName> = null;
+    addModalRef: BsModalRef;
 
     @Input() types = '';
     addCapOrRegModalTitle = '';
 
     @ViewChild('confirmDeleteModal') confirmDeleteModal: ModalDirective;
     @ViewChild('addModal') addModal: ModalDirective;
+    @ViewChild('addValidNodeTypeModal') addValidNodeTypeModal: ModalDirective;
     @ViewChild('editConModal') editConModal: ModalDirective;
     @ViewChild('editNewConModal') editNewConModal: ModalDirective;
     @ViewChild('lowerBoundSpinner') lowerBoundSpinner: SpinnerWithInfinityComponent;
     @ViewChild('upperBoundSpinner') upperBoundSpinner: SpinnerWithInfinityComponent;
     @ViewChild('editor') editor: any;
+    private currentNodeTypes: SelectData[];
+    private selectedNodeType: QName;
 
     constructor(public sharedData: InstanceService,
                 private service: CapabilityOrRequirementDefinitionsService,
+                private validSourceTypesService: ValidSourceTypesService,
                 private notify: WineryNotificationService,
+                private modalService: BsModalService,
                 private router: Router) {
         this.capOrReqDefToBeAdded = new CapOrReqDefinition();
 
@@ -124,6 +132,24 @@ export class CapOrReqDefComponent implements OnInit {
     onSelectedValueChanged(value: string) {
         this.capOrReqDefToBeAdded.type = value;
         this.noneSelected = this.capOrReqDefToBeAdded.type === '(none)';
+        this.getConstraintsOfType(value);
+    }
+
+    getConstraintsOfType(value: string) {
+        this.capOrReqDefToBeAdded.validSourceTypes = [];
+        this.validSourceTypesTableData = [];
+        if (!this.noneSelected) {
+            this.validSourceTypesService.getValidSourceTypesForCapabilityDefinition(value.replace('{', '/').replace('}', '/'))
+                .subscribe(
+                    (current) => {
+                        current.nodes.forEach(value1 => {
+                            this.validSourceTypesTableData.push(new QName(value1.namespace, value1.localname));
+                            this.capOrReqDefToBeAdded.validSourceTypes.push('{' + value1.namespace + '}' + value1.localname);
+                        });
+                    },
+                    error => this.handleError(error)
+                );
+        }
     }
 
     /**
@@ -231,6 +257,7 @@ export class CapOrReqDefComponent implements OnInit {
      * handler for clicks on the add button
      */
     onAddClick() {
+        this.capOrReqDefToBeAdded = new CapOrReqDefinition();
         this.addModal.show();
     }
 
@@ -518,4 +545,36 @@ export class CapOrReqDefComponent implements OnInit {
 
     // endregion
 
+    onAddSourceTypeClick() {
+        this.addModalRef = this.modalService.show(this.addValidNodeTypeModal);
+        this.validSourceTypesService.getAvailableValidSourceTypes().subscribe(available => this.handleNodeTypesData(available));
+
+    }
+
+    handleNodeTypesData(nodeTypes: SelectData[]) {
+        this.currentNodeTypes = nodeTypes;
+    }
+
+    onRemoveClicked(selected: QName) {
+        const toDelete: String = '{' + selected.namespace + '}' + selected.localPart;
+        if (selected) {
+            this.capOrReqDefToBeAdded.validSourceTypes = this.capOrReqDefToBeAdded.validSourceTypes.filter(item => item !== toDelete);
+            this.validSourceTypesTableData = this.validSourceTypesTableData.filter(item => item !== selected);
+            this.notify.success('Saved changes.');
+        }
+    }
+
+    onAddValidSourceType() {
+        this.capOrReqDefToBeAdded.validSourceTypes.push('{' + this.selectedNodeType.namespace + '}' + this.selectedNodeType.localPart);
+        this.validSourceTypesTableData.push(this.selectedNodeType);
+        this.notify.success('Saved changes.');
+    }
+
+    onSelectedNodeTypeChanged(value: SelectData) {
+        if (value.id !== null && value.id !== undefined) {
+            this.selectedNodeType = QName.stringToQName(value.id);
+        } else {
+            this.selectedNodeType = null;
+        }
+    }
 }
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/capabilityOrRequirementDefinitions/capOrReqDef.html b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/capabilityOrRequirementDefinitions/capOrReqDef.html
index bea4ea8ee..393f1e91e 100644
--- a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/capabilityOrRequirementDefinitions/capOrReqDef.html
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/capabilityOrRequirementDefinitions/capOrReqDef.html
@@ -73,6 +73,16 @@
                 <winery-spinner-with-infinity #upperBoundSpinner [label]="'Upper Bound'"
                                               [withInfinity]="true"></winery-spinner-with-infinity>
             </div>
+            <br>
+            <div *ngIf="this.capOrReqDefToBeAdded.type && this.capOrReqDefToBeAdded.type != 'none'">
+                <winery-table title="Valid Source Types"
+                              [columns]="addCapabilityColumns"
+                              [data]="validSourceTypesTableData"
+                              disableFiltering="true"
+                              (addBtnClicked)="onAddSourceTypeClick()"
+                              (removeBtnClicked)="onRemoveClicked($event)">
+                </winery-table>
+            </div>
         </form>
     </winery-modal-body>
     <winery-modal-footer [showDefaultButtons]="false">
@@ -83,6 +93,31 @@
     </winery-modal-footer>
 </winery-modal>
 
+<ng-template #addValidNodeTypeModal>
+    <winery-modal-header [title]="'Add Valid Source Type'" [modalRef]="addModalRef">
+    </winery-modal-header>
+    <winery-modal-body>
+        <form>
+            <div class="form-group">
+                <label for="validNodeTypes" class="control-label">Node Types</label>
+                <ng-select id="validNodeTypes"
+                           [disabled]="!sharedData?.currentVersion?.editable"
+                           [items]="currentNodeTypes"
+                           (selected)="onSelectedNodeTypeChanged($event)"
+                           [active]=""
+                >
+                </ng-select>
+            </div>
+
+        </form>
+    </winery-modal-body>
+    <winery-modal-footer [modalRef]="addModalRef"
+                         [okButtonLabel]="'Add'"
+                         [disableOkButton]=""
+                         (onOk)="onAddValidSourceType()">
+    </winery-modal-footer>
+</ng-template>
+
 <winery-modal bsModal #confirmDeleteModal="bs-modal" [modalRef]="confirmDeleteModal">
     <winery-modal-header [title]="'Delete Property'"></winery-modal-header>
     <winery-modal-body>
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/capabilityOrRequirementDefinitions/capOrReqDefResourceApiData.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/capabilityOrRequirementDefinitions/capOrReqDefResourceApiData.ts
index c5b60e1f4..6d828a872 100644
--- a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/capabilityOrRequirementDefinitions/capOrReqDefResourceApiData.ts
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/capabilityOrRequirementDefinitions/capOrReqDefResourceApiData.ts
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ * Copyright (c) 2017-2019 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -11,6 +11,9 @@
  *
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  *******************************************************************************/
+import { QName } from '../../../model/qName';
+import { QNameApiData } from '../../../model/qNameApiData';
+
 export class CapabilityOrRequirementDefinition {
     name: string = null;
     capabilityType: string = null;
@@ -21,6 +24,7 @@ export class CapabilityOrRequirementDefinition {
     documentation: any[] = [];
     any: any[] = [];
     otherAttributes: any = null;
+    validSourceTypes: String[] = [];
 }
 
 export class CapOrReqDefinition {
@@ -28,6 +32,7 @@ export class CapOrReqDefinition {
     type: string = null;
     lowerBound: string = null;
     upperBound: string = null;
+    validSourceTypes: String[] = [];
 }
 
 export class Constraint {
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/yamlRequirementDefinitions/yamlRequirementDefinitionApiData.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/yamlRequirementDefinitions/yamlRequirementDefinitionApiData.ts
new file mode 100644
index 000000000..ab2dd3d34
--- /dev/null
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/yamlRequirementDefinitions/yamlRequirementDefinitionApiData.ts
@@ -0,0 +1,45 @@
+/*******************************************************************************
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+
+export class YamlRequirementDefinitionApiData {
+    name: string = null;
+    capability: string = null;
+    node: string = null;
+    relationship: string = null;
+    lowerBound: string = null;
+    upperBound: string = null;
+    documentation: any[] = [];
+    any: any[] = [];
+    otherAttributes: any = null;
+}
+
+export class YamlRequirementDefinitionPostApiData {
+    name: string = null;
+    capability: string = null;
+    node: string = null;
+    relationship: string = null;
+    lowerBound: string = null;
+    upperBound: string = null;
+    static fromData(data: YamlRequirementDefinitionApiData): YamlRequirementDefinitionPostApiData {
+        const result = new YamlRequirementDefinitionPostApiData();
+        result.capability = data.capability;
+        result.lowerBound = data.lowerBound;
+        result.upperBound = data.upperBound;
+        result.node = data.node;
+        result.relationship = data.relationship;
+        result.name = data.name;
+
+        return result;
+    }
+}
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/yamlRequirementDefinitions/yamlRequirementDefinitionTableData.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/yamlRequirementDefinitions/yamlRequirementDefinitionTableData.ts
new file mode 100644
index 000000000..b385ffdea
--- /dev/null
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/yamlRequirementDefinitions/yamlRequirementDefinitionTableData.ts
@@ -0,0 +1,30 @@
+/*******************************************************************************
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+export class YamlRequirementDefinitionTableData {
+    name: string = null;
+    capability: string = null;
+    lowerBound: string = null;
+    upperBound: string = null;
+    node: string = null;
+    relationship: string = null;
+
+    constructor(name: string, capability: string, lowerBound: string, upperBound: string, node: string, relationship: string) {
+        this.name = name;
+        this.capability = capability;
+        this.lowerBound = lowerBound;
+        this.upperBound = upperBound;
+        this.node = node;
+        this.relationship = relationship;
+    }
+}
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/yamlRequirementDefinitions/yamlRequirementDefinitions.component.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/yamlRequirementDefinitions/yamlRequirementDefinitions.component.ts
new file mode 100644
index 000000000..21bd64fe1
--- /dev/null
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/yamlRequirementDefinitions/yamlRequirementDefinitions.component.ts
@@ -0,0 +1,186 @@
+/*******************************************************************************
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+
+import { Component, OnInit, ViewChild } from '@angular/core';
+import { WineryTableColumn } from '../../../wineryTableModule/wineryTable.component';
+import { YamlRequirementDefinitionsService } from './yamlRequirementDefinitions.service';
+import { SelectData } from '../../../model/selectData';
+import { YamlRequirementDefinitionApiData } from './yamlRequirementDefinitionApiData';
+import { forkJoin } from 'rxjs';
+import { WineryNotificationService } from '../../../wineryNotificationModule/wineryNotification.service';
+import { HttpErrorResponse } from '@angular/common/http';
+import { YamlRequirementDefinitionTableData } from './yamlRequirementDefinitionTableData';
+import { InstanceService } from '../../instance.service';
+import { QName } from '../../../model/qName';
+import { BsModalRef, BsModalService, ModalDirective } from 'ngx-bootstrap';
+import { SelectItem } from 'ng2-select';
+
+@Component({
+    selector: 'winery-req-definitions',
+    templateUrl: 'yamlRequirementDefinitions.html',
+    styleUrls: ['yamlRequirementDefinitions.style.css'],
+    providers: [
+        YamlRequirementDefinitionsService
+    ]
+})
+export class YamlRequirementDefinitionsComponent implements OnInit {
+    readonly noneElement: SelectData[] = [
+        { text: 'None', id: 'none', children: [{ text: '(none)', id: '(none)' }] }
+    ];
+
+    readonly anyElement: SelectData[] = [
+        { text: 'Any', id: 'any', children: [{ text: '(any)', id: '(any)' }] }
+    ];
+    columns: Array<WineryTableColumn> = [
+        { title: 'Name', name: 'name' },
+        { title: 'Capability Type', name: 'capability' },
+        { title: 'Node Type', name: 'node' },
+        { title: 'Relationship Type', name: 'relationship' },
+        { title: 'Lower Bound', name: 'lowerBound' },
+        { title: 'Upper Bound', name: 'upperBound' },
+    ];
+
+    allNodeTypes: SelectData[] = [];
+    initialNodeType = this.anyElement;
+    allCapabilityTypes: SelectData[] = [];
+    initialCapabilityType = this.noneElement;
+    allRelationshipTypes: SelectData[] = [];
+    initialRelationshipType = this.anyElement;
+    requirementDefinitions: YamlRequirementDefinitionApiData[] = [];
+    tableData: YamlRequirementDefinitionTableData[] = [];
+    reqDefToBeAdded: YamlRequirementDefinitionApiData;
+    lowerBound: number;
+    upperBound: number;
+    isUnboundedSelected: boolean;
+    loading: boolean;
+    elementToRemove: YamlRequirementDefinitionTableData;
+    @ViewChild('addModal') addModal: ModalDirective;
+    addModalRef: BsModalRef;
+    @ViewChild('removeModal') removeModal: ModalDirective;
+    removeModalRef: BsModalRef;
+    enableAddItemButton = false;
+
+    constructor(public sharedData: InstanceService,
+                private service: YamlRequirementDefinitionsService,
+                private notify: WineryNotificationService,
+                private modalService: BsModalService) {
+    }
+
+    ngOnInit(): void {
+        this.loading = true;
+        forkJoin(
+            this.service.getGroupedNodeTypes(),
+            this.service.getCapabilityTypes(),
+            this.service.getRelationshipTypes(),
+            this.service.getAllRequirementDefinitions()
+        ).subscribe((result) => {
+            this.loading = false;
+            this.allNodeTypes = this.noneElement.concat(result[0]);
+            this.allCapabilityTypes = this.noneElement.concat(result[1]);
+            this.allRelationshipTypes = this.noneElement.concat(result[2]);
+            this.handleRequirementDefinitions(result[3]);
+
+        }, error => this.handleError(error));
+    }
+
+    private handleError(error: HttpErrorResponse): void {
+        this.loading = false;
+        this.notify.error(error.message, 'Error');
+    }
+
+    private handleRequirementDefinitions(defs: YamlRequirementDefinitionApiData[]) {
+        this.requirementDefinitions = defs;
+
+        if (this.requirementDefinitions) {
+            this.tableData = this.requirementDefinitions.map(def => {
+                    const nodeHref = def.node ? this.typeToHref(QName.stringToQName(def.node), 'nodetypes') : 'ANY';
+                    const relationshipHref = def.relationship ? this.typeToHref(QName.stringToQName(def.relationship), 'relationshiptypes') : 'ANY';
+                    return new YamlRequirementDefinitionTableData(
+                        def.name,
+                        this.typeToHref(QName.stringToQName(def.capability), 'capabilitytypes'),
+                        def.lowerBound,
+                        def.upperBound,
+                        nodeHref,
+                        relationshipHref);
+                }
+            );
+        } else {
+            this.tableData = [];
+        }
+    }
+
+    onRemoveClick(reqDef: YamlRequirementDefinitionTableData) {
+        if (reqDef) {
+            this.elementToRemove = reqDef;
+            this.removeModalRef = this.modalService.show(this.removeModal);
+        }
+    }
+
+    removeConfirmed() {
+        this.tableData = this.tableData.filter(item => item !== this.elementToRemove);
+        this.elementToRemove = null;
+    }
+
+    onAddClick() {
+        this.lowerBound = 1;
+        this.upperBound = 1;
+        this.isUnboundedSelected = false;
+        this.enableAddItemButton = false;
+        this.reqDefToBeAdded = new YamlRequirementDefinitionApiData();
+        this.addModalRef = this.modalService.show(this.addModal);
+    }
+
+    addRequirementDefinition() {
+        // fill in the lower and upper bound values. The other values are already filled
+        this.reqDefToBeAdded.lowerBound = this.lowerBound.toString(10);
+        if (this.isUnboundedSelected) {
+            this.reqDefToBeAdded.upperBound = 'UNBOUNDED';
+        } else {
+            this.reqDefToBeAdded.upperBound = this.upperBound.toString(10);
+        }
+
+        this.service.saveRequirementDefinition(this.reqDefToBeAdded)
+            .flatMap(() => this.service.getAllRequirementDefinitions())
+            .subscribe(
+                (data) => {
+                    this.handleRequirementDefinitions(data);
+                    this.notify.success(`Requirement definition ${this.reqDefToBeAdded.name} added successfully!`);
+                },
+                error => this.handleError(error)
+            );
+    }
+
+    private typeToHref(typeQName: QName, refType: string): string {
+        // no need to encode the namespace since we assume dotted namespaces in YAML mode
+        const absoluteURL = `/#/${refType}/${typeQName.namespace}/${typeQName.localPart}`;
+        return '<a href="' + absoluteURL + '">' + typeQName.localPart + '</a>';
+    }
+
+    onSelectedCapTypeChanged(value: SelectItem) {
+        this.reqDefToBeAdded.capability = value.id;
+        this.enableAddItemButton = value.id !== '(none)';
+    }
+
+    onSelectedNodeTypeChanged(value: SelectItem) {
+        this.reqDefToBeAdded.node = value.id === '(any)' ? undefined : value.id;
+    }
+
+    onSelectedRelTypeChanged(value: SelectItem) {
+        this.reqDefToBeAdded.relationship = value.id === '(any)' ? undefined : value.id;
+    }
+
+    unboundedToggle() {
+        this.isUnboundedSelected = !this.isUnboundedSelected;
+    }
+}
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/yamlRequirementDefinitions/yamlRequirementDefinitions.html b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/yamlRequirementDefinitions/yamlRequirementDefinitions.html
new file mode 100644
index 000000000..5bb74edb0
--- /dev/null
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/yamlRequirementDefinitions/yamlRequirementDefinitions.html
@@ -0,0 +1,129 @@
+<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+  ~ Copyright (c) 2019 Contributors to the Eclipse Foundation
+  ~
+  ~ See the NOTICE file(s) distributed with this work for additional
+  ~ information regarding copyright ownership.
+  ~
+  ~ This program and the accompanying materials are made available under the
+  ~ terms of the Eclipse Public License 2.0 which is available at
+  ~ http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+  ~ which is available at https://www.apache.org/licenses/LICENSE-2.0.
+  ~
+  ~ SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
+<div class="localLoader" [class.hidden]="!loading">
+    <winery-loader></winery-loader>
+</div>
+
+<div *ngIf="!loading">
+    <!--need data for table component-->
+    <winery-table id="reqdef-table"
+                  [data]="tableData"
+                  [columns]="columns"
+                  [disableButtons]="!sharedData?.currentVersion?.editable"
+                  [itemsPerPage]="10"
+                  (removeBtnClicked)="onRemoveClick($event)"
+                  (addBtnClicked)="onAddClick()">
+    </winery-table>
+</div>
+
+<ng-template #addModal>
+    <winery-modal-header [title]="'Add a Requirement Definition'" [modalRef]="addModalRef">
+    </winery-modal-header>
+    <winery-modal-body>
+        <form #addRequirementDefinitionForm="ngForm" id="addRequirementDefinitionForm">
+            <div class="form-group">
+                <label class="control-label" for="reqDefName">Name*</label>
+                <input #reqDefName="ngModel"
+                       id="reqDefName"
+                       class="form-control"
+                       type="text"
+                       name="Requirement Definition Name"
+                       required
+                       [(ngModel)]="reqDefToBeAdded.name">
+
+                <div *ngIf="reqDefName.errors && (reqDefName.touched)"
+                     class="alert alert-danger">
+                    <div [hidden]="!reqDefName.errors.wineryDuplicateValidator">
+                        No duplicates allowed!
+                    </div>
+                    <div [hidden]="!reqDefName.errors.required">
+                        Name is required
+                    </div>
+                </div>
+            </div>
+
+            <div class="form-group">
+                <label for="capabilityType" class="control-label">Capability Type*</label>
+                <ng-select id="capabilityType"
+                           [disabled]="!sharedData?.currentVersion?.editable"
+                           [items]="allCapabilityTypes"
+                           (selected)="onSelectedCapTypeChanged($event)"
+                           [active]="initialCapabilityType">
+                </ng-select>
+            </div>
+
+            <div class="form-group">
+                <label for="nodeType" class="control-label">Node Type</label>
+                <ng-select id="nodeType"
+                           [disabled]="!sharedData?.currentVersion?.editable"
+                           [items]="allNodeTypes"
+                           (selected)="onSelectedNodeTypeChanged($event)"
+                           [active]="initialNodeType">
+                </ng-select>
+            </div>
+
+            <div class="form-group">
+                <label for="relationshipType" class="control-label">Relationship Type</label>
+                <ng-select id="relationshipType"
+                           [disabled]="!sharedData?.currentVersion?.editable"
+                           [items]="allRelationshipTypes"
+                           (selected)="onSelectedRelTypeChanged($event)"
+                           [active]="initialRelationshipType">
+                </ng-select>
+            </div>
+
+            <div class="form-group">
+                <div style="margin-bottom: 10px;">
+                    <label for="lowerBound" class="control-label">Lower Bound</label>
+                    <input type="number" class="form-control" id="lowerBound" name="lowerBound"
+                           [(ngModel)]="lowerBound"/>
+                </div>
+                <label for="upperBound" class="control-label">Upper Bound</label>
+                <div class="flex">
+                    <div>
+                        <input type="number" class="form-control" id="upperBound" name="upperBound"
+                               [disabled]="isUnboundedSelected"
+                               [(ngModel)]="upperBound"/>
+                    </div>
+                    <div class="left-margin-10 form-check" style="margin-top: 5px;">
+                        <input type="checkbox" class="form-check-input" id="isUnbounded"
+                               [checked]="isUnboundedSelected"
+                               (change)="unboundedToggle()">
+                        <label class="form-check-label" style="margin-left: 5px;" for="isUnbounded">Is Unbounded</label>
+                    </div>
+                </div>
+            </div>
+        </form>
+    </winery-modal-body>
+    <winery-modal-footer [modalRef]="addModalRef"
+                         [okButtonLabel]="'Add'"
+                         [disableOkButton]="!addRequirementDefinitionForm?.form.valid || !enableAddItemButton"
+                         (onOk)="addRequirementDefinition()">
+    </winery-modal-footer>
+</ng-template>
+
+<ng-template #removeModal>
+    <winery-modal-header [title]="'Delete Requirement Definition'" [modalRef]="removeModalRef">
+    </winery-modal-header>
+    <winery-modal-body>
+        <p *ngIf="elementToRemove != null" id="diagyesnomsg">
+            Do you want to delete the Element <span style="font-weight:bold;">{{ elementToRemove.name }}</span>?
+        </p>
+    </winery-modal-body>
+    <winery-modal-footer [modalRef]="removeModalRef"
+                         (onOk)="removeConfirmed();"
+                         [closeButtonLabel]="'No'"
+                         [okButtonLabel]="'Yes'">
+    </winery-modal-footer>
+</ng-template>
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/yamlRequirementDefinitions/yamlRequirementDefinitions.module.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/yamlRequirementDefinitions/yamlRequirementDefinitions.module.ts
new file mode 100644
index 000000000..2b392b4b6
--- /dev/null
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/yamlRequirementDefinitions/yamlRequirementDefinitions.module.ts
@@ -0,0 +1,47 @@
+/*******************************************************************************
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+
+import { NgModule } from '@angular/core';
+import { CommonModule } from '@angular/common';
+import { BrowserModule } from '@angular/platform-browser';
+import { SelectModule } from 'ng2-select';
+import { FormsModule } from '@angular/forms';
+import { RouterModule } from '@angular/router';
+import { WineryLoaderModule } from '../../../wineryLoader/wineryLoader.module';
+import { WineryQNameSelectorModule } from '../../../wineryQNameSelector/wineryQNameSelector.module';
+import { WineryModalModule } from '../../../wineryModalModule/winery.modal.module';
+import { WineryTableModule } from '../../../wineryTableModule/wineryTable.module';
+import { YamlRequirementDefinitionsComponent } from './yamlRequirementDefinitions.component';
+import { SpinnerWithInfinityModule } from '../../../winerySpinnerWithInfinityModule/winerySpinnerWithInfinity.module';
+
+@NgModule({
+    imports: [
+        CommonModule,
+        BrowserModule,
+        SelectModule,
+        FormsModule,
+        CommonModule,
+        RouterModule,
+        WineryLoaderModule,
+        WineryQNameSelectorModule,
+        WineryModalModule,
+        WineryTableModule,
+        SpinnerWithInfinityModule
+    ],
+    exports: [YamlRequirementDefinitionsComponent],
+    declarations: [YamlRequirementDefinitionsComponent],
+    providers: [],
+})
+export class YamlRequirementDefinitionsModule {
+}
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/yamlRequirementDefinitions/yamlRequirementDefinitions.service.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/yamlRequirementDefinitions/yamlRequirementDefinitions.service.ts
new file mode 100644
index 000000000..bcecafe75
--- /dev/null
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/yamlRequirementDefinitions/yamlRequirementDefinitions.service.ts
@@ -0,0 +1,61 @@
+/*******************************************************************************
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+
+import { Injectable } from '@angular/core';
+import { HttpClient } from '@angular/common/http';
+import { Observable } from 'rxjs';
+import { backendBaseURL } from '../../../configuration';
+import { SelectData } from '../../../model/selectData';
+import { ToscaTypes } from '../../../model/enums';
+import { Router } from '@angular/router';
+import { YamlRequirementDefinitionApiData, YamlRequirementDefinitionPostApiData } from './yamlRequirementDefinitionApiData';
+
+@Injectable()
+export class YamlRequirementDefinitionsService {
+    private readonly path: string;
+
+    constructor(private http: HttpClient,
+                private route: Router) {
+        // we have the same path in the backend for both xml and yaml
+        this.path = this.route.url.replace('yaml', '');
+    }
+
+    getAllRequirementDefinitions(): Observable<YamlRequirementDefinitionApiData[]> {
+        const url = backendBaseURL + this.path;
+        return this.http.get<YamlRequirementDefinitionApiData[]>(url);
+    }
+
+    getGroupedNodeTypes(): Observable<SelectData[]> {
+        return this.getAllTypes(ToscaTypes.NodeType);
+    }
+
+    getCapabilityTypes(): Observable<SelectData[]> {
+        return this.getAllTypes(ToscaTypes.CapabilityType);
+    }
+
+    getRelationshipTypes(): Observable<SelectData[]> {
+        return this.getAllTypes(ToscaTypes.RelationshipType);
+    }
+
+    getAllTypes(type: ToscaTypes): Observable<SelectData[]> {
+        const url = backendBaseURL + '/' + type + '?grouped=angularSelect&dev=true/';
+        return this.http.get<SelectData[]>(url);
+    }
+
+    saveRequirementDefinition(reqDef: YamlRequirementDefinitionApiData): Observable<any> {
+        const postData = YamlRequirementDefinitionPostApiData.fromData(reqDef);
+        const url = backendBaseURL + this.path;
+        return this.http.post<any>(url, postData);
+    }
+}
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/yamlRequirementDefinitions/yamlRequirementDefinitions.style.css b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/yamlRequirementDefinitions/yamlRequirementDefinitions.style.css
new file mode 100644
index 000000000..91ef1be1a
--- /dev/null
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/nodeTypes/yamlRequirementDefinitions/yamlRequirementDefinitions.style.css
@@ -0,0 +1,18 @@
+/*******************************************************************************
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+
+.flex {
+    display: flex;
+    flex-direction: row;
+}
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/sharedComponents/inheritance/inheritance.component.html b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/sharedComponents/inheritance/inheritance.component.html
index 798872ff5..ffd41f3bb 100644
--- a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/sharedComponents/inheritance/inheritance.component.html
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/sharedComponents/inheritance/inheritance.component.html
@@ -19,7 +19,7 @@
         <button class="btn btn-info" (click)="onAddSubType()">
             Add a subtype
         </button>
-        <button class="btn btn-primary" name="save" (click)="saveToServer()"
+        <button class="btn btn-primary left-margin-10" name="save" (click)="saveToServer()"
                 [disabled]="!sharedData?.currentVersion?.editable">
             Save
         </button>
@@ -39,7 +39,7 @@
         </select>
     </div>
 
-    <p>Derived from</p>
+    <label class="control-label">Derived From</label>
     <ng-select #derivedFromSelector
                [disabled]="!sharedData?.currentVersion?.editable"
                [items]="availableSuperClasses"
@@ -47,7 +47,7 @@
                [active]="initialActiveItem">
     </ng-select>
     <br>
-    <button class="btn btn-info btn-sm" [disabled]="!enableButton" (click)="onButtonClick()">open</button>
+    <button class="btn btn-info btn-sm" [disabled]="!enableButton" (click)="onButtonClick()">Open</button>
 </div>
 
 <winery-add-component #addSubTypeModal
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/sharedComponents/propertiesDefinition/propertiesDefinition.component.html b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/sharedComponents/propertiesDefinition/propertiesDefinition.component.html
index f6457f900..68d409bc3 100644
--- a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/sharedComponents/propertiesDefinition/propertiesDefinition.component.html
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/sharedComponents/propertiesDefinition/propertiesDefinition.component.html
@@ -16,7 +16,7 @@
 </div>
 <div *ngIf="!loading">
     <div class="radioWrapper">
-        <div class="left">
+        <div class="left" *wineryRepositoryHideOnFeature="configEnum.Yaml">
             <input id="nopropdef" type="radio" name="kind" (click)="onNoneSelected()"
                    [disabled]="!sharedData?.currentVersion?.editable"
                    [checked]="resourceApiData.selectedValue === propertiesEnum.None">
@@ -38,7 +38,9 @@
             <label for="customkv" class="cursorpointer">Custom key/value pairs</label>
         </div>
         <div class="right">
-            <button class="btn btn-primary" name="save" [disabled]="!sharedData?.currentVersion?.editable" (click)="save()">Save</button>
+            <button class="btn btn-primary" name="save" [disabled]="!sharedData?.currentVersion?.editable"
+                    (click)="save()">Save
+            </button>
         </div>
     </div>
     <div>
@@ -59,7 +61,7 @@
                         (addBtnClicked)="onAddClick();">
                     </winery-table>
                 </tab>
-                <tab heading="Wrapper">
+                <tab heading="Wrapper" *wineryRepositoryHideOnFeature="configEnum.Yaml">
                     <div class="wrapperTab">
                         <label for="wrapperName">Name of Wrapper Element</label><br>
                         <input id="wrapperName"
@@ -120,12 +122,25 @@
                     <option value="xsd:QName">xsd:QName</option>
                 </select>
             </div>
+            <div class="form-group">
+                <label class="control-label" for="defaultValue">Default Value</label>
+                <input #propertyDefaultValue id="defaultValue" class="form-control" type="text"/>
+            </div>
+            <div class="form-group">
+                <input type="checkbox" id="isRequired" #propertyIsRequired style="margin-right: 7px"/>
+                <label class="control-label" for="isRequired">Is required</label>
+            </div>
+            <div class="form-group">
+                <label class="control-label" for="defaultValue">Description</label>
+                <input #propertyDescription id="description" class="form-control" type="text"/>
+            </div>
         </form>
     </winery-modal-body>
-    <winery-modal-footer (onOk)="addProperty(selectProperty.value, propName.value); addPropertyFrom.reset();"
-                         [closeButtonLabel]="'Cancel'"
-                         [okButtonLabel]="'Add'"
-                         [disableOkButton]="!addPropertyFrom?.form.valid">
+    <winery-modal-footer
+        (onOk)="addProperty(selectProperty.value, propName.value, propertyIsRequired.checked, propertyDefaultValue.value, propertyDescription.value); addPropertyFrom.reset();"
+        [closeButtonLabel]="'Cancel'"
+        [okButtonLabel]="'Add'"
+        [disableOkButton]="!addPropertyFrom?.form.valid">
     </winery-modal-footer>
 </winery-modal>
 
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/sharedComponents/propertiesDefinition/propertiesDefinition.component.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/sharedComponents/propertiesDefinition/propertiesDefinition.component.ts
index 9d4075fef..3c788774f 100644
--- a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/sharedComponents/propertiesDefinition/propertiesDefinition.component.ts
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/sharedComponents/propertiesDefinition/propertiesDefinition.component.ts
@@ -15,8 +15,7 @@ import { Component, ElementRef, OnInit, ViewChild } from '@angular/core';
 import { InstanceService } from '../../instance.service';
 import { PropertiesDefinitionService } from './propertiesDefinition.service';
 import {
-    PropertiesDefinition, PropertiesDefinitionEnum, PropertiesDefinitionKVElement, PropertiesDefinitionsResourceApiData,
-    WinerysPropertiesDefinition
+    PropertiesDefinition, PropertiesDefinitionEnum, PropertiesDefinitionKVElement, PropertiesDefinitionsResourceApiData, WinerysPropertiesDefinition
 } from './propertiesDefinitionsResourceApiData';
 import { SelectData } from '../../../model/selectData';
 import { isNullOrUndefined } from 'util';
@@ -25,6 +24,8 @@ import { WineryValidatorObject } from '../../../wineryValidators/wineryDuplicate
 import { WineryRowData, WineryTableColumn } from '../../../wineryTableModule/wineryTable.component';
 import { ModalDirective } from 'ngx-bootstrap';
 import { HttpErrorResponse, HttpResponse } from '@angular/common/http';
+import { WineryRepositoryConfigurationService } from '../../../wineryFeatureToggleModule/WineryRepositoryConfiguration.service';
+import { FeatureEnum } from '../../../wineryFeatureToggleModule/wineryRepository.feature.direct';
 
 @Component({
     templateUrl: 'propertiesDefinition.component.html',
@@ -48,8 +49,12 @@ export class PropertiesDefinitionComponent implements OnInit {
     columns: Array<WineryTableColumn> = [
         { title: 'Name', name: 'key', sort: true },
         { title: 'Type', name: 'type', sort: true },
+        { title: 'Required', name: 'required' },
+        { title: 'Default Value', name: 'defaultValue' },
+        { title: 'Description', name: 'description' },
     ];
     newProperty: PropertiesDefinitionKVElement = new PropertiesDefinitionKVElement();
+    configEnum = FeatureEnum;
 
     validatorObject: WineryValidatorObject;
     @ViewChild('confirmDeleteModal') confirmDeleteModal: ModalDirective;
@@ -57,7 +62,7 @@ export class PropertiesDefinitionComponent implements OnInit {
     @ViewChild('nameInputForm') nameInputForm: ElementRef;
 
     constructor(public sharedData: InstanceService, private service: PropertiesDefinitionService,
-                private notify: WineryNotificationService) {
+                private notify: WineryNotificationService, private configurationService: WineryRepositoryConfigurationService) {
     }
 
     // region ########## Angular Callbacks ##########
@@ -225,11 +230,17 @@ export class PropertiesDefinitionComponent implements OnInit {
      * Adds a property to the table and model
      * @param propType
      * @param propName
+     * @param required
+     * @param defaultValue
+     * @param description
      */
-    addProperty(propType: string, propName: string) {
+    addProperty(propType: string, propName: string, required: boolean, defaultValue: string, description: string) {
         this.resourceApiData.winerysPropertiesDefinition.propertyDefinitionKVList.push({
             key: propName,
-            type: propType
+            type: propType,
+            defaultValue: defaultValue,
+            required: required,
+            description: description,
         });
         this.addModal.hide();
     }
@@ -319,7 +330,11 @@ export class PropertiesDefinitionComponent implements OnInit {
                 this.onCustomKeyValuePairSelected();
                 break;
             default:
-                this.resourceApiData.selectedValue = PropertiesDefinitionEnum.None;
+                if (this.configurationService.configuration.features.yaml) {
+                    this.onCustomKeyValuePairSelected();
+                } else {
+                    this.resourceApiData.selectedValue = PropertiesDefinitionEnum.None;
+                }
         }
 
         this.handleSuccess(data);
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/sharedComponents/propertiesDefinition/propertiesDefinition.module.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/sharedComponents/propertiesDefinition/propertiesDefinition.module.ts
index 121237a74..114906b8f 100644
--- a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/sharedComponents/propertiesDefinition/propertiesDefinition.module.ts
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/sharedComponents/propertiesDefinition/propertiesDefinition.module.ts
@@ -11,18 +11,19 @@
  *
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  *******************************************************************************/
-import {CommonModule} from '@angular/common';
-import {NgModule} from '@angular/core';
-import {FormsModule} from '@angular/forms';
-import {BrowserModule} from '@angular/platform-browser';
-import {TabsModule} from 'ngx-bootstrap';
-import {SelectModule} from 'ng2-select';
-import {WineryLoaderModule} from '../../../wineryLoader/wineryLoader.module';
-import {WineryNamespaceSelectorModule} from '../../../wineryNamespaceSelector/wineryNamespaceSelector.module';
-import {WineryDuplicateValidatorModule} from '../../../wineryValidators/wineryDuplicateValidator.module';
-import {WineryModalModule} from '../../../wineryModalModule/winery.modal.module';
-import {WineryTableModule} from '../../../wineryTableModule/wineryTable.module';
-import {PropertiesDefinitionComponent} from './propertiesDefinition.component';
+import { CommonModule } from '@angular/common';
+import { NgModule } from '@angular/core';
+import { FormsModule } from '@angular/forms';
+import { BrowserModule } from '@angular/platform-browser';
+import { TabsModule } from 'ngx-bootstrap';
+import { SelectModule } from 'ng2-select';
+import { WineryLoaderModule } from '../../../wineryLoader/wineryLoader.module';
+import { WineryNamespaceSelectorModule } from '../../../wineryNamespaceSelector/wineryNamespaceSelector.module';
+import { WineryDuplicateValidatorModule } from '../../../wineryValidators/wineryDuplicateValidator.module';
+import { WineryModalModule } from '../../../wineryModalModule/winery.modal.module';
+import { WineryTableModule } from '../../../wineryTableModule/wineryTable.module';
+import { PropertiesDefinitionComponent } from './propertiesDefinition.component';
+import { WineryFeatureToggleModule } from '../../../wineryFeatureToggleModule/winery-feature-toggle.module';
 
 @NgModule({
     imports: [
@@ -36,6 +37,7 @@ import {PropertiesDefinitionComponent} from './propertiesDefinition.component';
         WineryModalModule,
         WineryTableModule,
         WineryDuplicateValidatorModule,
+        WineryFeatureToggleModule,
     ],
     exports: [],
     declarations: [
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/sharedComponents/propertiesDefinition/propertiesDefinitionsResourceApiData.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/sharedComponents/propertiesDefinition/propertiesDefinitionsResourceApiData.ts
index 2a1fd6f0d..8d3550f11 100644
--- a/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/sharedComponents/propertiesDefinition/propertiesDefinitionsResourceApiData.ts
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/instance/sharedComponents/propertiesDefinition/propertiesDefinitionsResourceApiData.ts
@@ -22,6 +22,9 @@ export enum PropertiesDefinitionEnum {
 export class PropertiesDefinitionKVElement {
     key: string = null;
     type: string = null;
+    required: boolean;
+    defaultValue: string;
+    description: string;
 }
 
 export class PropertiesDefinition {
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/model/qNameApiData.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/model/qNameApiData.ts
new file mode 100644
index 000000000..d12268357
--- /dev/null
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/model/qNameApiData.ts
@@ -0,0 +1,28 @@
+/*******************************************************************************
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+import { QName } from './qName';
+
+export class QNameApiData {
+
+    static fromQName(qName: QName) {
+        return new QNameApiData(qName.localPart, qName.namespace);
+    }
+
+    constructor(public localname: string, public namespace: string) {
+    }
+
+    equals(item: QNameApiData) {
+        return this.localname === item.localname && this.namespace === item.namespace;
+    }
+}
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/other/other.component.html b/org.eclipse.winery.frontends/app/tosca-management/src/app/other/other.component.html
index bd8b5ef2f..31f1379a3 100644
--- a/org.eclipse.winery.frontends/app/tosca-management/src/app/other/other.component.html
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/other/other.component.html
@@ -12,32 +12,41 @@
   ~ SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
 <div class="otherelement">
-    <p>The following items list TOSCA elements contained in TOSCA's
+    <p *ngIf="!configurationService.isYaml(); else yamlDesc">The following items list TOSCA elements contained in
+        TOSCA's
         <code>Definitions</code>
-        element, which are not listed as separate tabs
+        element, which are not listed as separate tabs.
     </p>
+    <ng-template #yamlDesc>
+        <p>The following items list TOSCA elements contained in a TOSCA YAML
+            <code>ServiceTemplate</code>, which are not listed as separate tabs.</p>
+    </ng-template>
     <h4>Artifacts</h4>
-    <a class="btn btn-default" [routerLink]="['/artifacttypes']">Artifact Types</a>
+    <a class="btn btn-default right-margin-10" [routerLink]="['/artifacttypes']">Artifact Types</a>
     <a class="btn btn-default" [routerLink]="['/artifacttemplates']">Artifact Templates</a>
-    <h4>Requirements and Capabilities</h4>
-    <a class="btn btn-default" [routerLink]="['/requirementtypes']">Requirement Types</a>
+    <h4> {{!configurationService.isYaml() ? 'Requirements and ' : ''}} Capabilities</h4>
+    <!-- todo use the directive instead of the service-->
+    <a class="btn btn-default right-margin-10" [routerLink]="['/requirementtypes']" *ngIf="!configurationService.isYaml()">
+        Requirement Types
+    </a>
     <a class="btn btn-default" [routerLink]="['/capabilitytypes']">Capability Types</a>
     <h4>Implementations</h4>
-    <a class="btn btn-default" [routerLink]="['/nodetypeimplementations']">Node Type Implementations</a>
+    <a class="btn btn-default right-margin-10" [routerLink]="['/nodetypeimplementations']">Node Type Implementations</a>
     <a class="btn btn-default" [routerLink]="['/relationshiptypeimplementations']">Relationship Type Implementations</a>
     <h4>Policies</h4>
-    <a class="btn btn-default" [routerLink]="['/policytypes']">Policy Types</a>
+    <a class="btn btn-default right-margin-10" [routerLink]="['/policytypes']">Policy Types</a>
     <a class="btn btn-default" [routerLink]="['/policytemplates']">Policy Templates</a>
     <hr>
     <h4>Imports</h4>
-    <a class="btn btn-default" [routerLink]="['/imports/http%3A%2F%2Fwww.w3.org%2F2001%2FXMLSchema/']">XML Schema
+    <a class="btn btn-default right-margin-10" [routerLink]="['/imports/http%3A%2F%2Fwww.w3.org%2F2001%2FXMLSchema/']">XML
+        Schema
         Definitions</a>
     <a class="btn btn-default"
        [routerLink]="['/imports/http%3A%2F%2Fschemas.xmlsoap.org%2Fwsdl%2F']">WSDLs</a>
     <hr>
     <div *wineryRepositoryFeatureToggle="configEnum.PatternRefinement">
         <h4>Refinement Models</h4>
-        <a class="btn btn-default" [routerLink]="['/patternrefinementmodels']"
+        <a class="btn btn-default right-margin-10" [routerLink]="['/patternrefinementmodels']"
            *wineryRepositoryFeatureToggle="configEnum.PatternRefinement">
             Pattern Refinement Models
         </a>
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/other/other.component.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/other/other.component.ts
index 3bf101132..da11a276b 100644
--- a/org.eclipse.winery.frontends/app/tosca-management/src/app/other/other.component.ts
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/other/other.component.ts
@@ -13,6 +13,7 @@
  *******************************************************************************/
 import { Component } from '@angular/core';
 import { FeatureEnum } from '../wineryFeatureToggleModule/wineryRepository.feature.direct';
+import { WineryRepositoryConfigurationService } from '../wineryFeatureToggleModule/WineryRepositoryConfiguration.service';
 
 @Component({
     templateUrl: './other.component.html',
@@ -20,4 +21,7 @@ import { FeatureEnum } from '../wineryFeatureToggleModule/wineryRepository.featu
 })
 export class OtherComponent {
     configEnum = FeatureEnum;
+
+    constructor(public configurationService: WineryRepositoryConfigurationService) {
+    }
 }
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryAddComponentModule/addComponent.component.html b/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryAddComponentModule/addComponent.component.html
index 653011e30..29eaafc9c 100644
--- a/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryAddComponentModule/addComponent.component.html
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryAddComponentModule/addComponent.component.html
@@ -53,54 +53,71 @@
                                 <label for="newComponentVersion" class="control-label">Versioning:</label>
                                 <button type="button" class="btn btn-default btn-xs collapsebtn"
                                         (click)="collapseVersioning = !collapseVersioning" style="float: right;">
-                                    <span class="collapsespan" aria-hidden="true" [class.collapsed]="collapseVersioning"></span>
+                                    <span class="collapsespan" aria-hidden="true"
+                                          [class.collapsed]="collapseVersioning"></span>
                                 </button>
                             </div>
                             <div [collapse]="collapseVersioning">
-                                <label for="newComponentVersion">
-                                    Component version
-                                </label>
-                                <i class="fa fa-question-circle" tooltip="click me" (click)="showHelp()"></i>
-                                <input type="text"
-                                       id="newComponentVersion"
-                                       name="newComponentVersion"
-                                       class="form-control"
-                                       #newVersion="ngModel"
-                                       (input)="onInputChange()"
-                                       [(ngModel)]="newComponentVersion.componentVersion">
-                                <div *ngIf="(newName.dirty || newName.touched) && validation?.noVersionProvidedWarning"
-                                     class="alert alert-warning">
-                                    <div>
-                                        You haven't provided a version!
-                                    </div>
+                                <div class="checkbox">
+                                    <label>
+                                        <input name="versioning_checkbox" [checked]="useComponentVersion"
+                                               (change)="onToggleUseVersion()" type="checkbox">
+                                        Enable Versioning
+                                    </label>
                                 </div>
-                                <p *ngIf="!hideHelp" class="help-block">
-                                    The <b>component version</b> specifies the components' external version defined by the creator of the
-                                    software (e.g., Apache Tomcat 8.5.1 has a component version <code>8.5.1</code>). Winery adds management
-                                    to the software which is versioned independently of the softwares' version. The version inside Winery is
-                                    called <b>management version</b> and is mandatory. It consists of a <b>winery version</b> and a <b>work
-                                    in progress (wip)</b> version. Upon the creation of a new component, both management versions are set
-                                    automatically with their initial values of 1. The generated name is displayed in the 'Final name' field
-                                    (e.g., the final id for Apache Tomcat 8.5.1 is <code>Tomcat_8.5.1-w1-wip1</code>).
-                                    <br><br>
-                                    When developing a TOSCA definition, a the wip version is appended until the TOSCA definition is stable.
-                                    To test a TOSCA definition, the wip version can be committed. After a version was committed, a new
-                                    version must be added to apply further changes. Thus, a new wip version must be added (e.g.,
-                                    <code>Tomcat_8.5.1-w1-wip1</code> followed by <code>Tomcat_8.5.1-w1-wip2</code> released as
-                                    <code>Tomcat_8.5.1-w1</code> must be followed by <code>Tomcat_8.5.1-w2-wip1</code> to enable changes).
-                                    Thereby, different component versions do not affect each other (e.g., <code>Tomcat_8.5.1-w2-wip1</code>
-                                    can be created while <code>Tomcat_9.0.1-w3</code> exists).
-                                </p>
-                                <div *ngIf="(validation?.noUnderscoresAllowed)
+                                <div *ngIf="useComponentVersion">
+                                    <label for="newComponentVersion" style="padding-right: 5px">
+                                        Component version
+                                    </label>
+                                    <i class="fa fa-question-circle" tooltip="click me" (click)="showHelp()"></i>
+                                    <input type="text"
+                                           id="newComponentVersion"
+                                           name="newComponentVersion"
+                                           class="form-control"
+                                           #newVersion="ngModel"
+                                           (input)="onInputChange()"
+                                           [(ngModel)]="newComponentVersion.componentVersion">
+                                    <div
+                                        *ngIf="(newName.dirty || newName.touched) && validation?.noVersionProvidedWarning"
+                                        class="alert alert-warning">
+                                        <div>
+                                            You haven't provided a version!
+                                        </div>
+                                    </div>
+                                    <p *ngIf="!hideHelp" class="help-block">
+                                        The <b>component version</b> specifies the components' external version defined
+                                        by the creator of the software (e.g., Apache Tomcat 8.5.1 has a component
+                                        version <code>8.5.1</code>). Winery adds management
+                                        to the software which is versioned independently of the softwares' version. The
+                                        version inside Winery is called <b>management version</b> and is mandatory. It
+                                        consists of a <b>winery version</b> and a <b>work in progress (wip)</b> version.
+                                        Upon the creation of a new component, both management versions are set
+                                        automatically with their initial values of 1. The generated name is displayed in
+                                        the 'Final name' field (e.g., the final id for Apache Tomcat 8.5.1 is <code>Tomcat_8.5.1-w1-wip1</code>).
+                                        <br><br>
+                                        When developing a TOSCA definition, a the wip version is appended until the
+                                        TOSCA definition is stable. To test a TOSCA definition, the wip version can be
+                                        committed. After a version was committed, a new version must be added to apply
+                                        further changes. Thus, a new wip version must be added (e.g., <code>Tomcat_8.5.1-w1-wip1</code>
+                                        followed by <code>Tomcat_8.5.1-w1-wip2</code> released as
+                                        <code>Tomcat_8.5.1-w1</code> must be followed by
+                                        <code>Tomcat_8.5.1-w2-wip1</code> to enable changes). Thereby, different
+                                        component versions do not affect each other (e.g.,
+                                        <code>Tomcat_8.5.1-w2-wip1</code> can be created while
+                                        <code>Tomcat_9.0.1-w3</code> exists).
+                                    </p>
+                                    <div *ngIf="(validation?.noUnderscoresAllowed)
                                     && (newVersion.dirty || newVersion.touched)"
-                                     class="alert alert-danger">
-                                    <div [hidden]="!validation?.noUnderscoresAllowed">
-                                        Underscores are not allowed in the version!<br>Please replace them with dashes.
+                                         class="alert alert-danger">
+                                        <div [hidden]="!validation?.noUnderscoresAllowed">
+                                            Underscores are not allowed in the version!<br>Please replace them with
+                                            dashes.
+                                        </div>
                                     </div>
+                                    <br>
+                                    <label for="finalName">Final name</label>
+                                    <code class="form-control" id="finalName">{{ newComponentFinalName }}</code>
                                 </div>
-                                <br>
-                                <label for="finalName">Final name</label>
-                                <code class="form-control" id="finalName">{{ newComponentFinalName }}</code>
                             </div>
                         </div>
                     </div>
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryAddComponentModule/addComponent.component.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryAddComponentModule/addComponent.component.ts
index 12b8500d7..6463a4e7f 100644
--- a/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryAddComponentModule/addComponent.component.ts
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryAddComponentModule/addComponent.component.ts
@@ -66,6 +66,8 @@ export class WineryAddComponent {
     newComponentSelectedType: SelectData = new SelectData();
     newComponentVersion: WineryVersion = new WineryVersion('', 1, 1);
 
+    useComponentVersion = true;
+
     validation: AddComponentValidation;
 
     types: SelectData[];
@@ -224,7 +226,10 @@ export class WineryAddComponent {
         }
 
         if (!isNullOrUndefined(this.newComponentFinalName) && this.newComponentFinalName.length > 0) {
-            this.newComponentFinalName += WineryVersion.WINERY_NAME_FROM_VERSION_SEPARATOR + this.newComponentVersion.toString();
+            if (this.useComponentVersion) {
+                this.newComponentFinalName += WineryVersion.WINERY_NAME_FROM_VERSION_SEPARATOR + this.newComponentVersion.toString();
+            }
+
             const duplicate = this.componentData.find((component) => component.name.toLowerCase() === this.newComponentFinalName.toLowerCase());
 
             if (!isNullOrUndefined(duplicate)) {
@@ -243,7 +248,7 @@ export class WineryAddComponent {
             }
         }
 
-        if (this.newComponentVersion.componentVersion) {
+        if (this.newComponentVersion.componentVersion && this.useComponentVersion) {
             this.validation.noUnderscoresAllowed = this.newComponentVersion.componentVersion.includes('_');
             if (this.validation.noUnderscoresAllowed) {
                 return { noUnderscoresAllowed: true };
@@ -251,7 +256,12 @@ export class WineryAddComponent {
         }
 
         this.validation.noVersionProvidedWarning = isNullOrUndefined(this.newComponentVersion.componentVersion)
-            || this.newComponentVersion.componentVersion.length === 0;
+            || this.newComponentVersion.componentVersion.length === 0 || !this.useComponentVersion;
+    }
+
+    onToggleUseVersion() {
+        this.useComponentVersion = !this.useComponentVersion;
+        this.onInputChange();
     }
 
     private handleComponentData(data: SectionData[]) {
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryFeatureToggleModule/WineryRepositoryConfiguration.service.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryFeatureToggleModule/WineryRepositoryConfiguration.service.ts
index e98a271ab..2b8633224 100644
--- a/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryFeatureToggleModule/WineryRepositoryConfiguration.service.ts
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryFeatureToggleModule/WineryRepositoryConfiguration.service.ts
@@ -31,6 +31,7 @@ export interface WineryConfiguration {
         placement: boolean;
         edmmModeling: boolean;
         updateTemplates: boolean;
+        yaml: boolean;
     };
     endpoints: {
         container: String;
@@ -66,4 +67,8 @@ export class WineryRepositoryConfigurationService {
             );
         return subject.asObservable();
     }
+
+    isYaml(): boolean {
+        return this.configuration.features.yaml;
+    }
 }
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryFeatureToggleModule/winery-feature-toggle.module.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryFeatureToggleModule/winery-feature-toggle.module.ts
index d1d1c9cc9..c35394d38 100644
--- a/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryFeatureToggleModule/winery-feature-toggle.module.ts
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryFeatureToggleModule/winery-feature-toggle.module.ts
@@ -15,19 +15,23 @@
 import { NgModule } from '@angular/core';
 import { FeatureToggleDirective } from './wineryRepository.feature.direct';
 import { CommonModule } from '@angular/common';
-import { FormsModule } from '@angular/forms';
 import { WineryRepositoryConfigurationService } from './WineryRepositoryConfiguration.service';
+import { HideOnFeatureDirective } from './wineryRepository.hideOnFeature.direct';
+import { ShowOnFeatureDirective } from './wineryRepository.showOnFeature.direct';
 
 @NgModule({
     imports: [CommonModule],
     declarations: [
-        FeatureToggleDirective
+        FeatureToggleDirective,
+        HideOnFeatureDirective,
+        ShowOnFeatureDirective,
     ],
     exports: [
-        FeatureToggleDirective
+        FeatureToggleDirective,
+        HideOnFeatureDirective,
+        ShowOnFeatureDirective,
     ],
     providers: [WineryRepositoryConfigurationService]
 })
-
 export class WineryFeatureToggleModule {
 }
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryFeatureToggleModule/wineryRepository.feature.direct.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryFeatureToggleModule/wineryRepository.feature.direct.ts
index 6c24d7bb4..398c7dcfa 100644
--- a/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryFeatureToggleModule/wineryRepository.feature.direct.ts
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryFeatureToggleModule/wineryRepository.feature.direct.ts
@@ -11,46 +11,24 @@
  *
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  *******************************************************************************/
-import { Directive, Input, OnInit, TemplateRef, ViewContainerRef } from '@angular/core';
-import { WineryRepositoryConfigurationService } from './WineryRepositoryConfiguration.service';
+import { Directive, Input, OnInit } from '@angular/core';
+import { ShowOnFeatureDirective } from './wineryRepository.showOnFeature.direct';
 
 export enum FeatureEnum {
     Accountability = 'accountability', Completion = 'completion', Compliance = 'compliance', FreezeAndDefrost = 'freezeAndDefrost',
     ManagementFeatureEnrichment = 'managementFeatureEnrichment', NFV = 'nfv', PatternRefinement = 'patternRefinement', ProblemDetection = 'problemDetection',
-    Splitting = 'splitting', TestRefinement = 'testRefinement', Placement = 'placement', updateTemplates = 'updateTemplates'
+    Splitting = 'splitting', TestRefinement = 'testRefinement', Placement = 'placement', updateTemplates = 'updateTemplates', Yaml = 'yaml'
 }
 
 @Directive({
     selector: '[wineryRepositoryFeatureToggle]'
 })
-export class FeatureToggleDirective implements OnInit {
-    @Input() wineryRepositoryFeatureToggle: string | string[];
+export class FeatureToggleDirective extends ShowOnFeatureDirective implements OnInit {
 
-    constructor(
-        private templateRef: TemplateRef<any>,
-        private viewContainer: ViewContainerRef,
-        private configService: WineryRepositoryConfigurationService
-    ) {
-    }
+    @Input('wineryRepositoryFeatureToggle') data: string | string[];
 
     ngOnInit() {
-        if (Array.isArray(this.wineryRepositoryFeatureToggle)) {
-            let found = false;
-            for (const feature of this.wineryRepositoryFeatureToggle) {
-                if (this.configService.configuration.features[feature]) {
-                    this.viewContainer.createEmbeddedView(this.templateRef);
-                    found = true;
-                }
-            }
-            if (!found) {
-                this.viewContainer.clear();
-            }
-        } else if (typeof this.wineryRepositoryFeatureToggle === 'string') {
-            if (this.configService.configuration.features[this.wineryRepositoryFeatureToggle]) {
-                this.viewContainer.createEmbeddedView(this.templateRef);
-            } else {
-                this.viewContainer.clear();
-            }
-        }
+        this.featuresToShow = this.data;
+        super.ngOnInit();
     }
 }
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryFeatureToggleModule/wineryRepository.hideOnFeature.direct.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryFeatureToggleModule/wineryRepository.hideOnFeature.direct.ts
new file mode 100644
index 000000000..3728cea4b
--- /dev/null
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryFeatureToggleModule/wineryRepository.hideOnFeature.direct.ts
@@ -0,0 +1,48 @@
+/*******************************************************************************
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+import { Directive, Input, OnInit, TemplateRef, ViewContainerRef } from '@angular/core';
+import { WineryRepositoryConfigurationService } from './WineryRepositoryConfiguration.service';
+
+@Directive({
+    selector: '[wineryRepositoryHideOnFeature]'
+})
+export class HideOnFeatureDirective implements OnInit {
+
+    @Input('wineryRepositoryHideOnFeature') featuresToHide: string | string[];
+
+    constructor(private templateRef: TemplateRef<any>, private viewContainerRef: ViewContainerRef,
+                private configurationService: WineryRepositoryConfigurationService) {
+    }
+
+    ngOnInit() {
+        if (Array.isArray(this.featuresToHide)) {
+            let found = false;
+            for (const feature of this.featuresToHide) {
+                if (this.configurationService.configuration.features[feature]) {
+                    this.viewContainerRef.clear();
+                    found = true;
+                }
+            }
+            if (!found) {
+                this.viewContainerRef.createEmbeddedView(this.templateRef);
+            }
+        } else if (typeof this.featuresToHide === 'string') {
+            if (this.configurationService.configuration.features[this.featuresToHide]) {
+                this.viewContainerRef.clear();
+            } else {
+                this.viewContainerRef.createEmbeddedView(this.templateRef);
+            }
+        }
+    }
+}
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryFeatureToggleModule/wineryRepository.showOnFeature.direct.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryFeatureToggleModule/wineryRepository.showOnFeature.direct.ts
new file mode 100644
index 000000000..8d06d1516
--- /dev/null
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryFeatureToggleModule/wineryRepository.showOnFeature.direct.ts
@@ -0,0 +1,48 @@
+/*******************************************************************************
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+import { Directive, Input, OnInit, TemplateRef, ViewContainerRef } from '@angular/core';
+import { WineryRepositoryConfigurationService } from './WineryRepositoryConfiguration.service';
+
+@Directive({
+    selector: '[wineryRepositoryShowOnFeature]'
+})
+export class ShowOnFeatureDirective implements OnInit {
+
+    @Input('wineryRepositoryShowOnFeature') public featuresToShow: string | string[];
+
+    constructor(private templateRef: TemplateRef<any>, private viewContainerRef: ViewContainerRef,
+                private configurationService: WineryRepositoryConfigurationService) {
+    }
+
+    ngOnInit() {
+        if (Array.isArray(this.featuresToShow)) {
+            let found = false;
+            for (const feature of this.featuresToShow) {
+                if (this.configurationService.configuration.features[feature]) {
+                    this.viewContainerRef.createEmbeddedView(this.templateRef);
+                    found = true;
+                }
+            }
+            if (!found) {
+                this.viewContainerRef.clear();
+            }
+        } else if (typeof this.featuresToShow === 'string') {
+            if (this.configurationService.configuration.features[this.featuresToShow]) {
+                this.viewContainerRef.createEmbeddedView(this.templateRef);
+            } else {
+                this.viewContainerRef.clear();
+            }
+        }
+    }
+}
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryLicenseModule/wineryLicense.service.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryLicenseModule/wineryLicense.service.ts
index 183e91cb3..f016f38a5 100644
--- a/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryLicenseModule/wineryLicense.service.ts
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryLicenseModule/wineryLicense.service.ts
@@ -26,9 +26,9 @@ export class WineryLicenseService {
 
     constructor(private http: HttpClient, private sharedData: InstanceService) {
         this._allLicences = [
-            new WineryLicense('Apache-2.0', 'assets/licenses/Apache-2.0.txt'),
-            new WineryLicense('EPL-2.0', 'assets/licenses/EPL-2.0.txt'),
-            new WineryLicense('Proprietary', 'assets/licenses/Proprietary.txt')
+            new WineryLicense('Apache-2.0', '/assets/licenses/Apache-2.0.txt'),
+            new WineryLicense('EPL-2.0', '/assets/licenses/EPL-2.0.txt'),
+            new WineryLicense('Proprietary', '/assets/licenses/Proprietary.txt')
         ];
     }
 
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryMainModules/capabilityTypes/capabilityType.module.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryMainModules/capabilityTypes/capabilityType.module.ts
index e98b2511c..026e40084 100644
--- a/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryMainModules/capabilityTypes/capabilityType.module.ts
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryMainModules/capabilityTypes/capabilityType.module.ts
@@ -11,18 +11,20 @@
  *
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  *******************************************************************************/
-import {NgModule} from '@angular/core';
-import {CommonModule} from '@angular/common';
-import {CapabilityTypeRouterModule} from './capabilityTypeRouter.module';
-import {WineryReadmeModule} from '../../wineryReadmeModule/wineryReadme.module';
-import {WineryLicenseModule} from '../../wineryLicenseModule/wineryLicense.module';
+import { NgModule } from '@angular/core';
+import { CommonModule } from '@angular/common';
+import { CapabilityTypeRouterModule } from './capabilityTypeRouter.module';
+import { WineryReadmeModule } from '../../wineryReadmeModule/wineryReadme.module';
+import { WineryLicenseModule } from '../../wineryLicenseModule/wineryLicense.module';
+import { ValidSourceTypesModule } from '../../instance/capabilityTypes/validSourceTypes/validSourceTypes.module';
 
 @NgModule({
     imports: [
         CommonModule,
         CapabilityTypeRouterModule,
         WineryReadmeModule,
-        WineryLicenseModule
+        WineryLicenseModule,
+        ValidSourceTypesModule
     ],
 })
 export class CapabilityTypeModule {
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryMainModules/capabilityTypes/capabilityTypeRouter.module.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryMainModules/capabilityTypes/capabilityTypeRouter.module.ts
index f47465ef2..38e420a4b 100644
--- a/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryMainModules/capabilityTypes/capabilityTypeRouter.module.ts
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryMainModules/capabilityTypes/capabilityTypeRouter.module.ts
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ * Copyright (c) 2017-2019 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -12,37 +12,39 @@
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  *******************************************************************************/
 
-import {NgModule} from '@angular/core';
-import {RouterModule, Routes} from '@angular/router';
-import {SectionComponent} from '../../section/section.component';
-import {SectionResolver} from '../../section/section.resolver';
-import {InstanceComponent} from '../../instance/instance.component';
-import {InstanceResolver} from '../../instance/instance.resolver';
-import {EditXMLComponent} from '../../instance/sharedComponents/editXML/editXML.component';
-import {DocumentationComponent} from '../../instance/sharedComponents/documentation/documentation.component';
-import {ToscaTypes} from '../../model/enums';
-import {InheritanceComponent} from '../../instance/sharedComponents/inheritance/inheritance.component';
-import {PropertiesDefinitionComponent} from '../../instance/sharedComponents/propertiesDefinition/propertiesDefinition.component';
-import {WineryReadmeComponent} from '../../wineryReadmeModule/wineryReadme.component';
-import {WineryLicenseComponent} from '../../wineryLicenseModule/wineryLicense.component';
+import { NgModule } from '@angular/core';
+import { RouterModule, Routes } from '@angular/router';
+import { SectionComponent } from '../../section/section.component';
+import { SectionResolver } from '../../section/section.resolver';
+import { InstanceComponent } from '../../instance/instance.component';
+import { InstanceResolver } from '../../instance/instance.resolver';
+import { EditXMLComponent } from '../../instance/sharedComponents/editXML/editXML.component';
+import { DocumentationComponent } from '../../instance/sharedComponents/documentation/documentation.component';
+import { ToscaTypes } from '../../model/enums';
+import { InheritanceComponent } from '../../instance/sharedComponents/inheritance/inheritance.component';
+import { PropertiesDefinitionComponent } from '../../instance/sharedComponents/propertiesDefinition/propertiesDefinition.component';
+import { WineryReadmeComponent } from '../../wineryReadmeModule/wineryReadme.component';
+import { WineryLicenseComponent } from '../../wineryLicenseModule/wineryLicense.component';
+import { ValidSourceTypesComponent } from '../../instance/capabilityTypes/validSourceTypes/validSourceTypes.component';
 
 const toscaType = ToscaTypes.CapabilityType;
 
 const capabilityTypeRoutes: Routes = [
-    {path: toscaType, component: SectionComponent, resolve: {resolveData: SectionResolver}},
-    {path: toscaType + '/:namespace', component: SectionComponent, resolve: {resolveData: SectionResolver}},
+    { path: toscaType, component: SectionComponent, resolve: { resolveData: SectionResolver } },
+    { path: toscaType + '/:namespace', component: SectionComponent, resolve: { resolveData: SectionResolver } },
     {
         path: toscaType + '/:namespace/:localName',
         component: InstanceComponent,
-        resolve: {resolveData: InstanceResolver},
+        resolve: { resolveData: InstanceResolver },
         children: [
-            {path: 'readme', component: WineryReadmeComponent},
-            {path: 'license', component: WineryLicenseComponent},
-            {path: 'propertiesdefinition', component: PropertiesDefinitionComponent},
-            {path: 'inheritance', component: InheritanceComponent},
-            {path: 'documentation', component: DocumentationComponent},
-            {path: 'xml', component: EditXMLComponent},
-            {path: '', redirectTo: 'readme', pathMatch: 'full'}
+            { path: 'readme', component: WineryReadmeComponent },
+            { path: 'license', component: WineryLicenseComponent },
+            { path: 'propertiesdefinition', component: PropertiesDefinitionComponent },
+            { path: 'inheritance', component: InheritanceComponent },
+            { path: 'constraints', component: ValidSourceTypesComponent },
+            { path: 'documentation', component: DocumentationComponent },
+            { path: 'xml', component: EditXMLComponent },
+            { path: '', redirectTo: 'readme', pathMatch: 'full' }
         ]
     }
 ];
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryMainModules/nodeTypes/nodeType.module.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryMainModules/nodeTypes/nodeType.module.ts
index 94720e32d..c7c6c9778 100644
--- a/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryMainModules/nodeTypes/nodeType.module.ts
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryMainModules/nodeTypes/nodeType.module.ts
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2017-2018 Contributors to the Eclipse Foundation
+ * Copyright (c) 2017-2019 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -31,6 +31,7 @@ import { InheritanceModule } from '../../instance/sharedComponents/inheritance/i
 import { WineryReadmeModule } from '../../wineryReadmeModule/wineryReadme.module';
 import { WineryLicenseModule } from '../../wineryLicenseModule/wineryLicense.module';
 import { TagModule } from '../../instance/sharedComponents/tag/tag.module';
+import { YamlRequirementDefinitionsModule } from '../../instance/nodeTypes/yamlRequirementDefinitions/yamlRequirementDefinitions.module';
 
 @NgModule({
     imports: [
@@ -51,7 +52,8 @@ import { TagModule } from '../../instance/sharedComponents/tag/tag.module';
         WineryEditorModule,
         NodeTypeRouterModule,
         WineryReadmeModule,
-        WineryLicenseModule
+        WineryLicenseModule,
+        YamlRequirementDefinitionsModule
     ],
     exports: [],
     declarations: [CapOrReqDefComponent],
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryMainModules/nodeTypes/nodeTypeRouter.module.ts b/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryMainModules/nodeTypes/nodeTypeRouter.module.ts
index 6aea48280..baea072f6 100644
--- a/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryMainModules/nodeTypes/nodeTypeRouter.module.ts
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/app/wineryMainModules/nodeTypes/nodeTypeRouter.module.ts
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2017-2018 Contributors to the Eclipse Foundation
+ * Copyright (c) 2017-2019 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -30,6 +30,7 @@ import { CapOrReqDefComponent } from '../../instance/nodeTypes/capabilityOrRequi
 import { WineryReadmeComponent } from '../../wineryReadmeModule/wineryReadme.component';
 import { WineryLicenseComponent } from '../../wineryLicenseModule/wineryLicense.component';
 import { TagComponent } from '../../instance/sharedComponents/tag/tag.component';
+import { YamlRequirementDefinitionsComponent } from '../../instance/nodeTypes/yamlRequirementDefinitions/yamlRequirementDefinitions.component';
 
 const toscaType = ToscaTypes.NodeType;
 
@@ -48,6 +49,7 @@ const nodeTypeRoutes: Routes = [
             { path: 'interfaces', component: InterfacesComponent },
             { path: 'implementations', component: ImplementationsComponent },
             { path: 'tags', component: TagComponent },
+            { path: 'requirementdefinitionsyaml', component: YamlRequirementDefinitionsComponent },
             { path: 'requirementdefinitions', component: CapOrReqDefComponent },
             { path: 'capabilitydefinitions', component: CapOrReqDefComponent },
             { path: 'propertiesdefinition', component: PropertiesDefinitionComponent },
diff --git a/org.eclipse.winery.frontends/app/tosca-management/src/css/wineryRepository.css b/org.eclipse.winery.frontends/app/tosca-management/src/css/wineryRepository.css
index b1fb15f69..e4c0ac6e2 100644
--- a/org.eclipse.winery.frontends/app/tosca-management/src/css/wineryRepository.css
+++ b/org.eclipse.winery.frontends/app/tosca-management/src/css/wineryRepository.css
@@ -22,6 +22,18 @@
     cursor: pointer;
 }
 
+#reqdef-table tr td:nth-of-type(2) { /* Select the 2nd td */
+    cursor: pointer;
+}
+
+#reqdef-table tr td:nth-of-type(3) { /* Select the 3rd td */
+    cursor: pointer;
+}
+
+#reqdef-table tr td:nth-of-type(4) { /* Select the 4th td */
+    cursor: pointer;
+}
+
 .hidden {
     display: none;
 }
@@ -1312,3 +1324,11 @@ div.policiesContainer > div.content > div.policy > textarea.policy_xml {
 .active-row {
     background-color: #ccc !important;
 }
+
+.left-margin-10 {
+    margin-left: 10px;
+}
+
+.right-margin-10 {
+    margin-right: 10px;
+}
diff --git a/org.eclipse.winery.highlevelrestapi/src/main/java/org/eclipse/winery/highlevelrestapi/HttpResponseMessage.java b/org.eclipse.winery.highlevelrestapi/src/main/java/org/eclipse/winery/highlevelrestapi/HttpResponseMessage.java
index b5fe1af70..b52b50791 100644
--- a/org.eclipse.winery.highlevelrestapi/src/main/java/org/eclipse/winery/highlevelrestapi/HttpResponseMessage.java
+++ b/org.eclipse.winery.highlevelrestapi/src/main/java/org/eclipse/winery/highlevelrestapi/HttpResponseMessage.java
@@ -14,13 +14,13 @@
 package org.eclipse.winery.highlevelrestapi;
 
 /**
+ *
  */
 public class HttpResponseMessage {
 
     private int statusCode;
     private String responseBody;
 
-
     /**
      * @return the statusCode
      */
@@ -48,5 +48,4 @@ public String getResponseBody() {
     protected void setResponseBody(String responseBody) {
         this.responseBody = responseBody;
     }
-
 }
diff --git a/org.eclipse.winery.highlevelrestapi/src/main/java/org/eclipse/winery/highlevelrestapi/LowLevelRestApi.java b/org.eclipse.winery.highlevelrestapi/src/main/java/org/eclipse/winery/highlevelrestapi/LowLevelRestApi.java
index b21129ba8..1e751a819 100644
--- a/org.eclipse.winery.highlevelrestapi/src/main/java/org/eclipse/winery/highlevelrestapi/LowLevelRestApi.java
+++ b/org.eclipse.winery.highlevelrestapi/src/main/java/org/eclipse/winery/highlevelrestapi/LowLevelRestApi.java
@@ -17,22 +17,19 @@
 import org.apache.commons.httpclient.HttpMethod;
 
 /**
- * This static-class eases HTTP-method execution by self-managed fault-handling
- * and automated Response-information processing
+ * This static-class eases HTTP-method execution by self-managed fault-handling and automated Response-information
+ * processing
  */
 public class LowLevelRestApi {
 
     // Local HttpClient used for every communication (Singleton implementation)
     private static HttpClient httpClient = new HttpClient();
 
-
     /**
-     * Executes a passed HttpMethod (Method type is either PUT, POST, GET or
-     * DELETE) and returns a HttpResponseMessage
+     * Executes a passed HttpMethod (Method type is either PUT, POST, GET or DELETE) and returns a HttpResponseMessage
      *
      * @param method Method to execute
-     * @return HttpResponseMessage which contains all information about the
-     * execution
+     * @return HttpResponseMessage which contains all information about the execution
      */
     public static HttpResponseMessage executeHttpMethod(HttpMethod method) {
 
@@ -44,7 +41,6 @@ public static HttpResponseMessage executeHttpMethod(HttpMethod method) {
             // Execute Request
             LowLevelRestApi.httpClient.executeMethod(method);
             responseMessage = LowLevelRestApi.extractResponseInformation(method);
-
         } catch (Exception e) {
             e.printStackTrace();
         } finally {
@@ -73,7 +69,5 @@ private static HttpResponseMessage extractResponseInformation(HttpMethod method)
             e.printStackTrace();
         }
         return responseMessage;
-
     }
-
 }
diff --git a/org.eclipse.winery.model.tosca.yaml/src/main/java/org/eclipse/winery/model/tosca/yaml/TNodeTemplate.java b/org.eclipse.winery.model.tosca.yaml/src/main/java/org/eclipse/winery/model/tosca/yaml/TNodeTemplate.java
index 19b443743..56427d4fa 100644
--- a/org.eclipse.winery.model.tosca.yaml/src/main/java/org/eclipse/winery/model/tosca/yaml/TNodeTemplate.java
+++ b/org.eclipse.winery.model.tosca.yaml/src/main/java/org/eclipse/winery/model/tosca/yaml/TNodeTemplate.java
@@ -13,8 +13,19 @@
  *******************************************************************************/
 package org.eclipse.winery.model.tosca.yaml;
 
-import org.eclipse.jdt.annotation.NonNull;
-import org.eclipse.jdt.annotation.Nullable;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlAttribute;
+import javax.xml.bind.annotation.XmlType;
+import javax.xml.namespace.QName;
+
 import org.eclipse.winery.model.tosca.yaml.support.Metadata;
 import org.eclipse.winery.model.tosca.yaml.support.TMapRequirementAssignment;
 import org.eclipse.winery.model.tosca.yaml.visitor.AbstractParameter;
@@ -22,12 +33,8 @@
 import org.eclipse.winery.model.tosca.yaml.visitor.IVisitor;
 import org.eclipse.winery.model.tosca.yaml.visitor.VisitorNode;
 
-import javax.xml.bind.annotation.XmlAccessType;
-import javax.xml.bind.annotation.XmlAccessorType;
-import javax.xml.bind.annotation.XmlAttribute;
-import javax.xml.bind.annotation.XmlType;
-import javax.xml.namespace.QName;
-import java.util.*;
+import org.eclipse.jdt.annotation.NonNull;
+import org.eclipse.jdt.annotation.Nullable;
 
 @XmlAccessorType(XmlAccessType.FIELD)
 @XmlType(name = "tNodeTemplate", namespace = " http://docs.oasis-open.org/tosca/ns/simple/yaml/1.0", propOrder = {
@@ -289,7 +296,9 @@ public Builder setDescription(String description) {
         }
 
         public Builder setMetadata(Metadata metadata) {
-            this.metadata = metadata;
+            if (Objects.nonNull(metadata) && !metadata.isEmpty()) {
+                this.metadata = metadata;
+            }
             return this;
         }
 
diff --git a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/Definitions.java b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/Definitions.java
index 83c500dfa..c32523ab1 100644
--- a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/Definitions.java
+++ b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/Definitions.java
@@ -8,7 +8,6 @@
  * terms of the Eclipse Public License 2.0 which is available at
  * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
  * which is available at https://www.apache.org/licenses/LICENSE-2.0.
- *
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  *******************************************************************************/
 
diff --git a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TCapability.java b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TCapability.java
index 00214d4cc..5f67530bf 100644
--- a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TCapability.java
+++ b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TCapability.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2013-2018 Contributors to the Eclipse Foundation
+ * Copyright (c) 2013-2019 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
diff --git a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TCapabilityDefinition.java b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TCapabilityDefinition.java
index 7f103d79a..aebf6b099 100644
--- a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TCapabilityDefinition.java
+++ b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TCapabilityDefinition.java
@@ -46,6 +46,8 @@
     protected Integer lowerBound;
     @XmlAttribute(name = "upperBound")
     protected String upperBound;
+    @XmlAttribute(name = "validSourceTypes")
+    protected List<QName> validSourceTypes;
 
     public TCapabilityDefinition() {
     }
@@ -57,6 +59,7 @@ public TCapabilityDefinition(Builder builder) {
         this.capabilityType = builder.capabilityType;
         this.lowerBound = builder.lowerBound;
         this.upperBound = builder.upperBound;
+        this.validSourceTypes = builder.validSourceTypes;
     }
 
     @Override
@@ -68,12 +71,13 @@ public boolean equals(Object o) {
             Objects.equals(name, that.name) &&
             Objects.equals(capabilityType, that.capabilityType) &&
             Objects.equals(lowerBound, that.lowerBound) &&
-            Objects.equals(upperBound, that.upperBound);
+            Objects.equals(upperBound, that.upperBound) &&
+            Objects.equals(validSourceTypes, that.validSourceTypes);
     }
 
     @Override
     public int hashCode() {
-        return Objects.hash(constraints, name, capabilityType, lowerBound, upperBound);
+        return Objects.hash(constraints, name, capabilityType, lowerBound, upperBound, validSourceTypes);
     }
 
     public TCapabilityDefinition.@Nullable Constraints getConstraints() {
@@ -129,6 +133,14 @@ public void setUpperBound(@Nullable String value) {
         this.upperBound = value;
     }
 
+    public List<QName> getValidSourceTypes() {
+        return validSourceTypes;
+    }
+
+    public void setValidSourceTypes(List<QName> value) {
+        this.validSourceTypes = value;
+    }
+
     @Override
     public void accept(Visitor visitor) {
         visitor.visit(this);
@@ -173,6 +185,8 @@ public int hashCode() {
         private Integer lowerBound;
         private String upperBound;
 
+        private List<QName> validSourceTypes;
+
         public Builder(String name, QName capabilityType) {
             this.name = name;
             this.capabilityType = capabilityType;
@@ -193,6 +207,11 @@ public Builder setUpperBound(String upperBound) {
             return this;
         }
 
+        public Builder setValidSourceTypes(List<QName> validSourceTypes) {
+            this.validSourceTypes = validSourceTypes;
+            return this;
+        }
+
         public Builder addConstraints(TCapabilityDefinition.Constraints constraints) {
             if (constraints == null || constraints.getConstraint().isEmpty()) {
                 return this;
diff --git a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TCapabilityType.java b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TCapabilityType.java
index edcdf0173..b812a471c 100644
--- a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TCapabilityType.java
+++ b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TCapabilityType.java
@@ -14,20 +14,37 @@
 
 package org.eclipse.winery.model.tosca;
 
+import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlType;
+import javax.xml.namespace.QName;
 
 import org.eclipse.winery.model.tosca.visitor.Visitor;
 
 @XmlAccessorType(XmlAccessType.FIELD)
 @XmlType(name = "tCapabilityType")
 public class TCapabilityType extends TEntityType {
+    // this is added here to support the YAML model
+    // cannot be annotated as transient. Reason: org.eclipse.winery.repository.backend.BackendUtils.persist(
+    // java.lang.Object, org.eclipse.winery.common.RepositoryFileReference, org.apache.tika.mime.MediaType)
+    private List<QName> validNodeTypes;
+
     public TCapabilityType() {
     }
 
     public TCapabilityType(Builder builder) {
         super(builder);
+        this.validNodeTypes = builder.validSourceTypes;
+    }
+
+    public List<QName> getValidNodeTypes() {
+        return validNodeTypes;
+    }
+
+    public void setValidNodeTypes(List<QName> validNodeTypes) {
+        this.validNodeTypes = validNodeTypes;
     }
 
     @Override
@@ -36,12 +53,20 @@ public void accept(Visitor visitor) {
     }
 
     public static class Builder extends TEntityType.Builder<Builder> {
+        private List<QName> validSourceTypes;
+
         public Builder(String name) {
             super(name);
         }
 
-        public Builder(TEntityType entityType) {
+        public Builder(TCapabilityType entityType) {
             super(entityType);
+            this.validSourceTypes = entityType.validNodeTypes;
+        }
+
+        public Builder setValidSourceTypes(List<QName> validSourceTypes) {
+            this.validSourceTypes = validSourceTypes;
+            return self();
         }
 
         @Override
diff --git a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TEntityTemplate.java b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TEntityTemplate.java
index a6fac302e..76ad26439 100644
--- a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TEntityTemplate.java
+++ b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TEntityTemplate.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2013-2018 Contributors to the Eclipse Foundation
+ * Copyright (c) 2013-2019 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -74,7 +74,8 @@
     @XmlElement(name = "PropertyConstraints")
     protected TEntityTemplate.PropertyConstraints propertyConstraints;
 
-    @XmlAttribute(name = "type", required = true)
+    // allow empty types to support YAML capability assignments
+    @XmlAttribute(name = "type")
     protected QName type;
 
     public TEntityTemplate() {
@@ -123,8 +124,7 @@ public void setProperties(TEntityTemplate.Properties value) {
     public void setPropertyConstraints(TEntityTemplate.@Nullable PropertyConstraints value) {
         this.propertyConstraints = value;
     }
-
-    @NonNull
+    
     public QName getType() {
         return type;
     }
diff --git a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TExtensibleElements.java b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TExtensibleElements.java
index 5591230cd..75a5adff8 100644
--- a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TExtensibleElements.java
+++ b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TExtensibleElements.java
@@ -69,7 +69,7 @@
 
     @XmlAnyAttribute
     @NonNull
-    private Map<QName, String> otherAttributes = new HashMap<QName, String>();
+    private Map<QName, String> otherAttributes = new HashMap<>();
 
     public TExtensibleElements() {
     }
diff --git a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TImport.java b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TImport.java
index c6d5ad190..1b03e1c3d 100644
--- a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TImport.java
+++ b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TImport.java
@@ -8,7 +8,6 @@
  * terms of the Eclipse Public License 2.0 which is available at
  * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
  * which is available at https://www.apache.org/licenses/LICENSE-2.0.
- *
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  *******************************************************************************/
 
diff --git a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TNodeTemplate.java b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TNodeTemplate.java
index a1d11fcd9..e9ed6219e 100644
--- a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TNodeTemplate.java
+++ b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TNodeTemplate.java
@@ -83,6 +83,11 @@ public TNodeTemplate(Builder builder) {
         this.name = builder.name;
         this.minInstances = builder.minInstances;
         this.maxInstances = builder.maxInstances;
+
+        if (Objects.nonNull(builder.x) && Objects.nonNull(builder.y)) {
+            this.setX(builder.x);
+            this.setY(builder.y);
+        }
     }
 
     @Override
@@ -322,6 +327,8 @@ public void accept(Visitor visitor) {
         private String name;
         private Integer minInstances;
         private String maxInstances;
+        private String x;
+        private String y;
 
         public Builder(String id, QName type) {
             super(id, type);
@@ -366,6 +373,16 @@ public Builder setMaxInstances(String maxInstances) {
             return this;
         }
 
+        public Builder setX(String x) {
+            this.x = x;
+            return this;
+        }
+
+        public Builder setY(String y) {
+            this.y = y;
+            return this;
+        }
+
         public Builder addRequirements(TNodeTemplate.Requirements requirements) {
             if (requirements == null || requirements.getRequirement().isEmpty()) {
                 return this;
diff --git a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TNodeTypeImplementation.java b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TNodeTypeImplementation.java
index ce8852f1f..459f04a4b 100644
--- a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TNodeTypeImplementation.java
+++ b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TNodeTypeImplementation.java
@@ -91,6 +91,7 @@ public TNodeTypeImplementation(Builder builder) {
         super(builder);
         this.derivedFrom = builder.derivedFrom;
         this.deploymentArtifacts = builder.deploymentArtifacts;
+        this.implementationArtifacts = builder.implementationArtifacts;
     }
 
     @Override
diff --git a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TRelationshipTypeImplementation.java b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TRelationshipTypeImplementation.java
index a11e0f82d..9d3dd3871 100644
--- a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TRelationshipTypeImplementation.java
+++ b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TRelationshipTypeImplementation.java
@@ -137,6 +137,10 @@ public Builder(Builder builder, String name, QName implementedType) {
             super(builder, name, implementedType);
         }
 
+        public Builder(String name, QName implementedRelationshipType) {
+            super(name, implementedRelationshipType);
+        }
+
         public Builder setDerivedFrom(DerivedFrom derivedFrom) {
             this.derivedFrom = derivedFrom;
             return this;
diff --git a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TRequirement.java b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TRequirement.java
index cc0acfd7b..8e0c3ef37 100644
--- a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TRequirement.java
+++ b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TRequirement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2013-2018 Contributors to the Eclipse Foundation
+ * Copyright (c) 2013-2019 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -14,18 +14,19 @@
 
 package org.eclipse.winery.model.tosca;
 
-import com.fasterxml.jackson.annotation.JsonTypeInfo;
-import org.eclipse.jdt.annotation.NonNull;
+import java.util.Objects;
 
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlAttribute;
 import javax.xml.bind.annotation.XmlType;
 import javax.xml.namespace.QName;
-import java.util.Objects;
 
 import org.eclipse.winery.model.tosca.visitor.Visitor;
 
+import com.fasterxml.jackson.annotation.JsonTypeInfo;
+import org.eclipse.jdt.annotation.NonNull;
+
 @XmlAccessorType(XmlAccessType.FIELD)
 @XmlType(name = "tRequirement")
 @JsonTypeInfo(
@@ -38,26 +39,41 @@
     @XmlAttribute(name = "name", required = true)
     protected String name;
 
+    @XmlAttribute(name = "capability")
+    protected String capability;
+
+    @XmlAttribute(name = "node")
+    protected String node;
+
+    @XmlAttribute(name = "relationship")
+    protected String relationship;
+
     public TRequirement() {
     }
 
     public TRequirement(Builder builder) {
         super(builder);
         this.name = builder.name;
+        this.capability = builder.capability;
+        this.node = builder.node;
+        this.relationship = builder.relationship;
     }
 
     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
-        if (!(o instanceof TRequirement)) return false;
+        if (o == null || getClass() != o.getClass()) return false;
         if (!super.equals(o)) return false;
         TRequirement that = (TRequirement) o;
-        return Objects.equals(name, that.name);
+        return name.equals(that.name) &&
+            Objects.equals(capability, that.capability) &&
+            Objects.equals(node, that.node) &&
+            Objects.equals(relationship, that.relationship);
     }
 
     @Override
     public int hashCode() {
-        return Objects.hash(super.hashCode(), name);
+        return Objects.hash(super.hashCode(), name, capability, node, relationship);
     }
 
     /**
@@ -79,6 +95,30 @@ public void setName(String value) {
         this.name = value;
     }
 
+    public String getCapability() {
+        return capability;
+    }
+
+    public void setCapability(String capability) {
+        this.capability = capability;
+    }
+
+    public String getNode() {
+        return node;
+    }
+
+    public void setNode(String node) {
+        this.node = node;
+    }
+
+    public String getRelationship() {
+        return relationship;
+    }
+
+    public void setRelationship(String relationship) {
+        this.relationship = relationship;
+    }
+
     @Override
     @NonNull
     public String getFakeJacksonType() {
@@ -91,6 +131,9 @@ public void accept(Visitor visitor) {
 
     public static class Builder extends RelationshipSourceOrTarget.Builder<Builder> {
         private final String name;
+        private String capability;
+        private String relationship;
+        private String node;
 
         public Builder(String id, QName type) {
             super(id, type);
@@ -102,6 +145,21 @@ public Builder(String id, String name, QName type) {
             this.name = name;
         }
 
+        public Builder setCapability(String capability) {
+            this.capability = capability;
+            return self();
+        }
+
+        public Builder setRelationship(String relationship) {
+            this.relationship = relationship;
+            return self();
+        }
+
+        public Builder setNode(String node) {
+            this.node = node;
+            return self();
+        }
+
         @Override
         public Builder self() {
             return this;
diff --git a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TRequirementDefinition.java b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TRequirementDefinition.java
index 1577b2c06..214ebf752 100644
--- a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TRequirementDefinition.java
+++ b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TRequirementDefinition.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2013-2018 Contributors to the Eclipse Foundation
+ * Copyright (c) 2013-2019 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -40,12 +40,19 @@
     protected TRequirementDefinition.Constraints constraints;
     @XmlAttribute(name = "name", required = true)
     protected String name;
-    @XmlAttribute(name = "requirementType", required = true)
+    @XmlAttribute(name = "requirementType")
     protected QName requirementType;
     @XmlAttribute(name = "lowerBound")
     protected Integer lowerBound;
     @XmlAttribute(name = "upperBound")
     protected String upperBound;
+    // the following attributes are introduced to support the YAML specs
+    @XmlAttribute(name = "capability")
+    private QName capability;
+    @XmlAttribute(name = "node")
+    private QName node;
+    @XmlAttribute(name = "relationship")
+    private QName relationship;
 
     public TRequirementDefinition() {
 
@@ -58,6 +65,9 @@ public TRequirementDefinition(Builder builder) {
         this.requirementType = builder.requirementType;
         this.lowerBound = builder.lowerBound;
         this.upperBound = builder.upperBound;
+        this.capability = builder.capability;
+        this.node = builder.node;
+        this.relationship = builder.relationship;
     }
 
     @Override
@@ -101,7 +111,7 @@ public void setName(@NonNull String value) {
         this.name = value;
     }
 
-    @NonNull
+    // removed the @NonNull annotation since this field is not present in YAML mode
     public QName getRequirementType() {
         return requirementType;
     }
@@ -137,6 +147,30 @@ public void setUpperBound(@Nullable String value) {
         this.upperBound = value;
     }
 
+    public QName getCapability() {
+        return capability;
+    }
+
+    public void setCapability(QName capability) {
+        this.capability = capability;
+    }
+
+    public QName getNode() {
+        return node;
+    }
+
+    public void setNode(QName node) {
+        this.node = node;
+    }
+
+    public QName getRelationship() {
+        return relationship;
+    }
+
+    public void setRelationship(QName relationship) {
+        this.relationship = relationship;
+    }
+
     @XmlAccessorType(XmlAccessType.FIELD)
     @XmlType(name = "", propOrder = {
         "constraint"
@@ -171,10 +205,19 @@ public int hashCode() {
     public static class Builder extends TExtensibleElements.Builder<Builder> {
         private final String name;
         private final QName requirementType;
-
         private Constraints constraints;
         private Integer lowerBound;
         private String upperBound;
+        private QName capability;
+        private QName node;
+        private QName relationship;
+
+        /**
+         * This constructor is used when in YAML mode.
+         */
+        public Builder(String name) {
+            this(name, null);
+        }
 
         public Builder(String name, QName requirementType) {
             this.name = name;
@@ -196,6 +239,21 @@ public Builder setUpperBound(String upperBound) {
             return this;
         }
 
+        public Builder setCapability(QName capability) {
+            this.capability = capability;
+            return self();
+        }
+
+        public Builder setNode(QName node) {
+            this.node = node;
+            return self();
+        }
+
+        public Builder setRelationship(QName relationship) {
+            this.relationship = relationship;
+            return self();
+        }
+
         public Builder addConstraints(TRequirementDefinition.Constraints constraints) {
             if (constraints == null || constraints.getConstraint().isEmpty()) {
                 return this;
diff --git a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TServiceTemplate.java b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TServiceTemplate.java
index 85345b58b..925261651 100644
--- a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TServiceTemplate.java
+++ b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TServiceTemplate.java
@@ -178,6 +178,11 @@ public void accept(Visitor visitor) {
         private String name;
         private String targetNamespace;
         private QName substitutableNodeType;
+        
+        public Builder(String id) {
+            super(id);
+            topologyTemplate = null;
+        }
 
         public Builder(String id, TTopologyTemplate topologyTemplate) {
             super(id);
diff --git a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TTopologyTemplate.java b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TTopologyTemplate.java
index 83c4bad3d..36ecb4e5b 100644
--- a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TTopologyTemplate.java
+++ b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/TTopologyTemplate.java
@@ -8,7 +8,6 @@
  * terms of the Eclipse Public License 2.0 which is available at
  * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
  * which is available at https://www.apache.org/licenses/LICENSE-2.0.
- *
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  *******************************************************************************/
 
diff --git a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/kvproperties/PropertyDefinitionKV.java b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/kvproperties/PropertyDefinitionKV.java
index fc83b1e4c..8ea61f566 100644
--- a/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/kvproperties/PropertyDefinitionKV.java
+++ b/org.eclipse.winery.model.tosca/src/main/java/org/eclipse/winery/model/tosca/kvproperties/PropertyDefinitionKV.java
@@ -18,12 +18,17 @@
 
 import javax.xml.bind.annotation.XmlRootElement;
 
+import com.fasterxml.jackson.annotation.JsonInclude;
+
 @XmlRootElement(name = "PropertyDefinition")
+@JsonInclude(JsonInclude.Include.NON_NULL)
 public class PropertyDefinitionKV implements Serializable {
 
     private String key;
     private String type;
-
+    private Boolean required;
+    private String defaultValue;
+    private String description;
 
     public PropertyDefinitionKV() {
         super();
@@ -35,6 +40,17 @@ public PropertyDefinitionKV(String key, String type) {
         this.setType(type);
     }
 
+    public PropertyDefinitionKV(String key, String type, Boolean required, String defaultValue) {
+        this(key, type);
+        this.setRequired(required);
+        this.setDefaultValue(defaultValue);
+    }
+
+    public PropertyDefinitionKV(String key, String type, Boolean required, String defaultValue, String description) {
+        this(key, type, required, defaultValue);
+        this.setDescription(description);
+    }
+
     public String getKey() {
         return this.key;
     }
@@ -57,17 +73,40 @@ public void setType(String type) {
         this.type = type;
     }
 
+    public Boolean isRequired() {
+        return required;
+    }
+
+    public void setRequired(Boolean required) {
+        this.required = required;
+    }
+
+    public String getDefaultValue() {
+        return defaultValue;
+    }
+
+    public void setDefaultValue(String defaultValue) {
+        this.defaultValue = defaultValue;
+    }
+
+    public String getDescription() {
+        return description;
+    }
+
+    public void setDescription(String description) {
+        this.description = description;
+    }
+
     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
         PropertyDefinitionKV that = (PropertyDefinitionKV) o;
-        return Objects.equals(key, that.key) &&
-            Objects.equals(type, that.type);
+        return Objects.equals(key, that.key);
     }
 
     @Override
-	public int hashCode() {
-		return this.key.hashCode();
-	}
+    public int hashCode() {
+        return this.key.hashCode();
+    }
 }
diff --git a/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/datatypes/select2/Select2DataWithOptGroups.java b/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/datatypes/select2/Select2DataWithOptGroups.java
index 22fa18b98..25dfb468b 100644
--- a/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/datatypes/select2/Select2DataWithOptGroups.java
+++ b/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/datatypes/select2/Select2DataWithOptGroups.java
@@ -24,7 +24,6 @@
 
     Map<String, Select2OptGroup> idx = new HashMap<>();
 
-
     /**
      * Add an item to a group
      *
@@ -58,6 +57,5 @@ public void add(String group, String id, String text) {
         }
 
         return res;
-
     }
 }
diff --git a/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/_support/AbstractComponentInstanceResource.java b/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/_support/AbstractComponentInstanceResource.java
index 269798a7a..a0c3ff3ab 100644
--- a/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/_support/AbstractComponentInstanceResource.java
+++ b/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/_support/AbstractComponentInstanceResource.java
@@ -134,7 +134,7 @@ public AbstractComponentInstanceResource(DefinitionsChildId id) {
             LOGGER.debug("data file exists");
             this.load();
         } else {
-            LOGGER.debug("Data file does not exist. Creating a new one.");
+            LOGGER.debug("Data file {} does not exist. Creating a new one.", this.ref.toString());
             this.createNew();
         }
     }
@@ -347,7 +347,8 @@ public Object getElementAsJson(@QueryParam("versions") @ApiParam("If set, a list
                 return BackendUtils.getDefinitionsHavingCorrectImports(repository, this.id);
             }
         } catch (Exception e) {
-            throw new WebApplicationException(e);
+            throw 
+                new WebApplicationException(e);
         }
     }
 
diff --git a/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/apiData/QNameApiData.java b/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/apiData/QNameApiData.java
index e21ca8a39..1088da662 100644
--- a/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/apiData/QNameApiData.java
+++ b/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/apiData/QNameApiData.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2017-2018 Contributors to the Eclipse Foundation
+ * Copyright (c) 2017-2019 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -15,6 +15,7 @@
 package org.eclipse.winery.repository.rest.resources.apiData;
 
 import javax.xml.bind.annotation.XmlRootElement;
+import javax.xml.namespace.QName;
 
 import org.eclipse.winery.common.ids.definitions.DefinitionsChildId;
 
@@ -30,4 +31,16 @@ public QNameApiData(DefinitionsChildId newId) {
         this.localname = newId.getXmlId().getDecoded();
         this.namespace = newId.getNamespace().getDecoded();
     }
+
+    public QName asQName() {
+        return new QName(namespace, localname);
+    }
+
+    public static QNameApiData fromQName(QName original) {
+        QNameApiData result = new QNameApiData();
+        result.localname = original.getLocalPart();
+        result.namespace = original.getNamespaceURI();
+
+        return result;
+    }
 }
diff --git a/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/apiData/RequirementOrCapabilityDefinitionPostData.java b/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/apiData/RequirementOrCapabilityDefinitionPostData.java
new file mode 100644
index 000000000..b84a0acbe
--- /dev/null
+++ b/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/apiData/RequirementOrCapabilityDefinitionPostData.java
@@ -0,0 +1,34 @@
+/*******************************************************************************
+ * Copyright (c) 2017-2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+
+package org.eclipse.winery.repository.rest.resources.apiData;
+
+import java.util.List;
+
+import javax.xml.namespace.QName;
+
+public class RequirementOrCapabilityDefinitionPostData {
+    public String name;
+    public String type;
+    public String upperBound;
+    public String lowerBound;
+    // the following fields support YAML mode
+    public String capability;
+    public String node;
+    public String relationship;
+    public List<QName> validSourceTypes;
+
+    RequirementOrCapabilityDefinitionPostData() {
+    }
+}
diff --git a/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/apiData/ValidSourceTypesApiData.java b/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/apiData/ValidSourceTypesApiData.java
new file mode 100644
index 000000000..5fac7d0e3
--- /dev/null
+++ b/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/apiData/ValidSourceTypesApiData.java
@@ -0,0 +1,62 @@
+/*******************************************************************************
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+
+package org.eclipse.winery.repository.rest.resources.apiData;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.stream.Collectors;
+
+import org.eclipse.winery.model.tosca.TCapabilityType;
+
+public class ValidSourceTypesApiData {
+    private List<QNameApiData> nodes;
+
+    public ValidSourceTypesApiData() {
+    }
+
+    public ValidSourceTypesApiData(TCapabilityType capabilityType) {
+        if (capabilityType.getValidNodeTypes() != null) {
+            this.nodes = capabilityType
+                .getValidNodeTypes()
+                .stream()
+                .map(QNameApiData::fromQName)
+                .collect(Collectors.toList());
+        } else {
+            this.nodes = new ArrayList<>();
+        }
+    }
+
+    public List<QNameApiData> getNodes() {
+        return nodes;
+    }
+
+    public void setNodes(List<QNameApiData> nodes) {
+        this.nodes = nodes;
+    }
+
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+        builder.append("ValidSourceTypesApiDataJson: { nodes: ");
+
+        if (nodes != null) {
+            nodes.forEach(node -> builder.append(String.format("\"%s\",", node)));
+            builder.replace(builder.lastIndexOf(","), builder.lastIndexOf(",") + 1, "}");
+        } else {
+            builder.append("null }");
+        }
+
+        return builder.toString();
+    }
+}
diff --git a/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/apiData/CapabilityDefinitionPostData.java b/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/apiData/YamlRequirementDefinitionApiData.java
similarity index 74%
rename from org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/apiData/CapabilityDefinitionPostData.java
rename to org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/apiData/YamlRequirementDefinitionApiData.java
index d59db68c5..86226a362 100644
--- a/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/apiData/CapabilityDefinitionPostData.java
+++ b/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/apiData/YamlRequirementDefinitionApiData.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2017-2018 Contributors to the Eclipse Foundation
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -14,12 +14,15 @@
 
 package org.eclipse.winery.repository.rest.resources.apiData;
 
-public class CapabilityDefinitionPostData {
+public class YamlRequirementDefinitionApiData {
     public String name;
-    public String type;
-    public String upperBound;
+    public QNameApiData capability;
+    public QNameApiData node;
+    public QNameApiData relationship;
     public String lowerBound;
+    public String upperBound;
 
-    CapabilityDefinitionPostData() {
+    public YamlRequirementDefinitionApiData() {
+        
     }
 }
diff --git a/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/entitytypes/capabilitytypes/CapabilityTypeResource.java b/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/entitytypes/capabilitytypes/CapabilityTypeResource.java
index 013954044..469d3d7c7 100644
--- a/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/entitytypes/capabilitytypes/CapabilityTypeResource.java
+++ b/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/entitytypes/capabilitytypes/CapabilityTypeResource.java
@@ -13,10 +13,21 @@
  *******************************************************************************/
 package org.eclipse.winery.repository.rest.resources.entitytypes.capabilitytypes;
 
+import java.util.stream.Collectors;
+
+import javax.ws.rs.GET;
+import javax.ws.rs.PUT;
+import javax.ws.rs.Path;
+import javax.ws.rs.core.Response;
+
 import org.eclipse.winery.common.ids.definitions.CapabilityTypeId;
 import org.eclipse.winery.model.tosca.TCapabilityType;
 import org.eclipse.winery.model.tosca.TExtensibleElements;
+import org.eclipse.winery.repository.rest.RestUtils;
+import org.eclipse.winery.repository.rest.resources.apiData.QNameApiData;
+import org.eclipse.winery.repository.rest.resources.apiData.ValidSourceTypesApiData;
 import org.eclipse.winery.repository.rest.resources.entitytypes.EntityTypeResource;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -24,7 +35,6 @@
 
     private static final Logger LOGGER = LoggerFactory.getLogger(CapabilityTypeResource.class);
 
-
     /**
      * Constructor has to be public because of test cases
      */
@@ -46,4 +56,22 @@ protected TExtensibleElements createNewElement() {
         return new TCapabilityType();
     }
 
+    @Path("constraints")
+    @GET
+    public ValidSourceTypesApiData getValidSourceTypes() {
+        return new ValidSourceTypesApiData(getCapabilityType());
+    }
+
+    @Path("constraints")
+    @PUT
+    public Response saveValidSourceTypes(ValidSourceTypesApiData newValidSourceTypes) {
+        TCapabilityType t = this.getCapabilityType();
+        t.setValidNodeTypes(newValidSourceTypes
+            .getNodes()
+            .stream()
+            .map(QNameApiData::asQName)
+            .collect(Collectors.toList()));
+
+        return RestUtils.persist(this);
+    }
 }
diff --git a/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/entitytypes/nodetypes/reqandcapdefs/AbstractReqOrCapDefResource.java b/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/entitytypes/nodetypes/reqandcapdefs/AbstractReqOrCapDefResource.java
index 4edb56f4d..47ff7a145 100644
--- a/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/entitytypes/nodetypes/reqandcapdefs/AbstractReqOrCapDefResource.java
+++ b/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/entitytypes/nodetypes/reqandcapdefs/AbstractReqOrCapDefResource.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2012-2013 Contributors to the Eclipse Foundation
+ * Copyright (c) 2012-2019 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -13,6 +13,18 @@
  *******************************************************************************/
 package org.eclipse.winery.repository.rest.resources.entitytypes.nodetypes.reqandcapdefs;
 
+import java.lang.reflect.Method;
+import java.util.List;
+
+import javax.ws.rs.FormParam;
+import javax.ws.rs.GET;
+import javax.ws.rs.PUT;
+import javax.ws.rs.Path;
+import javax.ws.rs.Produces;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response;
+import javax.xml.namespace.QName;
+
 import org.eclipse.winery.model.tosca.TCapabilityDefinition;
 import org.eclipse.winery.model.tosca.TConstraint;
 import org.eclipse.winery.model.tosca.TRequirementDefinition;
@@ -21,22 +33,15 @@
 import org.eclipse.winery.repository.rest.resources._support.collections.IIdDetermination;
 import org.eclipse.winery.repository.rest.resources._support.collections.withid.EntityWithIdResource;
 import org.eclipse.winery.repository.rest.resources.entitytypes.nodetypes.NodeTypeResource;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import javax.ws.rs.*;
-import javax.ws.rs.core.MediaType;
-import javax.ws.rs.core.Response;
-import javax.xml.namespace.QName;
-import java.lang.reflect.Method;
-import java.util.List;
-
 /**
  * Bundles common properties of TRequirementDefinition and TCapabilityDefinition
  * <p>
- * We agreed in the project not to modify org.eclipse.winery.model.tosca.
- * Therefore, this resource models the common properties of a
- * TRequirementDefinition and a TCapabilityDefinition
+ * We agreed in the project not to modify org.eclipse.winery.model.tosca. Therefore, this resource models the common
+ * properties of a TRequirementDefinition and a TCapabilityDefinition
  */
 public abstract class AbstractReqOrCapDefResource<ReqOrCapDef> extends EntityWithIdResource<ReqOrCapDef> implements IIdDetermination<ReqOrCapDef> {
 
@@ -45,15 +50,13 @@
     protected NodeTypeResource parent;
 
     // the capability or the requirement
-    private Object reqOrCapDef;
+    protected Object reqOrCapDef;
 
     private List<TConstraint> constraints;
 
-
     /**
-     * @param constraints additional parameter (in comparison to the constructor
-     *                    of EntityWithIdResource) as we require that sublist for the
-     *                    constrinats sub resource
+     * @param constraints additional parameter (in comparison to the constructor of EntityWithIdResource) as we require
+     *                    that sublist for the constrinats sub resource
      */
     public AbstractReqOrCapDefResource(IIdDetermination<ReqOrCapDef> idDetermination, ReqOrCapDef reqOrCapDef, int idx, List<ReqOrCapDef> list, NodeTypeResource res, List<TConstraint> constraints) {
         super(idDetermination, reqOrCapDef, idx, list, res);
@@ -159,9 +162,7 @@ public String getTypeAsString() {
     /**
      * required by the JSP.
      * <p>
-     * Therefore, we have two getters for the type: QName for the JSP and String
-     * for REST clients
+     * Therefore, we have two getters for the type: QName for the JSP and String for REST clients
      */
     public abstract QName getType();
-
 }
diff --git a/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/entitytypes/nodetypes/reqandcapdefs/RequirementDefinitionResource.java b/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/entitytypes/nodetypes/reqandcapdefs/RequirementDefinitionResource.java
index d1ee4c678..7a50d3297 100644
--- a/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/entitytypes/nodetypes/reqandcapdefs/RequirementDefinitionResource.java
+++ b/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/entitytypes/nodetypes/reqandcapdefs/RequirementDefinitionResource.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2012-2013 Contributors to the Eclipse Foundation
+ * Copyright (c) 2012-2019 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -13,6 +13,18 @@
  *******************************************************************************/
 package org.eclipse.winery.repository.rest.resources.entitytypes.nodetypes.reqandcapdefs;
 
+import java.util.List;
+
+import javax.ws.rs.Consumes;
+import javax.ws.rs.FormParam;
+import javax.ws.rs.GET;
+import javax.ws.rs.PUT;
+import javax.ws.rs.Path;
+import javax.ws.rs.Produces;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response;
+import javax.xml.namespace.QName;
+
 import org.eclipse.winery.model.tosca.TConstraint;
 import org.eclipse.winery.model.tosca.TRequirementDefinition;
 import org.eclipse.winery.model.tosca.TRequirementDefinition.Constraints;
@@ -20,47 +32,38 @@
 import org.eclipse.winery.repository.rest.resources._support.AbstractComponentInstanceResource;
 import org.eclipse.winery.repository.rest.resources._support.IPersistable;
 import org.eclipse.winery.repository.rest.resources._support.collections.IIdDetermination;
+import org.eclipse.winery.repository.rest.resources.apiData.QNameApiData;
 import org.eclipse.winery.repository.rest.resources.entitytypes.nodetypes.NodeTypeResource;
 
-import javax.ws.rs.FormParam;
-import javax.ws.rs.PUT;
-import javax.ws.rs.Path;
-import javax.ws.rs.core.Response;
-import javax.xml.namespace.QName;
-import java.util.List;
-
 public final class RequirementDefinitionResource extends AbstractReqOrCapDefResource<TRequirementDefinition> {
 
-    private TRequirementDefinition reqDef;
-
-
     /**
-     * Constructor has to follow the pattern of EnetityTResource as the
-     * constructor is invoked by reflection in EntityWithIdcollectionResource
+     * Constructor has to follow the pattern of EnetityTResource as the constructor is invoked by reflection in
+     * EntityWithIdcollectionResource
      *
-     * @param res the resource this req def is nested in. Has to be of Type
-     *            "NodeTypeResource". Due to the implementation of
-     *            org.eclipse.winery .repository.resources._support.collections.
-     *            withid.EntityWithIdCollectionResource
-     *            .getEntityResourceInstance(EntityT, int), we have to use
+     * @param res the resource this req def is nested in. Has to be of Type "NodeTypeResource". Due to the
+     *            implementation of org.eclipse.winery .repository.resources._support.collections.
+     *            withid.EntityWithIdCollectionResource .getEntityResourceInstance(EntityT, int), we have to use
      *            "AbstractComponentInstanceResource" as type
      */
     public RequirementDefinitionResource(IIdDetermination<TRequirementDefinition> idDetermination, TRequirementDefinition reqDef, int idx, List<TRequirementDefinition> list, AbstractComponentInstanceResource res) {
         super(idDetermination, reqDef, idx, list, (NodeTypeResource) res, RequirementDefinitionResource.getConstraints(reqDef));
-        this.reqDef = reqDef;
     }
 
     /**
-     * Quick fix to avoid internal server error when opening
-     * RequirementDefinitions Tab
+     * Quick fix to avoid internal server error when opening RequirementDefinitions Tab
      */
     public RequirementDefinitionResource(IIdDetermination<TRequirementDefinition> idDetermination, TRequirementDefinition reqDef, int idx, List<TRequirementDefinition> list, IPersistable res) {
         this(idDetermination, reqDef, idx, list, (AbstractComponentInstanceResource) res);
     }
 
+    public TRequirementDefinition getDefinition() {
+        return (TRequirementDefinition) this.reqOrCapDef;
+    }
+
     /**
-     * Fetch the list of constraints from the given definition. If the list does
-     * not exist, the list is created an stored in the given def
+     * Fetch the list of constraints from the given definition. If the list does not exist, the list is created an
+     * stored in the given def
      */
     public static List<TConstraint> getConstraints(TRequirementDefinition def) {
         Constraints constraints = def.getConstraints();
@@ -72,14 +75,14 @@ public RequirementDefinitionResource(IIdDetermination<TRequirementDefinition> id
     }
 
     public QName getType() {
-        return this.reqDef.getRequirementType();
+        return this.getDefinition().getRequirementType();
     }
 
     @PUT
     @Path("type")
     public Response setType(@FormParam(value = "type") String value) {
         QName qname = QName.valueOf(value);
-        this.reqDef.setRequirementType(qname);
+        this.getDefinition().setRequirementType(qname);
         return RestUtils.persist(this.parent);
     }
 
@@ -87,4 +90,53 @@ public Response setType(@FormParam(value = "type") String value) {
     public String getId(TRequirementDefinition e) {
         return e.getName();
     }
+
+    // The following methods support the YAML specs
+    @GET
+    @Path("capability")
+    @Produces(MediaType.APPLICATION_JSON)
+    public QNameApiData getCapability() {
+        return QNameApiData.fromQName(this.getDefinition().getCapability());
+    }
+
+    @PUT
+    @Path("capability")
+    @Consumes(MediaType.APPLICATION_JSON)
+    public Response setCapability(QNameApiData data) {
+        QName qName = data.asQName();
+        this.getDefinition().setCapability(qName);
+        return RestUtils.persist(this.parent);
+    }
+
+    @GET
+    @Path("node")
+    @Produces(MediaType.APPLICATION_JSON)
+    public QNameApiData getNode() {
+        return QNameApiData.fromQName(this.getDefinition().getNode());
+    }
+
+    @PUT
+    @Path("node")
+    @Consumes(MediaType.APPLICATION_JSON)
+    public Response setNode(QNameApiData data) {
+        QName qName = data.asQName();
+        this.getDefinition().setNode(qName);
+        return RestUtils.persist(this.parent);
+    }
+
+    @GET
+    @Path("relationship")
+    @Produces(MediaType.APPLICATION_JSON)
+    public QNameApiData getRelationship() {
+        return QNameApiData.fromQName(this.getDefinition().getRelationship());
+    }
+
+    @PUT
+    @Path("relationship")
+    @Consumes(MediaType.APPLICATION_JSON)
+    public Response setRelationship(QNameApiData data) {
+        QName qName = data.asQName();
+        this.getDefinition().setRelationship(qName);
+        return RestUtils.persist(this.parent);
+    }
 }
diff --git a/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/entitytypes/nodetypes/reqandcapdefs/RequirementDefinitionsResource.java b/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/entitytypes/nodetypes/reqandcapdefs/RequirementDefinitionsResource.java
index 7f6ead0fd..2c5d388c9 100644
--- a/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/entitytypes/nodetypes/reqandcapdefs/RequirementDefinitionsResource.java
+++ b/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/entitytypes/nodetypes/reqandcapdefs/RequirementDefinitionsResource.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2012-2017 Contributors to the Eclipse Foundation
+ * Copyright (c) 2012-2019 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -13,18 +13,24 @@
  *******************************************************************************/
 package org.eclipse.winery.repository.rest.resources.entitytypes.nodetypes.reqandcapdefs;
 
+import java.util.Collection;
+import java.util.List;
+import java.util.SortedSet;
+
+import javax.ws.rs.Path;
+import javax.ws.rs.PathParam;
+import javax.ws.rs.core.Response;
+import javax.xml.namespace.QName;
+
+import org.eclipse.winery.common.configuration.Environments;
 import org.eclipse.winery.common.ids.definitions.RequirementTypeId;
 import org.eclipse.winery.model.tosca.TRequirementDefinition;
 import org.eclipse.winery.repository.backend.BackendUtils;
 import org.eclipse.winery.repository.backend.RepositoryFactory;
+import org.eclipse.winery.repository.rest.resources.apiData.RequirementOrCapabilityDefinitionPostData;
 import org.eclipse.winery.repository.rest.resources.entitytypes.nodetypes.NodeTypeResource;
 
-import javax.ws.rs.Path;
-import javax.ws.rs.PathParam;
-import javax.xml.namespace.QName;
-import java.util.Collection;
-import java.util.List;
-import java.util.SortedSet;
+import org.apache.commons.lang3.StringUtils;
 
 public class RequirementDefinitionsResource extends RequirementOrCapabilityDefinitionsResource<RequirementDefinitionResource, TRequirementDefinition> {
 
@@ -43,4 +49,34 @@ public RequirementDefinitionsResource(NodeTypeResource res, List<TRequirementDef
     public RequirementDefinitionResource getEntityResource(@PathParam("id") String id) {
         return this.getEntityResourceFromEncodedId(id);
     }
+
+    @Override
+    public Response performPost(RequirementOrCapabilityDefinitionPostData postData) {
+        // if we are in XML mode, we delegate to the parent
+        if (!Environments.getUiConfig().getFeatures().get("yaml")) {
+            return super.performPost(postData);
+        }
+
+        // otherwise, we do it the YAML way!!
+        if (StringUtils.isEmpty(postData.name)) {
+            return Response.status(Response.Status.BAD_REQUEST).entity("Name has to be provided").build();
+        }
+
+        if (StringUtils.isEmpty(postData.capability)) {
+            return Response.status(Response.Status.BAD_REQUEST).entity("Capability Type has to be provided").build();
+        }
+
+        TRequirementDefinition def = super.createBasicReqOrCapDef(postData);
+        def.setCapability(QName.valueOf(postData.capability));
+
+        if (!StringUtils.isEmpty(postData.node)) {
+            def.setNode(QName.valueOf(postData.node));
+        }
+
+        if (!StringUtils.isEmpty(postData.relationship)) {
+            def.setRelationship(QName.valueOf(postData.relationship));
+        }
+
+        return super.persistDef(def, postData);
+    }
 }
diff --git a/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/entitytypes/nodetypes/reqandcapdefs/RequirementOrCapabilityDefinitionsResource.java b/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/entitytypes/nodetypes/reqandcapdefs/RequirementOrCapabilityDefinitionsResource.java
index d44d12c48..37a01fee1 100644
--- a/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/entitytypes/nodetypes/reqandcapdefs/RequirementOrCapabilityDefinitionsResource.java
+++ b/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/entitytypes/nodetypes/reqandcapdefs/RequirementOrCapabilityDefinitionsResource.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2012-2018 Contributors to the Eclipse Foundation
+ * Copyright (c) 2012-2019 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -27,15 +27,14 @@
 import org.eclipse.winery.model.tosca.TRequirementDefinition;
 import org.eclipse.winery.repository.rest.RestUtils;
 import org.eclipse.winery.repository.rest.resources._support.collections.withid.EntityWithIdCollectionResource;
-import org.eclipse.winery.repository.rest.resources.apiData.CapabilityDefinitionPostData;
+import org.eclipse.winery.repository.rest.resources.apiData.RequirementOrCapabilityDefinitionPostData;
 import org.eclipse.winery.repository.rest.resources.entitytypes.nodetypes.NodeTypeResource;
 
 import org.apache.commons.lang3.StringUtils;
 
 /**
- * This superclass has only a few methods as we cannot easily abstract from the
- * subclasses: We would need Java reflection to invoke "getName" (to get the
- * subresource). The hope is that this copy'n'paste programming will not
+ * This superclass has only a few methods as we cannot easily abstract from the subclasses: We would need Java
+ * reflection to invoke "getName" (to get the subresource). The hope is that this copy'n'paste programming will not
  * introduce bugs when changing childs
  * <p>
  * We try to abstract from the problems by using generics and reflections
@@ -47,7 +46,6 @@
 
     protected final NodeTypeResource res;
 
-
     public RequirementOrCapabilityDefinitionsResource(Class<ReqDefOrCapDefResource> entityResourceTClazz, Class<ReqDefOrCapDef> entityTClazz, List<ReqDefOrCapDef> list, NodeTypeResource res) {
         super(entityResourceTClazz, entityTClazz, list, res);
         this.res = res;
@@ -62,21 +60,38 @@ public RequirementOrCapabilityDefinitionsResource(Class<ReqDefOrCapDefResource>
     // As there is no supertype of TCapabilityType and TRequirementType containing the common attributes, we have to rely on unchecked casts
     @SuppressWarnings("unchecked")
     @Consumes(MediaType.APPLICATION_JSON)
-    public Response onPost(CapabilityDefinitionPostData postData) {
+    public Response onPost(RequirementOrCapabilityDefinitionPostData postData) {
+        return this.performPost(postData);
+    }
+
+    @Override
+    public String getId(ReqDefOrCapDef reqDefOrCapDef) {
+        return AbstractReqOrCapDefResource.getName(reqDefOrCapDef);
+    }
+
+    protected Response performPost(RequirementOrCapabilityDefinitionPostData postData) {
         if (StringUtils.isEmpty(postData.name)) {
             return Response.status(Status.BAD_REQUEST).entity("Name has to be provided").build();
         }
+
         if (StringUtils.isEmpty(postData.type)) {
             return Response.status(Status.BAD_REQUEST).entity("Type has to be provided").build();
         }
 
+        try {
+            ReqDefOrCapDef def = this.createBasicReqOrCapDef(postData);
+            this.handleDefType(def, postData);
+
+            return this.persistDef(def, postData);
+        } catch (NumberFormatException e) {
+            return Response.status(Status.BAD_REQUEST).entity("Bad format of lowerbound: " + e.getMessage()).build();
+        }
+    }
+
+    protected ReqDefOrCapDef createBasicReqOrCapDef(RequirementOrCapabilityDefinitionPostData postData) throws NumberFormatException {
         int lbound = 1;
         if (!StringUtils.isEmpty(postData.lowerBound)) {
-            try {
-                lbound = Integer.parseInt(postData.lowerBound);
-            } catch (NumberFormatException e) {
-                return Response.status(Status.BAD_REQUEST).entity("Bad format of lowerbound: " + e.getMessage()).build();
-            }
+            lbound = Integer.parseInt(postData.lowerBound);
         }
 
         String ubound = "1";
@@ -84,35 +99,52 @@ public Response onPost(CapabilityDefinitionPostData postData) {
             ubound = postData.upperBound;
         }
 
-        // we also support replacement of existing requirements
-        // therefore, we loop through the existing requirements
-        int idx = -1;
-        boolean found = false;
-        for (ReqDefOrCapDef d : this.list) {
-            idx++;
-            if (this.getId(d).equals(postData.name)) {
-                found = true;
-                break;
-            }
-        }
-
-        QName typeQName = QName.valueOf(postData.type);
         // Create object and put type in it
         ReqDefOrCapDef def;
+
         if (this instanceof CapabilityDefinitionsResource) {
             def = (ReqDefOrCapDef) new TCapabilityDefinition();
-            ((TCapabilityDefinition) def).setCapabilityType(typeQName);
         } else {
             assert (this instanceof RequirementDefinitionsResource);
             def = (ReqDefOrCapDef) new TRequirementDefinition();
-            ((TRequirementDefinition) def).setRequirementType(typeQName);
         }
 
-        // copy all other data into object
+        // copy all basic data into object
         AbstractReqOrCapDefResource.invokeSetter(def, "setName", postData.name);
         AbstractReqOrCapDefResource.invokeSetter(def, "setLowerBound", lbound);
         AbstractReqOrCapDefResource.invokeSetter(def, "setUpperBound", ubound);
 
+        return def;
+    }
+
+    protected void handleDefType(ReqDefOrCapDef def, RequirementOrCapabilityDefinitionPostData postData) {
+        QName typeQName = null;
+
+        if (postData.type != null) {
+            typeQName = QName.valueOf(postData.type);
+
+            if (def instanceof TCapabilityDefinition) {
+                ((TCapabilityDefinition) def).setCapabilityType(typeQName);
+                ((TCapabilityDefinition) def).setValidSourceTypes(postData.validSourceTypes);
+            } else {
+                ((TRequirementDefinition) def).setRequirementType(typeQName);
+            }
+        }
+    }
+
+    protected Response persistDef(ReqDefOrCapDef def, RequirementOrCapabilityDefinitionPostData postData) {
+        // we support replacement of existing requirements
+        // therefore, we loop through the existing requirements
+        int idx = -1;
+        boolean found = false;
+        for (ReqDefOrCapDef d : this.list) {
+            idx++;
+            if (this.getId(d).equals(postData.name)) {
+                found = true;
+                break;
+            }
+        }
+
         if (found) {
             // replace element
             this.list.set(idx, def);
@@ -123,9 +155,4 @@ public Response onPost(CapabilityDefinitionPostData postData) {
 
         return RestUtils.persist(this.res);
     }
-
-    @Override
-    public String getId(ReqDefOrCapDef reqDefOrCapDef) {
-        return AbstractReqOrCapDefResource.getName(reqDefOrCapDef);
-    }
 }
diff --git a/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/yaml/YAMLParserResource.java b/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/yaml/YAMLParserResource.java
index efa8f6fa2..bf5ffbcdf 100644
--- a/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/yaml/YAMLParserResource.java
+++ b/org.eclipse.winery.repository.rest/src/main/java/org/eclipse/winery/repository/rest/resources/yaml/YAMLParserResource.java
@@ -18,7 +18,6 @@
 import io.swagger.annotations.ApiOperation;
 import io.swagger.annotations.ApiParam;
 import org.apache.commons.lang3.StringEscapeUtils;
-import org.eclipse.winery.yaml.converter.Converter;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -31,13 +30,15 @@
 import javax.ws.rs.core.UriInfo;
 import java.io.InputStream;
 
+import org.eclipse.winery.yaml.converter.Converter;
+
 public class YAMLParserResource {
     public final static Logger LOGGER = LoggerFactory.getLogger(YAMLParserResource.class);
 
     @POST
     @ApiOperation(value = "Imports the given zipped YAML files")
     @Consumes(MediaType.MULTIPART_FORM_DATA)
-    @Produces(MediaType.TEXT_PLAIN)
+    @Produces(MediaType.TEXT_PLAIN) 
     public Response importYAML(
         @FormDataParam("file") InputStream uploadInputStream,
         @FormDataParam("file") FormDataContentDisposition fileDetail,
@@ -45,11 +46,11 @@ public Response importYAML(
         @Context UriInfo uriInfo
     ) {
         LOGGER.debug("File {}", fileDetail);
-        Converter converter = new Converter();
+        Converter converter = new Converter();     
         try {
             converter.convertY2X(uploadInputStream);
         } catch (Exception e) {
-
+    
             return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(
                 StringEscapeUtils.escapeHtml4(e.getMessage().trim())
             ).type("text/plain").build();
diff --git a/org.eclipse.winery.repository/pom.xml b/org.eclipse.winery.repository/pom.xml
index 079a5ef30..da0c9e04f 100644
--- a/org.eclipse.winery.repository/pom.xml
+++ b/org.eclipse.winery.repository/pom.xml
@@ -28,6 +28,11 @@
         <main.basedir>${project.parent.basedir}</main.basedir>
     </properties>
     <dependencies>
+<!--        <dependency>-->
+<!--            <groupId>org.eclipse.winery</groupId>-->
+<!--            <artifactId>org.eclipse.winery.yaml.converter</artifactId>-->
+<!--            <version>2.0.0-SNAPSHOT</version>-->
+<!--        </dependency>-->
         <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-api</artifactId>
@@ -229,6 +234,24 @@
             <artifactId>org.eclipse.winery.accountability</artifactId>
             <version>2.0.0-SNAPSHOT</version>
         </dependency>
+        <dependency>
+            <groupId>org.eclipse.winery</groupId>
+            <artifactId>org.eclipse.winery.model.tosca.yaml</artifactId>
+            <version>2.0.0-SNAPSHOT</version>
+            <scope>compile</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.yaml</groupId>
+            <artifactId>snakeyaml</artifactId>
+            <version>1.17</version>
+            <scope>compile</scope>
+        </dependency>
+        <dependency>
+            <groupId>commons-codec</groupId>
+            <artifactId>commons-codec</artifactId>
+            <version>1.11</version>
+            <scope>compile</scope>
+        </dependency>
     </dependencies>
     <build>
         <resources>
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/JAXBSupport.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/JAXBSupport.java
index ad36844aa..adabd6b02 100644
--- a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/JAXBSupport.java
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/JAXBSupport.java
@@ -95,8 +95,6 @@ private static JAXBContext initContext() {
                 MockXMLElement.class);
             // @formatter:on
         } catch (JAXBException e) {
-            System.out.println("HALLO");
-            System.out.println(e);
             LOGGER.error("Could not initialize JAXBContext", e);
             throw new IllegalStateException(e);
         }
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/TestWithGitBackedRepository.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/TestWithGitBackedRepository.java
index 33aed6381..02c7b47e0 100644
--- a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/TestWithGitBackedRepository.java
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/TestWithGitBackedRepository.java
@@ -17,14 +17,15 @@
 import java.nio.file.Path;
 import java.nio.file.Paths;
 
+import org.eclipse.winery.common.configuration.FileBasedRepositoryConfiguration;
+import org.eclipse.winery.common.configuration.GitBasedRepositoryConfiguration;
+import org.eclipse.winery.common.configuration.RepositoryConfigurationObject;
 import org.eclipse.winery.common.ids.definitions.NodeTypeId;
 import org.eclipse.winery.model.tosca.TNodeType;
 import org.eclipse.winery.model.tosca.TTopologyElementInstanceStates;
 import org.eclipse.winery.repository.backend.BackendUtils;
 import org.eclipse.winery.repository.backend.IRepository;
 import org.eclipse.winery.repository.backend.RepositoryFactory;
-import org.eclipse.winery.common.configuration.FileBasedRepositoryConfiguration;
-import org.eclipse.winery.common.configuration.GitBasedRepositoryConfiguration;
 
 import org.eclipse.jgit.api.Git;
 import org.eclipse.jgit.api.ResetCommand;
@@ -82,6 +83,7 @@ public TestWithGitBackedRepository() {
 
             // inject the current path to the repository factory
             FileBasedRepositoryConfiguration fileBasedRepositoryConfiguration = new FileBasedRepositoryConfiguration(repositoryPath);
+            fileBasedRepositoryConfiguration.setRepositoryProvider(RepositoryConfigurationObject.RepositoryProvider.FILE);
             GitBasedRepositoryConfiguration gitBasedRepositoryConfiguration = new GitBasedRepositoryConfiguration(false, fileBasedRepositoryConfiguration);
             RepositoryFactory.reconfigure(gitBasedRepositoryConfiguration);
 
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/AbstractRepository.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/AbstractRepository.java
index c3d1acdd9..509555297 100644
--- a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/AbstractRepository.java
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/AbstractRepository.java
@@ -18,14 +18,11 @@
 import java.io.InputStream;
 import java.util.Date;
 
-import javax.xml.bind.Unmarshaller;
-
 import org.eclipse.winery.common.Constants;
 import org.eclipse.winery.common.RepositoryFileReference;
 import org.eclipse.winery.common.ids.GenericId;
 import org.eclipse.winery.common.ids.definitions.DefinitionsChildId;
 import org.eclipse.winery.model.tosca.Definitions;
-import org.eclipse.winery.repository.JAXBSupport;
 
 import org.apache.commons.configuration2.Configuration;
 import org.apache.commons.io.IOUtils;
@@ -90,7 +87,7 @@ public String getMimeType(RepositoryFileReference ref) throws IOException {
      * @param ref       the file reference
      * @param mediaType the mimeType
      */
-    protected void setMimeType(RepositoryFileReference ref, MediaType mediaType) throws IOException {
+    public void setMimeType(RepositoryFileReference ref, MediaType mediaType) throws IOException {
         RepositoryFileReference mimeFileRef = this.getMimeFileRef(ref);
         this.putContentToFile(mimeFileRef, mediaType.toString(), null);
     }
@@ -114,9 +111,12 @@ public Definitions getDefinitions(DefinitionsChildId id) {
             return BackendUtils.createWrapperDefinitionsAndInitialEmptyElement(this, id);
         }
         try {
-            InputStream is = this.newInputStream(ref);
-            Unmarshaller u = JAXBSupport.createUnmarshaller();
-            return (Definitions) u.unmarshal(is);
+            Definitions output = this.definitionsFromRef(ref);
+            if (output != null) {
+                return output;
+            } else {
+                return BackendUtils.createWrapperDefinitionsAndInitialEmptyElement(this, id);
+            }
         } catch (Exception e) {
             LOGGER.error("Could not read content from file {}", ref, e);
             throw new IllegalStateException(e);
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/BackendUtils.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/BackendUtils.java
index 34a53c0c8..09cf52384 100644
--- a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/BackendUtils.java
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/BackendUtils.java
@@ -348,9 +348,17 @@ public static String getFilenameAndSubDirectory(RepositoryFileReference ref) {
      * @return the reference
      */
     public static RepositoryFileReference getRefOfDefinitions(DefinitionsChildId id) {
-        String name = Util.getTypeForComponentId(id.getClass());
+        return new RepositoryFileReference(id, getFileNameOfDefinitions(id));
+    }
+    
+    public static String getFileNameOfDefinitions(DefinitionsChildId id) {
+        return getFileNameOfDefinitions(id.getClass());
+    }
+    
+    public static <T extends DefinitionsChildId> String getFileNameOfDefinitions(Class<T> id) {
+        String name = Util.getTypeForComponentId(id);
         name = name + Constants.SUFFIX_TOSCA_DEFINITIONS;
-        return new RepositoryFileReference(id, name);
+        return name;
     }
 
     /**
@@ -725,6 +733,7 @@ public static void persist(DefinitionsChildId id, Definitions definitions) throw
         BackendUtils.persist(definitions, ref, MediaTypes.MEDIATYPE_TOSCA_DEFINITIONS);
     }
 
+    // todo this should not depend on JAXB !
     /**
      * @throws IOException           if content could not be updated in the repository
      * @throws IllegalStateException if an JAXBException occurred. This should never happen.
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/IGenericRepository.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/IGenericRepository.java
index 5baa7ed93..f2abfbef3 100644
--- a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/IGenericRepository.java
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/IGenericRepository.java
@@ -36,6 +36,7 @@
 import javax.xml.namespace.QName;
 
 import org.eclipse.winery.common.RepositoryFileReference;
+import org.eclipse.winery.common.configuration.Environments;
 import org.eclipse.winery.common.ids.GenericId;
 import org.eclipse.winery.common.ids.Namespace;
 import org.eclipse.winery.common.ids.definitions.ArtifactTemplateId;
@@ -170,6 +171,15 @@
      */
     InputStream newInputStream(RepositoryFileReference ref) throws IOException;
 
+    /**
+     * Creates {@link Definitions} object from a {@link RepositoryFileReference}.
+     *
+     * @param ref the {@link RepositoryFileReference} to use
+     * @return the {@link Definitions} object
+     * @throws IOException if something goes wrong
+     */
+    Definitions definitionsFromRef(RepositoryFileReference ref) throws IOException;
+
     /**
      * Creates a stream of a ZIP file containing all files contained in the given id
      *
@@ -427,13 +437,15 @@
 
         final TNodeType nodeType = this.getElement(id);
 
-        // add all referenced requirement types
-        TNodeType.RequirementDefinitions reqDefsContainer = nodeType.getRequirementDefinitions();
-        if (reqDefsContainer != null) {
-            List<TRequirementDefinition> reqDefs = reqDefsContainer.getRequirementDefinition();
-            for (TRequirementDefinition reqDef : reqDefs) {
-                RequirementTypeId reqTypeId = new RequirementTypeId(reqDef.getRequirementType());
-                ids.add(reqTypeId);
+        // add all referenced requirement types, but only in XML mode. YAML does not have requirement types
+        if (!Environments.getUiConfig().getFeatures().get("yaml")) {
+            TNodeType.RequirementDefinitions reqDefsContainer = nodeType.getRequirementDefinitions();
+            if (reqDefsContainer != null) {
+                List<TRequirementDefinition> reqDefs = reqDefsContainer.getRequirementDefinition();
+                for (TRequirementDefinition reqDef : reqDefs) {
+                    RequirementTypeId reqTypeId = new RequirementTypeId(reqDef.getRequirementType());
+                    ids.add(reqTypeId);
+                }
             }
         }
 
@@ -484,11 +496,6 @@
         return this.getReferencedTOSCAComponentImplementationArtifactIds(ids, element.getImplementationArtifacts(), id);
     }
 
-    default Collection<DefinitionsChildId> getReferencedDefinitionsChildIds(ArtifactTypeId id) {
-        // no recursive crawling needed
-        return Collections.emptyList();
-    }
-
     /**
      * Helper method
      *
@@ -638,16 +645,8 @@
                             }
                         }
                     }
+                    getReferencedRequirementTypeIds(ids, n);
 
-                    // crawl through reqs/caps
-                    TNodeTemplate.Requirements requirements = n.getRequirements();
-                    if (requirements != null) {
-                        for (TRequirement req : requirements.getRequirement()) {
-                            QName type = req.getType();
-                            RequirementTypeId rtId = new RequirementTypeId(type);
-                            ids.add(rtId);
-                        }
-                    }
                     TNodeTemplate.Capabilities capabilities = n.getCapabilities();
                     if (capabilities != null) {
                         for (TCapability cap : capabilities.getCapability()) {
@@ -682,6 +681,18 @@
         return ids;
     }
 
+    default void getReferencedRequirementTypeIds(Collection<DefinitionsChildId> ids, TNodeTemplate n) {
+        // crawl through reqs/caps
+        TNodeTemplate.Requirements requirements = n.getRequirements();
+        if (requirements != null) {
+            for (TRequirement req : requirements.getRequirement()) {
+                QName type = req.getType();
+                RequirementTypeId rtId = new RequirementTypeId(type);
+                ids.add(rtId);
+            }
+        }
+    }
+
     default Collection<DefinitionsChildId> getReferencedDefinitionsChildIds(PatternRefinementModelId id) {
         // TODO
         return new HashSet<>();
@@ -721,14 +732,7 @@
                     }
 
                     // crawl through reqs/caps
-                    TNodeTemplate.Requirements requirements = n.getRequirements();
-                    if (requirements != null) {
-                        for (TRequirement req : requirements.getRequirement()) {
-                            QName type = req.getType();
-                            RequirementTypeId rtId = new RequirementTypeId(type);
-                            ids.add(rtId);
-                        }
-                    }
+                    getReferencedRequirementTypeIds(ids, n);
                     TNodeTemplate.Capabilities capabilities = n.getCapabilities();
                     if (capabilities != null) {
                         for (TCapability cap : capabilities.getCapability()) {
@@ -780,14 +784,12 @@
             referencedDefinitionsChildIds = this.getReferencedDefinitionsChildIds((RelationshipTypeImplementationId) id);
         } else if (id instanceof RequirementTypeId) {
             referencedDefinitionsChildIds = this.getReferencedDefinitionsChildIds((RequirementTypeId) id);
-        } else if (id instanceof ArtifactTypeId) {
-            referencedDefinitionsChildIds = this.getReferencedDefinitionsChildIds((ArtifactTypeId) id);
         } else if (id instanceof ArtifactTemplateId) {
             referencedDefinitionsChildIds = this.getReferencedDefinitionsChildIds((ArtifactTemplateId) id);
         } else if (id instanceof PolicyTemplateId) {
             referencedDefinitionsChildIds = this.getReferencedDefinitionsChildIds((PolicyTemplateId) id);
-        } else if (id instanceof GenericImportId || id instanceof PolicyTypeId || id instanceof CapabilityTypeId) {
-            // in case of imports, policy types, and capability types, there are no other ids referenced
+        } else if (id instanceof ArtifactTypeId || id instanceof GenericImportId || id instanceof PolicyTypeId || id instanceof CapabilityTypeId) {
+            // in case of artifact types, imports, policy types, and capability types, there are no other ids referenced
             // Collections.emptyList() cannot be used as we add elements later on in the case of inheritance
             referencedDefinitionsChildIds = new ArrayList();
         } else if (id instanceof ComplianceRuleId) {
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/IRepository.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/IRepository.java
index 6dbcf3fb9..80a430a12 100644
--- a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/IRepository.java
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/IRepository.java
@@ -13,6 +13,7 @@
  *******************************************************************************/
 package org.eclipse.winery.repository.backend;
 
+import java.nio.file.Path;
 import java.util.Date;
 
 import org.eclipse.winery.common.RepositoryFileReference;
@@ -62,4 +63,8 @@
      * id. NULL if the associated TOSCA element does not exist.
      */
     Date getConfigurationLastUpdate(GenericId id);
+
+    Path getRepositoryRoot();
+
+    Path getRepositoryDep();
 }
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/RepositoryFactory.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/RepositoryFactory.java
index a3e21d19b..34fbc7482 100644
--- a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/RepositoryFactory.java
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/RepositoryFactory.java
@@ -24,10 +24,12 @@
 import org.eclipse.winery.common.configuration.Environments;
 import org.eclipse.winery.common.configuration.FileBasedRepositoryConfiguration;
 import org.eclipse.winery.common.configuration.GitBasedRepositoryConfiguration;
+import org.eclipse.winery.common.configuration.RepositoryConfigurationObject;
 import org.eclipse.winery.repository.backend.constants.Filename;
 import org.eclipse.winery.repository.backend.filebased.FilebasedRepository;
 import org.eclipse.winery.repository.backend.filebased.GitBasedRepository;
 import org.eclipse.winery.repository.backend.filebased.MultiRepository;
+import org.eclipse.winery.repository.backend.filebased.YamlRepository;
 
 import org.eclipse.jgit.api.errors.GitAPIException;
 import org.slf4j.Logger;
@@ -48,14 +50,23 @@ private static boolean repositoryContainsRepoConfig(FileBasedRepositoryConfigura
         return FilebasedRepository.getRepositoryRoot(config).resolve(Filename.FILENAME_JSON_REPOSITORIES).toFile().exists();
     }
 
+    public static FilebasedRepository createXmlOrYamlRepository(FileBasedRepositoryConfiguration configuration) {
+        if (RepositoryConfigurationObject.RepositoryProvider.YAML.equals(configuration.getRepositoryProvider())) {
+            return new YamlRepository(configuration);
+        } else {
+            // XML-based repository
+            return new FilebasedRepository(configuration);
+        }
+    }
+
     public static void reconfigure(GitBasedRepositoryConfiguration gitBasedRepositoryConfiguration) throws IOException, GitAPIException {
         RepositoryFactory.gitBasedRepositoryConfiguration = gitBasedRepositoryConfiguration;
         RepositoryFactory.fileBasedRepositoryConfiguration = null;
 
         if (repositoryContainsRepoConfig(gitBasedRepositoryConfiguration)) {
-            repository = new MultiRepository(gitBasedRepositoryConfiguration);
+            repository = new MultiRepository(gitBasedRepositoryConfiguration, createXmlOrYamlRepository(gitBasedRepositoryConfiguration));
         } else {
-            repository = new GitBasedRepository(gitBasedRepositoryConfiguration);
+            repository = new GitBasedRepository(gitBasedRepositoryConfiguration, createXmlOrYamlRepository(gitBasedRepositoryConfiguration));
         }
     }
 
@@ -65,7 +76,8 @@ public static void reconfigure(FileBasedRepositoryConfiguration fileBasedReposit
 
         if (repositoryContainsRepoConfig(fileBasedRepositoryConfiguration)) {
             try {
-                repository = new MultiRepository(new GitBasedRepositoryConfiguration(false, fileBasedRepositoryConfiguration));
+                FilebasedRepository compositeRepository = createXmlOrYamlRepository(fileBasedRepositoryConfiguration);
+                repository = new MultiRepository(new GitBasedRepositoryConfiguration(false, fileBasedRepositoryConfiguration), compositeRepository);
             } catch (IOException | GitAPIException exception) {
                 exception.printStackTrace();
             }
@@ -78,7 +90,7 @@ public static void reconfigure(FileBasedRepositoryConfiguration fileBasedReposit
      * Reconfigures based on Environment
      */
     public static void reconfigure() throws Exception {
-        final Optional<GitBasedRepositoryConfiguration> gitBasedRepositoryConfiguration = Environments.getGitBasedRepsitoryConfiguration();
+        final Optional<GitBasedRepositoryConfiguration> gitBasedRepositoryConfiguration = Environments.getGitBasedRepositoryConfiguration();
         final FileBasedRepositoryConfiguration filebasedRepositoryConfiguration = Environments.getFilebasedRepositoryConfiguration();
 
         // Determine whether the filebased repository could be git repository.
@@ -118,6 +130,6 @@ public static IRepository getRepository(FileBasedRepositoryConfiguration fileBas
         // FIXME: currently, the CSAR export does not reuse the repository instance returned here. Thus, we have to reconfigure the repository.
         // This should be fixed by always passing IRepository when working with the repository
         reconfigure(fileBasedRepositoryConfiguration);
-        return new FilebasedRepository(Objects.requireNonNull(fileBasedRepositoryConfiguration));
+        return createXmlOrYamlRepository(fileBasedRepositoryConfiguration);
     }
 }
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/AutoSaveListener.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/AutoSaveListener.java
index f54130854..f0c6f9862 100644
--- a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/AutoSaveListener.java
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/AutoSaveListener.java
@@ -13,13 +13,6 @@
  *******************************************************************************/
 package org.eclipse.winery.repository.backend.filebased;
 
-import org.apache.commons.configuration2.ex.ConfigurationException;
-import org.apache.commons.configuration2.PropertiesConfiguration;
-import org.apache.commons.configuration2.event.ConfigurationEvent;
-import org.apache.commons.configuration2.event.EventListener;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
@@ -27,9 +20,15 @@
 import java.nio.file.Path;
 import java.nio.file.StandardOpenOption;
 
+import org.apache.commons.configuration2.PropertiesConfiguration;
+import org.apache.commons.configuration2.event.ConfigurationEvent;
+import org.apache.commons.configuration2.event.EventListener;
+import org.apache.commons.configuration2.ex.ConfigurationException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 /**
- * We do not count loads and saves as in
- * {@link org.apache.commons.configuration.builder.AutoSaveListener}, because
+ * We do not count loads and saves as in {@link org.apache.commons.configuration.builder.AutoSaveListener}, because
  * ConfigurationListener is not aware of such things
  */
 class AutoSaveListener implements EventListener<ConfigurationEvent> {
@@ -39,12 +38,10 @@
     private final Path path;
     private final PropertiesConfiguration configuration;
 
-
     /**
      * @param path          the file path to write to
-     * @param configuration the configuration, where the change events come
-     *                      from. This is needed as <code>event.getSource()</code> does
-     *                      not work
+     * @param configuration the configuration, where the change events come from. This is needed as
+     *                      <code>event.getSource()</code> does not work
      */
     public AutoSaveListener(Path path, PropertiesConfiguration configuration) {
         this.path = path;
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/FilebasedRepository.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/FilebasedRepository.java
index a82bf734f..85ced8ce1 100644
--- a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/FilebasedRepository.java
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/FilebasedRepository.java
@@ -45,6 +45,8 @@
 import java.util.zip.ZipInputStream;
 import java.util.zip.ZipOutputStream;
 
+import javax.xml.bind.Unmarshaller;
+
 import org.eclipse.winery.common.Constants;
 import org.eclipse.winery.common.RepositoryFileReference;
 import org.eclipse.winery.common.Util;
@@ -62,6 +64,7 @@
 import org.eclipse.winery.common.version.WineryVersion;
 import org.eclipse.winery.model.tosca.Definitions;
 import org.eclipse.winery.model.tosca.HasIdInIdOrNameField;
+import org.eclipse.winery.repository.JAXBSupport;
 import org.eclipse.winery.repository.backend.AbstractRepository;
 import org.eclipse.winery.repository.backend.AccountabilityConfigurationManager;
 import org.eclipse.winery.repository.backend.BackendUtils;
@@ -99,12 +102,10 @@
 
     private static List<String> ignoreFile = new ArrayList<>();
 
-    protected final Path repositoryRoot;
-    protected final Path repositoryDep;
+    private final Path repositoryRoot;
+    private final Path repositoryDep;
 
-    // convenience variables to have a clean code
     private final FileSystem fileSystem;
-
     private final FileSystemProvider provider;
 
     private final boolean isLocal;
@@ -144,11 +145,13 @@ private Path makeAbsolute(Path relativePath) {
     /**
      * @return the currently configured repository root
      */
+    @Override
     public Path getRepositoryRoot() {
         return repositoryRoot;
     }
 
-    protected Path getRepositoryDep() {
+    @Override
+    public Path getRepositoryDep() {
         return repositoryDep;
     }
 
@@ -223,6 +226,17 @@ public static File getActiveRepositoryFilePath() {
         return new File(Environments.getRepositoryConfig().getRepositoryRoot());
     }
 
+    @Override
+    public Definitions definitionsFromRef(RepositoryFileReference ref) throws IOException {
+        try {
+            InputStream is = newInputStream(ref);
+            Unmarshaller unmarshaller = JAXBSupport.createUnmarshaller();
+            return (Definitions) unmarshaller.unmarshal(is);
+        } catch (Exception e) {
+            return null;
+        }
+    }
+
     private static Path createDefaultRepositoryPath() {
         File repo = null;
         boolean operationalFileSystemAccess;
@@ -378,6 +392,10 @@ public void putContentToFile(RepositoryFileReference ref, InputStream inputStrea
             this.setMimeType(ref, mediaType);
         }
         Path targetPath = this.ref2AbsolutePath(ref);
+        writeInputStreamToPath(targetPath, inputStream);
+    }
+
+    public void writeInputStreamToPath(Path targetPath, InputStream inputStream) throws IOException {
         // ensure that parent directory exists
         FileUtils.createDirectory(targetPath.getParent());
 
@@ -411,7 +429,7 @@ public boolean exists(RepositoryFileReference ref) {
         return getDefinitionsChildIds(idClass, true);
     }
 
-    private <T extends DefinitionsChildId> SortedSet<T> getDefinitionsChildIds(Class<T> idClass, boolean omitDevelopmentVersions) {
+    public <T extends DefinitionsChildId> SortedSet<T> getDefinitionsChildIds(Class<T> idClass, boolean omitDevelopmentVersions) {
         SortedSet<T> res = new TreeSet<>();
         String rootPathFragment = Util.getRootPathFragment(idClass);
         Path dir = this.getRepositoryRoot().resolve(rootPathFragment);
@@ -807,6 +825,10 @@ public FileTime getLastModifiedTime(RepositoryFileReference ref) throws IOExcept
     @Override
     public InputStream newInputStream(RepositoryFileReference ref) throws IOException {
         Path path = this.ref2AbsolutePath(ref);
+        return newInputStream(path);
+    }
+
+    public InputStream newInputStream(Path path) throws IOException {
         return Files.newInputStream(path);
     }
 
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/GitBasedRepository.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/GitBasedRepository.java
index ceffc16b6..a31a654da 100644
--- a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/GitBasedRepository.java
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/GitBasedRepository.java
@@ -22,19 +22,76 @@
 import java.io.StringWriter;
 import java.nio.file.Files;
 import java.nio.file.Path;
+import java.nio.file.attribute.FileTime;
+import java.util.Collection;
+import java.util.Date;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
+import java.util.Optional;
+import java.util.SortedSet;
 import java.util.stream.Collectors;
 
+import javax.xml.namespace.QName;
+
 import org.eclipse.winery.common.Constants;
 import org.eclipse.winery.common.RepositoryFileReference;
 import org.eclipse.winery.common.configuration.GitBasedRepositoryConfiguration;
+import org.eclipse.winery.common.ids.GenericId;
+import org.eclipse.winery.common.ids.Namespace;
+import org.eclipse.winery.common.ids.definitions.ArtifactTemplateId;
+import org.eclipse.winery.common.ids.definitions.ArtifactTypeId;
+import org.eclipse.winery.common.ids.definitions.CapabilityTypeId;
+import org.eclipse.winery.common.ids.definitions.ComplianceRuleId;
+import org.eclipse.winery.common.ids.definitions.DefinitionsChildId;
+import org.eclipse.winery.common.ids.definitions.HasInheritanceId;
+import org.eclipse.winery.common.ids.definitions.NodeTypeId;
+import org.eclipse.winery.common.ids.definitions.NodeTypeImplementationId;
+import org.eclipse.winery.common.ids.definitions.PatternRefinementModelId;
+import org.eclipse.winery.common.ids.definitions.PolicyTemplateId;
+import org.eclipse.winery.common.ids.definitions.PolicyTypeId;
+import org.eclipse.winery.common.ids.definitions.RefinementId;
+import org.eclipse.winery.common.ids.definitions.RelationshipTypeId;
+import org.eclipse.winery.common.ids.definitions.RelationshipTypeImplementationId;
+import org.eclipse.winery.common.ids.definitions.RequirementTypeId;
+import org.eclipse.winery.common.ids.definitions.ServiceTemplateId;
+import org.eclipse.winery.common.ids.definitions.TestRefinementModelId;
+import org.eclipse.winery.common.ids.definitions.imports.GenericImportId;
+import org.eclipse.winery.common.ids.elements.ToscaElementId;
+import org.eclipse.winery.model.tosca.Definitions;
+import org.eclipse.winery.model.tosca.TArtifactTemplate;
+import org.eclipse.winery.model.tosca.TArtifactType;
+import org.eclipse.winery.model.tosca.TCapabilityType;
+import org.eclipse.winery.model.tosca.TComplianceRule;
+import org.eclipse.winery.model.tosca.TEntityTemplate;
+import org.eclipse.winery.model.tosca.TEntityType;
+import org.eclipse.winery.model.tosca.TExtensibleElements;
+import org.eclipse.winery.model.tosca.TImplementationArtifacts;
+import org.eclipse.winery.model.tosca.TNodeType;
+import org.eclipse.winery.model.tosca.TNodeTypeImplementation;
+import org.eclipse.winery.model.tosca.TPatternRefinementModel;
+import org.eclipse.winery.model.tosca.TPolicyTemplate;
+import org.eclipse.winery.model.tosca.TPolicyType;
+import org.eclipse.winery.model.tosca.TRefinementModel;
+import org.eclipse.winery.model.tosca.TRelationshipType;
+import org.eclipse.winery.model.tosca.TRelationshipTypeImplementation;
+import org.eclipse.winery.model.tosca.TRequirementType;
+import org.eclipse.winery.model.tosca.TServiceTemplate;
+import org.eclipse.winery.model.tosca.TTestRefinementModel;
+import org.eclipse.winery.repository.backend.AccountabilityConfigurationManager;
 import org.eclipse.winery.repository.backend.BackendUtils;
+import org.eclipse.winery.repository.backend.EdmmManager;
+import org.eclipse.winery.repository.backend.IRepository;
+import org.eclipse.winery.repository.backend.IRepositoryAdministration;
+import org.eclipse.winery.repository.backend.NamespaceManager;
+import org.eclipse.winery.repository.backend.xsd.XsdImportManager;
+import org.eclipse.winery.repository.exceptions.RepositoryCorruptException;
+import org.eclipse.winery.repository.exceptions.WineryRepositoryException;
 
 import com.google.common.collect.Iterables;
 import com.google.common.eventbus.EventBus;
+import org.apache.commons.configuration2.Configuration;
 import org.apache.tika.mime.MediaType;
 import org.eclipse.jgit.api.AddCommand;
 import org.eclipse.jgit.api.CleanCommand;
@@ -56,7 +113,7 @@
 /**
  * Allows to reset repository to a certain commit id
  */
-public class GitBasedRepository extends FilebasedRepository {
+public class GitBasedRepository extends FilebasedRepository implements IRepository, IRepositoryAdministration {
 
     /**
      * Used for synchronizing the method {@link GitBasedRepository#addCommit(RepositoryFileReference)}
@@ -64,27 +121,35 @@
     private static final Object COMMIT_LOCK = new Object();
     private static final Logger LOGGER = LoggerFactory.getLogger(GitBasedRepository.class);
 
-    protected final Path workingRepositoryRoot;
+    private final Path workingRepositoryRoot;
 
     private final Git git;
     private final EventBus eventBus;
-    private final GitBasedRepositoryConfiguration gitBasedRepositoryConfiguration;
+    private final GitBasedRepositoryConfiguration configuration;
+
+    private final FilebasedRepository repository;
+    private final Path repositoryRoot;
 
     /**
-     * @param gitBasedRepositoryConfiguration the configuration of the repository
+     * @param configuration the configuration of the repository
+     * @param repository    a repository reference to use
      * @throws IOException         thrown if repository does not exist
      * @throws GitAPIException     thrown if there was an error while checking the status of the repository
      * @throws NoWorkTreeException thrown if the directory is not a git work tree
      */
-    public GitBasedRepository(GitBasedRepositoryConfiguration gitBasedRepositoryConfiguration) throws IOException, NoWorkTreeException, GitAPIException {
-        super(Objects.requireNonNull(gitBasedRepositoryConfiguration));
-        this.gitBasedRepositoryConfiguration = gitBasedRepositoryConfiguration;
+    public GitBasedRepository(GitBasedRepositoryConfiguration configuration, FilebasedRepository repository) throws IOException, NoWorkTreeException, GitAPIException {
+        super(Objects.requireNonNull(configuration));
+
+        this.configuration = configuration;
+        this.repository = repository;
+
+        this.repositoryRoot = repository.getRepositoryRoot();
 
         FileRepositoryBuilder builder = new FileRepositoryBuilder();
         Repository gitRepo = builder.setWorkTree(this.repositoryRoot.toFile()).setMustExist(false).build();
 
-        String repoUrl = gitBasedRepositoryConfiguration.getRepositoryUrl();
-        String branch = gitBasedRepositoryConfiguration.getBranch();
+        String repoUrl = configuration.getRepositoryUrl();
+        String branch = configuration.getBranch();
 
         if (!Files.exists(this.repositoryRoot.resolve(".git"))) {
             if (repoUrl != null && !repoUrl.isEmpty()) {
@@ -101,10 +166,10 @@ public GitBasedRepository(GitBasedRepositoryConfiguration gitBasedRepositoryConf
             if (!(this instanceof MultiRepository)) {
                 this.workingRepositoryRoot = this.repositoryRoot.resolve(Constants.DEFAULT_LOCAL_REPO_NAME);
             } else {
-                this.workingRepositoryRoot = repositoryDep;
+                this.workingRepositoryRoot = this.repository.getRepositoryDep();
             }
         } else {
-            this.workingRepositoryRoot = repositoryDep;
+            this.workingRepositoryRoot = this.repository.getRepositoryDep();
         }
 
         this.eventBus = new EventBus();
@@ -113,7 +178,7 @@ public GitBasedRepository(GitBasedRepositoryConfiguration gitBasedRepositoryConf
         gitRepo.getConfig().setBoolean("core", null, "longpaths", true);
         gitRepo.getConfig().save();
 
-        if (gitBasedRepositoryConfiguration.isAutoCommit() && !this.git.status().call().isClean()) {
+        if (configuration.isAutoCommit() && !this.git.status().call().isClean()) {
             this.addCommit("Files changed externally.");
         }
     }
@@ -122,7 +187,7 @@ Path generateWorkingRepositoryRoot() {
         if (this.repositoryRoot.resolve(Constants.DEFAULT_LOCAL_REPO_NAME).toFile().exists()) {
             return this.repositoryRoot.resolve(Constants.DEFAULT_LOCAL_REPO_NAME);
         } else {
-            return repositoryDep;
+            return this.repository.getRepositoryDep();
         }
     }
 
@@ -255,9 +320,9 @@ public void setRevisionTo(String ref) throws GitAPIException {
 
     @Override
     public void putContentToFile(RepositoryFileReference ref, InputStream inputStream, MediaType mediaType) throws IOException {
-        super.putContentToFile(ref, inputStream, mediaType);
+        repository.putContentToFile(ref, inputStream, mediaType);
         try {
-            if (gitBasedRepositoryConfiguration.isAutoCommit()) {
+            if (configuration.isAutoCommit()) {
                 this.addCommit(ref);
             } else {
                 postEventMap();
@@ -295,20 +360,475 @@ public Status getStatus() {
         }
     }
 
+    public String getRepositoryUrl() {
+        return this.configuration.getRepositoryUrl();
+    }
+
     private Git cloneRepository(String repoUrl, String branch) throws GitAPIException {
         return Git.cloneRepository()
             .setURI(repoUrl)
-            .setDirectory(this.getRepositoryDep().toFile())
+            .setDirectory(getRepositoryDep().toFile())
             .setBranch(branch)
             .call();
     }
 
-    public String getRepositoryUrl() {
-        return this.gitBasedRepositoryConfiguration.getRepositoryUrl();
+    @Override
+    protected Path id2RelativePath(GenericId id) {
+        return repository.id2RelativePath(id);
+    }
+
+    @Override
+    protected Path id2AbsolutePath(GenericId id) {
+        return repository.id2AbsolutePath(id);
+    }
+
+    @Override
+    protected Path ref2AbsolutePath(RepositoryFileReference ref) {
+        return repository.ref2AbsolutePath(ref);
+    }
+
+    @Override
+    public void writeInputStreamToPath(Path targetPath, InputStream inputStream) throws IOException {
+        repository.writeInputStreamToPath(targetPath, inputStream);
+    }
+
+    @Override
+    public <T extends DefinitionsChildId> SortedSet<T> getDefinitionsChildIds(Class<T> idClass, boolean omitDevelopmentVersions) {
+        return repository.getDefinitionsChildIds(idClass, omitDevelopmentVersions);
+    }
+
+    @Override
+    public Collection<? extends DefinitionsChildId> getAllIdsInNamespace(Class<? extends DefinitionsChildId> clazz, Namespace namespace) {
+        return repository.getAllIdsInNamespace(clazz, namespace);
+    }
+
+    @Override
+    public void forceClear() {
+        repository.forceClear();
+    }
+
+    @Override
+    public InputStream newInputStream(Path path) throws IOException {
+        return repository.newInputStream(path);
+    }
+
+    @Override
+    public void setMimeType(RepositoryFileReference ref, MediaType mediaType) throws IOException {
+        repository.setMimeType(ref, mediaType);
+    }
+
+    @Override
+    public boolean flagAsExisting(GenericId id) {
+        return repository.flagAsExisting(id);
+    }
+
+    @Override
+    public boolean exists(GenericId id) {
+        return repository.exists(id);
+    }
+
+    @Override
+    public void forceDelete(RepositoryFileReference ref) throws IOException {
+        repository.forceDelete(ref);
+    }
+
+    @Override
+    public boolean exists(RepositoryFileReference ref) {
+        return repository.exists(ref);
+    }
+
+    @Override
+    public void putContentToFile(RepositoryFileReference ref, String content, MediaType mediaType) throws IOException {
+        repository.putContentToFile(ref, content, mediaType);
+    }
+
+    @Override
+    public InputStream newInputStream(RepositoryFileReference ref) throws IOException {
+        return repository.newInputStream(ref);
+    }
+
+    @Override
+    public Definitions definitionsFromRef(RepositoryFileReference ref) throws IOException {
+        return repository.definitionsFromRef(ref);
+    }
+
+    @Override
+    public void getZippedContents(GenericId id, OutputStream out) throws WineryRepositoryException {
+        repository.getZippedContents(id, out);
+    }
+
+    @Override
+    public long getSize(RepositoryFileReference ref) throws IOException {
+        return repository.getSize(ref);
+    }
+
+    @Override
+    public FileTime getLastModifiedTime(RepositoryFileReference ref) throws IOException {
+        return repository.getLastModifiedTime(ref);
+    }
+
+    @Override
+    public String getMimeType(RepositoryFileReference ref) throws IOException {
+        return repository.getMimeType(ref);
+    }
+
+    @Override
+    public Date getLastUpdate(RepositoryFileReference ref) {
+        return repository.getLastUpdate(ref);
+    }
+
+    @Override
+    public <T extends DefinitionsChildId> SortedSet<T> getAllDefinitionsChildIds(Class<T> idClass) {
+        return repository.getAllDefinitionsChildIds(idClass);
+    }
+
+    @Override
+    public <T extends DefinitionsChildId> SortedSet<T> getStableDefinitionsChildIdsOnly(Class<T> idClass) {
+        return repository.getStableDefinitionsChildIdsOnly(idClass);
+    }
+
+    @Override
+    public SortedSet<DefinitionsChildId> getAllDefinitionsChildIds() {
+        return repository.getAllDefinitionsChildIds();
+    }
+
+    @Override
+    public <T extends DefinitionsChildId, S extends TExtensibleElements> Map<QName, S> getQNameToElementMapping(Class<T> idClass) {
+        return repository.getQNameToElementMapping(idClass);
+    }
+
+    @Override
+    public <T extends ToscaElementId> SortedSet<T> getNestedIds(GenericId ref, Class<T> idClass) {
+        return repository.getNestedIds(ref, idClass);
+    }
+
+    @Override
+    public SortedSet<RepositoryFileReference> getContainedFiles(GenericId id) {
+        return repository.getContainedFiles(id);
+    }
+
+    @Override
+    public Collection<Namespace> getUsedNamespaces() {
+        return repository.getUsedNamespaces();
+    }
+
+    @Override
+    public Collection<Namespace> getComponentsNamespaces(Class<? extends DefinitionsChildId> clazz) {
+        return repository.getComponentsNamespaces(clazz);
+    }
+
+    @Override
+    public <X extends DefinitionsChildId> Collection<X> getAllElementsReferencingGivenType(Class<X> clazz, QName qNameOfTheType) {
+        return repository.getAllElementsReferencingGivenType(clazz, qNameOfTheType);
+    }
+
+    @Override
+    public Optional<DefinitionsChildId> getDefinitionsChildIdOfParent(HasInheritanceId id) {
+        return repository.getDefinitionsChildIdOfParent(id);
+    }
+
+    @Override
+    public Collection<DefinitionsChildId> getReferencedDefinitionsChildIds(NodeTypeId id) {
+        return repository.getReferencedDefinitionsChildIds(id);
+    }
+
+    @Override
+    public Collection<DefinitionsChildId> getReferencedDefinitionsChildIds(NodeTypeImplementationId id) {
+        return repository.getReferencedDefinitionsChildIds(id);
+    }
+
+    @Override
+    public Collection<DefinitionsChildId> getReferencedDefinitionsChildIds(RelationshipTypeImplementationId id) {
+        return repository.getReferencedDefinitionsChildIds(id);
+    }
+
+    @Override
+    public Collection<DefinitionsChildId> getReferencedTOSCAComponentImplementationArtifactIds(Collection<DefinitionsChildId> ids, TImplementationArtifacts implementationArtifacts, DefinitionsChildId id) {
+        return repository.getReferencedTOSCAComponentImplementationArtifactIds(ids, implementationArtifacts, id);
+    }
+
+    @Override
+    public Collection<DefinitionsChildId> getReferencedDefinitionsChildIds(RequirementTypeId id) {
+        return repository.getReferencedDefinitionsChildIds(id);
+    }
+
+    @Override
+    public Collection<DefinitionsChildId> getReferencedDefinitionsChildIds(PolicyTemplateId id) {
+        return repository.getReferencedDefinitionsChildIds(id);
+    }
+
+    @Override
+    public Collection<DefinitionsChildId> getReferencedDefinitionsChildIds(RelationshipTypeId id) {
+        return repository.getReferencedDefinitionsChildIds(id);
+    }
+
+    @Override
+    public Collection<DefinitionsChildId> getReferencedDefinitionsChildIds(ArtifactTemplateId id) throws RepositoryCorruptException {
+        return repository.getReferencedDefinitionsChildIds(id);
+    }
+
+    @Override
+    public Collection<DefinitionsChildId> getReferencedDefinitionsChildIds(ServiceTemplateId id) {
+        return repository.getReferencedDefinitionsChildIds(id);
+    }
+
+    @Override
+    public Collection<DefinitionsChildId> getReferencedDefinitionsChildIds(PatternRefinementModelId id) {
+        return repository.getReferencedDefinitionsChildIds(id);
+    }
+
+    @Override
+    public Collection<DefinitionsChildId> getReferencedDefinitionsChildIds(TestRefinementModelId id) {
+        return repository.getReferencedDefinitionsChildIds(id);
+    }
+
+    @Override
+    public Collection<DefinitionsChildId> getReferencedDefinitionsChildIds(ComplianceRuleId id) {
+        return repository.getReferencedDefinitionsChildIds(id);
+    }
+
+    @Override
+    public Collection<DefinitionsChildId> getReferencedDefinitionsChildIds(DefinitionsChildId id) throws RepositoryCorruptException {
+        return repository.getReferencedDefinitionsChildIds(id);
+    }
+
+    @Override
+    public Collection<DefinitionsChildId> getReferencingDefinitionsChildIds(NodeTypeId id) {
+        return repository.getReferencingDefinitionsChildIds(id);
+    }
+
+    @Override
+    public Collection<DefinitionsChildId> getReferencingDefinitionsChildIds(NodeTypeImplementationId id) {
+        return repository.getReferencingDefinitionsChildIds(id);
+    }
+
+    @Override
+    public Collection<DefinitionsChildId> getReferencingDefinitionsChildIds(RelationshipTypeImplementationId id) {
+        return repository.getReferencingDefinitionsChildIds(id);
+    }
+
+    @Override
+    public Collection<DefinitionsChildId> getReferencingDefinitionsChildIds(RelationshipTypeId id) {
+        return repository.getReferencingDefinitionsChildIds(id);
+    }
+
+    @Override
+    public Collection<DefinitionsChildId> getReferencingDefinitionsChildIds(RequirementTypeId id) {
+        return repository.getReferencingDefinitionsChildIds(id);
+    }
+
+    @Override
+    public Collection<DefinitionsChildId> getReferencingDefinitionsChildIds(ArtifactTypeId id) {
+        return repository.getReferencingDefinitionsChildIds(id);
+    }
+
+    @Override
+    public Collection<DefinitionsChildId> getReferencingDefinitionsChildIds(ArtifactTemplateId id) {
+        return repository.getReferencingDefinitionsChildIds(id);
+    }
+
+    @Override
+    public Collection<DefinitionsChildId> getReferencingDefinitionsChildIds(PolicyTemplateId id) {
+        return repository.getReferencingDefinitionsChildIds(id);
+    }
+
+    @Override
+    public Collection<DefinitionsChildId> getReferencingDefinitionsChildIds(PolicyTypeId id) {
+        return repository.getReferencingDefinitionsChildIds(id);
+    }
+
+    @Override
+    public Collection<DefinitionsChildId> getReferencingDefinitionsChildIds(CapabilityTypeId id) {
+        return repository.getReferencingDefinitionsChildIds(id);
+    }
+
+    @Override
+    public Collection<DefinitionsChildId> getReferencingDefinitionsChildIds(GenericImportId id) {
+        return repository.getReferencingDefinitionsChildIds(id);
+    }
+
+    @Override
+    public Collection<DefinitionsChildId> getReferencingDefinitionsChildIds(DefinitionsChildId id) throws RepositoryCorruptException {
+        return repository.getReferencingDefinitionsChildIds(id);
+    }
+
+    @Override
+    public NamespaceManager getNamespaceManager() {
+        return repository.getNamespaceManager();
+    }
+
+    @Override
+    public EdmmManager getEdmmManager() {
+        return repository.getEdmmManager();
+    }
+
+    @Override
+    public AccountabilityConfigurationManager getAccountabilityConfigurationManager() {
+        return repository.getAccountabilityConfigurationManager();
+    }
+
+    @Override
+    public XsdImportManager getXsdImportManager() {
+        return repository.getXsdImportManager();
+    }
+
+    @Override
+    public void setElement(DefinitionsChildId id, TExtensibleElements element) throws IOException {
+        repository.setElement(id, element);
+    }
+
+    @Override
+    public int getReferenceCount(ArtifactTemplateId id) {
+        return repository.getReferenceCount(id);
     }
 
     @Override
     public Path getRepositoryRoot() {
         return this.workingRepositoryRoot;
     }
+
+    @Override
+    public Path getRepositoryDep() {
+        return repository.getRepositoryDep();
+    }
+
+    @Override
+    public Configuration getConfiguration(GenericId id) {
+        return repository.getConfiguration(id);
+    }
+
+    @Override
+    public Configuration getConfiguration(RepositoryFileReference ref) {
+        return repository.getConfiguration(ref);
+    }
+
+    @Override
+    public Date getConfigurationLastUpdate(GenericId id) {
+        return repository.getConfigurationLastUpdate(id);
+    }
+
+    @Override
+    public Definitions getDefinitions(DefinitionsChildId id) {
+        return repository.getDefinitions(id);
+    }
+
+    @Override
+    public <T extends DefinitionsChildId, S extends TExtensibleElements> S getElement(T id) {
+        return repository.getElement(id);
+    }
+
+    @Override
+    public TNodeTypeImplementation getElement(NodeTypeImplementationId id) {
+        return repository.getElement(id);
+    }
+
+    @Override
+    public TRelationshipTypeImplementation getElement(RelationshipTypeImplementationId id) {
+        return repository.getElement(id);
+    }
+
+    @Override
+    public TNodeType getElement(NodeTypeId id) {
+        return repository.getElement(id);
+    }
+
+    @Override
+    public TRelationshipType getElement(RelationshipTypeId id) {
+        return repository.getElement(id);
+    }
+
+    @Override
+    public TServiceTemplate getElement(ServiceTemplateId id) {
+        return repository.getElement(id);
+    }
+
+    @Override
+    public TArtifactTemplate getElement(ArtifactTemplateId id) {
+        return repository.getElement(id);
+    }
+
+    @Override
+    public TArtifactType getElement(ArtifactTypeId id) {
+        return repository.getElement(id);
+    }
+
+    @Override
+    public TPolicyTemplate getElement(PolicyTemplateId id) {
+        return repository.getElement(id);
+    }
+
+    @Override
+    public TCapabilityType getElement(CapabilityTypeId id) {
+        return repository.getElement(id);
+    }
+
+    @Override
+    public TRequirementType getElement(RequirementTypeId id) {
+        return repository.getElement(id);
+    }
+
+    @Override
+    public TPolicyType getElement(PolicyTypeId id) {
+        return repository.getElement(id);
+    }
+
+    @Override
+    public TComplianceRule getElement(ComplianceRuleId id) {
+        return repository.getElement(id);
+    }
+
+    @Override
+    public TPatternRefinementModel getElement(PatternRefinementModelId id) {
+        return repository.getElement(id);
+    }
+
+    @Override
+    public TTestRefinementModel getElement(TestRefinementModelId id) {
+        return repository.getElement(id);
+    }
+
+    @Override
+    public TRefinementModel getElement(RefinementId id) {
+        return repository.getElement(id);
+    }
+
+    @Override
+    public void forceDelete(GenericId id) {
+        repository.forceDelete(id);
+    }
+
+    @Override
+    public void rename(DefinitionsChildId oldId, DefinitionsChildId newId) throws IOException {
+        repository.rename(oldId, newId);
+    }
+
+    @Override
+    public void duplicate(DefinitionsChildId from, DefinitionsChildId newId) throws IOException {
+        repository.duplicate(from, newId);
+    }
+
+    @Override
+    public void forceDelete(Class<? extends DefinitionsChildId> definitionsChildIdClazz, Namespace namespace) {
+        repository.forceDelete(definitionsChildIdClazz, namespace);
+    }
+
+    @Override
+    public TEntityType getTypeForTemplate(TEntityTemplate template) {
+        return repository.getTypeForTemplate(template);
+    }
+
+    @Override
+    public void doDump(OutputStream out) throws IOException {
+        repository.doDump(out);
+    }
+
+    @Override
+    public void doClear() {
+        repository.doClear();
+    }
+
+    @Override
+    public void doImport(InputStream in) {
+        repository.doImport(in);
+    }
 }
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/MultiRepository.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/MultiRepository.java
index 7aaedf4ed..b376d2683 100644
--- a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/MultiRepository.java
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/MultiRepository.java
@@ -39,6 +39,7 @@
 import org.eclipse.winery.common.ids.definitions.DefinitionsChildId;
 import org.eclipse.winery.common.ids.elements.ToscaElementId;
 import org.eclipse.winery.repository.backend.NamespaceManager;
+import org.eclipse.winery.repository.backend.RepositoryFactory;
 import org.eclipse.winery.repository.exceptions.WineryRepositoryException;
 
 import org.apache.commons.configuration2.Configuration;
@@ -59,15 +60,15 @@
 
     private GitBasedRepository localRepository;
 
-    public MultiRepository(GitBasedRepositoryConfiguration configuration) throws IOException, GitAPIException {
-        super(configuration);
+    public MultiRepository(GitBasedRepositoryConfiguration configuration, FilebasedRepository repository) throws IOException, GitAPIException {
+        super(configuration, repository);
 
         try {
             LOGGER.debug("Trying to initialize local repository...");
             File localRepoPath = new File(FilebasedRepository.getActiveRepositoryFilePath(), Constants.DEFAULT_LOCAL_REPO_NAME);
             FileBasedRepositoryConfiguration localRepoConfig = new FileBasedRepositoryConfiguration(localRepoPath.toPath());
             GitBasedRepositoryConfiguration gitConfig = new GitBasedRepositoryConfiguration(false, localRepoConfig);
-            this.localRepository = new GitBasedRepository(gitConfig);
+            this.localRepository = new GitBasedRepository(gitConfig, RepositoryFactory.createXmlOrYamlRepository(localRepoConfig));
             LOGGER.debug("Local repo has been initialized at {}", localRepoPath.getAbsolutePath());
         } catch (IOException | GitAPIException e) {
             LOGGER.error("Error while initializing local repository of the Multi Repository!", e);
@@ -82,7 +83,7 @@ public MultiRepository(GitBasedRepositoryConfiguration configuration) throws IOE
 
     @Override
     Path generateWorkingRepositoryRoot() {
-        return this.repositoryDep;
+        return this.getRepositoryDep();
     }
 
     protected FilebasedRepository getLocalRepository() {
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/YamlRepository.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/YamlRepository.java
new file mode 100644
index 000000000..61c497204
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/YamlRepository.java
@@ -0,0 +1,1018 @@
+/*******************************************************************************
+ * Copyright (c) 2012-2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.nio.file.DirectoryStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.SortedSet;
+import java.util.TreeSet;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBException;
+import javax.xml.bind.Unmarshaller;
+import javax.xml.namespace.QName;
+
+import org.eclipse.winery.common.RepositoryFileReference;
+import org.eclipse.winery.common.Util;
+import org.eclipse.winery.common.configuration.FileBasedRepositoryConfiguration;
+import org.eclipse.winery.common.ids.GenericId;
+import org.eclipse.winery.common.ids.Namespace;
+import org.eclipse.winery.common.ids.XmlId;
+import org.eclipse.winery.common.ids.definitions.ArtifactTemplateId;
+import org.eclipse.winery.common.ids.definitions.ArtifactTypeId;
+import org.eclipse.winery.common.ids.definitions.CapabilityTypeId;
+import org.eclipse.winery.common.ids.definitions.DefinitionsChildId;
+import org.eclipse.winery.common.ids.definitions.NodeTypeId;
+import org.eclipse.winery.common.ids.definitions.NodeTypeImplementationId;
+import org.eclipse.winery.common.ids.definitions.PolicyTypeId;
+import org.eclipse.winery.common.ids.definitions.RelationshipTypeId;
+import org.eclipse.winery.common.ids.definitions.RelationshipTypeImplementationId;
+import org.eclipse.winery.common.ids.definitions.RequirementTypeId;
+import org.eclipse.winery.common.version.VersionUtils;
+import org.eclipse.winery.common.version.WineryVersion;
+import org.eclipse.winery.model.tosca.Definitions;
+import org.eclipse.winery.model.tosca.TArtifactTemplate;
+import org.eclipse.winery.model.tosca.TNodeTemplate;
+import org.eclipse.winery.model.tosca.yaml.TArtifactDefinition;
+import org.eclipse.winery.model.tosca.yaml.TImplementation;
+import org.eclipse.winery.model.tosca.yaml.TImportDefinition;
+import org.eclipse.winery.model.tosca.yaml.TInterfaceDefinition;
+import org.eclipse.winery.model.tosca.yaml.TNodeType;
+import org.eclipse.winery.model.tosca.yaml.TOperationDefinition;
+import org.eclipse.winery.model.tosca.yaml.TRelationshipType;
+import org.eclipse.winery.model.tosca.yaml.TServiceTemplate;
+import org.eclipse.winery.model.tosca.yaml.support.Defaults;
+import org.eclipse.winery.model.tosca.yaml.support.TMapImportDefinition;
+import org.eclipse.winery.repository.JAXBSupport;
+import org.eclipse.winery.repository.backend.BackendUtils;
+import org.eclipse.winery.repository.backend.constants.MediaTypes;
+import org.eclipse.winery.repository.backend.filebased.converter.X2YConverter;
+import org.eclipse.winery.repository.backend.filebased.converter.Y2XConverter;
+import org.eclipse.winery.repository.backend.filebased.converter.support.exception.MultiException;
+import org.eclipse.winery.repository.backend.filebased.converter.support.reader.yaml.Reader;
+import org.eclipse.winery.repository.backend.filebased.converter.support.writer.yaml.Writer;
+
+import org.apache.tika.mime.MediaType;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class YamlRepository extends FilebasedRepository {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(YamlRepository.class);
+
+    private final Pattern namePattern;
+
+    public YamlRepository(FileBasedRepositoryConfiguration fileBasedRepositoryConfiguration) {
+        super(Objects.requireNonNull(fileBasedRepositoryConfiguration));
+
+        String nameRegex = "(.*)@(.*)@(.*)";
+        this.namePattern = Pattern.compile(nameRegex);
+    }
+
+    /**
+     * Converts RepositoryFileReference to compatible YAML File
+     *
+     * @param ref RepositoryFileReference
+     * @return compatible Path
+     **/
+    @Override
+    public Path ref2AbsolutePath(RepositoryFileReference ref) {
+        Path resultPath = id2AbsolutePath(ref.getParent());
+        Optional<Path> subDirectory = ref.getSubDirectory();
+        if (subDirectory.isPresent()) {
+            resultPath = resultPath.resolve(subDirectory.get());
+        }
+        GenericId convertedId = convertGenericId(ref.getParent());
+        if (convertedId != null) {
+            if (convertedId instanceof DefinitionsChildId) {
+                String convertedFilename = BackendUtils.getFileNameOfDefinitions((DefinitionsChildId) convertedId);
+                return resultPath.resolve(convertedFilename);
+            }
+        }
+        return resultPath.resolve(ref.getFileName());
+    }
+
+    /**
+     * Converts Generic to compatible YAML Folder
+     *
+     * @param id GenericId
+     * @return compatible Path
+     **/
+    @Override
+    public Path id2AbsolutePath(GenericId id) {
+        GenericId convertedId = convertGenericId(id);
+        if (convertedId != null) {
+            return super.id2AbsolutePath(convertedId);
+        } else {
+            return super.id2AbsolutePath(id);
+        }
+    }
+
+    /**
+     * Converts Generic id of non existing XML Definitions in compatible YAML Definition
+     *
+     * @param id GenericId
+     * @return converted Generic Id
+     **/
+    private GenericId convertGenericId(GenericId id) {
+        if (id instanceof NodeTypeImplementationId) {
+            return new NodeTypeId(((NodeTypeImplementationId) id).getQName());
+        } else if (id instanceof RelationshipTypeImplementationId) {
+            return new RelationshipTypeId(((RelationshipTypeImplementationId) id).getQName());
+        } else if (id instanceof ArtifactTemplateId) {
+            QName qName = ((ArtifactTemplateId) id).getQName();
+            Matcher nameMatcher = namePattern.matcher(qName.getLocalPart());
+            if (nameMatcher.matches()) {
+                String typeName = nameMatcher.group(2);
+                if (nameMatcher.group(3).equalsIgnoreCase("nodetypes")) {
+                    return new NodeTypeId(new QName(qName.getNamespaceURI(), typeName));
+                } else {
+                    return new RelationshipTypeId(new QName(qName.getNamespaceURI(), typeName));
+                }
+            } else {
+                return new NodeTypeId(new QName(qName.getNamespaceURI(), "Cache"));
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Converts idClass of non existing XML Definitions to compatible YAML id Classes
+     *
+     * @param idClasses id Class of target
+     * @return converted id Classes
+     **/
+    @SuppressWarnings("unchecked")
+    private <T extends DefinitionsChildId> List<Class<T>> convertDefinitionsChildIdIfNeeded(List<Class<T>> idClasses) {
+        List<Class<T>> output = new ArrayList<>();
+        if (idClasses.size() == 1) {
+            Class<T> idClass = idClasses.get(0);
+            if (NodeTypeImplementationId.class.isAssignableFrom(idClass)) {
+                output.add((Class<T>) NodeTypeId.class);
+                return output;
+            } else if (RelationshipTypeImplementationId.class.isAssignableFrom(idClass)) {
+                output.add((Class<T>) RelationshipTypeId.class);
+                return output;
+            } else if (ArtifactTemplateId.class.isAssignableFrom(idClass)) {
+                output.add((Class<T>) NodeTypeId.class);
+                output.add((Class<T>) RelationshipTypeId.class);
+                return output;
+            }
+        }
+        return idClasses;
+    }
+
+    /**
+     * Checks if XML Definition in exists Artifact Templates are searched in Type
+     *
+     * @param id generic id of target
+     * @return boolean if target exists
+     **/
+    @Override
+    public boolean exists(GenericId id) {
+        Path targetPath = id2AbsolutePath(id);
+        if (id instanceof ArtifactTemplateId) {
+            GenericId convertedId = convertGenericId(id);
+            if (convertedId != null) {
+                String convertedFilename = BackendUtils.getFileNameOfDefinitions((DefinitionsChildId) convertedId);
+                targetPath = targetPath.resolve(convertedFilename);
+                return chechIfArtifactTemplateExists(targetPath, ((ArtifactTemplateId) id).getQName());
+            }
+        }
+        return Files.exists(targetPath);
+    }
+
+    /**
+     * Checks if referenced File in exists Artifact Templates are searched in Type
+     *
+     * @param ref Repository File Reference
+     * @return boolean if target exists
+     **/
+    @Override
+    public boolean exists(RepositoryFileReference ref) {
+        Path targetPath = this.ref2AbsolutePath(ref);
+        if (ref.getParent() instanceof ArtifactTemplateId) {
+            if (Files.exists(targetPath)) {
+                return chechIfArtifactTemplateExists(targetPath, ((ArtifactTemplateId) ref.getParent()).getQName());
+            }
+        }
+        return Files.exists(targetPath);
+    }
+
+    /**
+     * Returns name of the artifact that is contained in the artifact name
+     *
+     * @param name name string
+     * @return artifact name
+     **/
+    private String getNameOfArtifactFromArtifactName(String name) {
+        Matcher nameMatcher = namePattern.matcher(name);
+        if (nameMatcher.matches()) {
+            return nameMatcher.group(1);
+        }
+        return name;
+    }
+
+    /**
+     * Returns name of the type that is contained in the artifact name
+     *
+     * @param name name string
+     * @return type name
+     **/
+    private String getNameOfTypeFromArtifactName(String name) {
+        Matcher nameMatcher = namePattern.matcher(name);
+        if (nameMatcher.matches()) {
+            return nameMatcher.group(2);
+        }
+        return "Cache";
+    }
+
+    /**
+     * Returns types main folder that is contained in the artifact name
+     *
+     * @param name name string
+     * @return folder name
+     **/
+    private String getTypeFromArtifactName(String name) {
+        Matcher nameMatcher = namePattern.matcher(name);
+        if (nameMatcher.matches()) {
+            return nameMatcher.group(3);
+        }
+        return "nodetypes";
+    }
+
+    /**
+     * Deletes referenced File Does not delete implementations anymore Deletes artifacts from there referenced type
+     *
+     * @param ref Repository File Reference
+     **/
+    @Override
+    public void forceDelete(RepositoryFileReference ref) throws IOException {
+        if (ref.getParent() instanceof NodeTypeImplementationId || ref.getParent() instanceof RelationshipTypeImplementationId) {
+            return;
+        }
+
+        if (ref.getParent() instanceof ArtifactTemplateId) {
+            deleteArtifact((ArtifactTemplateId) ref.getParent());
+        } else {
+            super.forceDelete(ref);
+        }
+    }
+
+    /**
+     * Deletes referenced Definition Does not delete implementations anymore Deletes artifacts from there referenced
+     * type
+     *
+     * @param id generic id
+     **/
+    @Override
+    public void forceDelete(GenericId id) {
+        if (id instanceof NodeTypeImplementationId || id instanceof RelationshipTypeImplementationId) {
+            return;
+        }
+        if (id instanceof ArtifactTemplateId) {
+            deleteArtifact((ArtifactTemplateId) id);
+        } else {
+            super.forceDelete(id);
+        }
+    }
+
+    /**
+     * Deletes artifacts from there referenced type
+     *
+     * @param id Artifact Template id
+     **/
+    private void deleteArtifact(ArtifactTemplateId id) {
+        if (getNameOfTypeFromArtifactName(id.getQName().getLocalPart()).equalsIgnoreCase("Cache")) {
+            super.forceDelete(id);
+        } else {
+            Path targetPath = id2AbsolutePath(id);
+            GenericId convertedId = convertGenericId(id);
+            if (convertedId != null) {
+                if (convertedId instanceof DefinitionsChildId) {
+                    String convertedFilename = BackendUtils.getFileNameOfDefinitions((DefinitionsChildId) convertedId);
+                    targetPath = targetPath.resolve(convertedFilename);
+                }
+            }
+
+            if (Files.exists(targetPath)) {
+                try {
+                    TServiceTemplate nodeType = readServiceTemplate(targetPath);
+                    String targetArtifactName = getNameOfArtifactFromArtifactName(id.getQName().getLocalPart());
+                    if (getTypeFromArtifactName(id.getQName().getLocalPart()).equalsIgnoreCase("nodetypes")) {
+                        Map<String, TArtifactDefinition> artifacts = nodeType.getNodeTypes().entrySet().iterator().next().getValue().getArtifacts();
+                        nodeType.getNodeTypes().entrySet().iterator().next().setValue(removeImplementation(nodeType.getNodeTypes().entrySet().iterator().next().getValue(), targetArtifactName));
+                        artifacts.remove(targetArtifactName);
+                        nodeType.getNodeTypes().entrySet().iterator().next().getValue().setArtifacts(artifacts);
+                    } else {
+                        nodeType.getRelationshipTypes().entrySet().iterator().next().setValue(removeRelationshipArtifact(nodeType.getRelationshipTypes().entrySet().iterator().next().getValue(), targetArtifactName));
+                    }
+                    Writer writer = new Writer();
+                    InputStream output = writer.writeToInputStream(nodeType);
+                    writeInputStreamToPath(targetPath, output);
+                } catch (Exception e) {
+                    LOGGER.error("Error deleting file: {}", e.getMessage(), e);
+                }
+            }
+        }
+    }
+
+    /**
+     * Deletes artifact from yaml relationship type
+     *
+     * @param relationshipType   TRelationshipType
+     * @param targetArtifactName targeted artifact name
+     * @return updated node type
+     **/
+    private TRelationshipType removeRelationshipArtifact(TRelationshipType relationshipType, String targetArtifactName) {
+        Map<String, TInterfaceDefinition> interfaces = relationshipType.getInterfaces();
+        if (interfaces != null) {
+            for (Map.Entry<String, TInterfaceDefinition> interfaceDefinition : interfaces.entrySet()) {
+                Map<String, TOperationDefinition> operations = interfaceDefinition.getValue().getOperations();
+                if (operations != null) {
+                    TOperationDefinition operationWithImplementation = operations.get(targetArtifactName);
+                    if (operationWithImplementation != null) {
+                        operationWithImplementation.setImplementation(null);
+                        operations.replace(targetArtifactName, operationWithImplementation);
+                    } else {
+                        for (Map.Entry<String, TOperationDefinition> operation : operations.entrySet()) {
+                            TOperationDefinition operationDefinition = operation.getValue();
+                            if (operationDefinition != null) {
+                                TImplementation implementation = operationDefinition.getImplementation();
+                                if (implementation != null) {
+                                    if (implementation.getPrimary() != null) {
+                                        if (implementation.getPrimary().getLocalPart().equalsIgnoreCase(targetArtifactName)) {
+                                            operationDefinition.setImplementation(null);
+                                        } else {
+                                            if (implementation.getDependencies() != null) {
+                                                List<QName> qNames = implementation.getDependencies();
+                                                for (QName name : implementation.getDependencies()) {
+                                                    if (name.getLocalPart().equalsIgnoreCase(targetArtifactName)) {
+                                                        qNames.remove(name);
+                                                    }
+                                                }
+                                                implementation.setDependencies(qNames);
+                                            }
+                                        }
+                                    }
+                                    operationDefinition.setImplementation(implementation);
+                                }
+                            }
+                            operation.setValue(operationDefinition);
+                        }
+                    }
+                }
+                TInterfaceDefinition tInterfaceDefinition = interfaceDefinition.getValue();
+                tInterfaceDefinition.setOperations(operations);
+                interfaceDefinition.setValue(tInterfaceDefinition);
+            }
+            relationshipType.setInterfaces(interfaces);
+        }
+        return relationshipType;
+    }
+
+    /**
+     * Deletes artifact from yaml node type interfaces
+     *
+     * @param nodeType           TNodeType
+     * @param targetArtifactName targeted artifact name
+     * @return updated node type
+     **/
+    private TNodeType removeImplementation(TNodeType nodeType, String targetArtifactName) {
+        Map<String, TInterfaceDefinition> interfaces = nodeType.getInterfaces();
+        if (interfaces != null) {
+            for (Map.Entry<String, TInterfaceDefinition> interfaceDefinition : interfaces.entrySet()) {
+                Map<String, TOperationDefinition> operations = interfaceDefinition.getValue().getOperations();
+                if (operations != null) {
+                    for (Map.Entry<String, TOperationDefinition> operation : operations.entrySet()) {
+                        TOperationDefinition operationDefinition = operation.getValue();
+                        if (operationDefinition != null) {
+                            TImplementation implementation = operationDefinition.getImplementation();
+                            if (implementation != null) {
+                                if (implementation.getPrimary() != null) {
+                                    if (implementation.getPrimary().getLocalPart().equalsIgnoreCase(targetArtifactName)) {
+                                        operationDefinition.setImplementation(null);
+                                    } else {
+                                        if (implementation.getDependencies() != null) {
+                                            List<QName> qNames = implementation.getDependencies();
+                                            for (QName name : implementation.getDependencies()) {
+                                                if (name.getLocalPart().equalsIgnoreCase(targetArtifactName)) {
+                                                    qNames.remove(name);
+                                                }
+                                            }
+                                            implementation.setDependencies(qNames);
+                                        }
+                                    }
+                                }
+                                operationDefinition.setImplementation(implementation);
+                            }
+                        }
+                        operation.setValue(operationDefinition);
+                    }
+                }
+                TInterfaceDefinition tInterfaceDefinition = interfaceDefinition.getValue();
+                tInterfaceDefinition.setOperations(operations);
+                interfaceDefinition.setValue(tInterfaceDefinition);
+            }
+            nodeType.setInterfaces(interfaces);
+        }
+        return nodeType;
+    }
+
+    /**
+     * Gets yaml service template from ref and converts it to xml definitions
+     *
+     * @param ref Repository File Reference
+     * @return xml definitions
+     **/
+    @Override
+    public Definitions definitionsFromRef(RepositoryFileReference ref) throws IOException {
+        Path targetPath = this.ref2AbsolutePath(ref);
+        if (ref.getParent() instanceof DefinitionsChildId) {
+            try {
+                QName name = ((DefinitionsChildId) ref.getParent()).getQName();
+                Definitions definitions = convertToDefinitions(targetPath, name.getLocalPart(), name.getNamespaceURI());
+                return getRequestedDefinition((DefinitionsChildId) ref.getParent(), definitions);
+            } catch (MultiException e) {
+                LOGGER.debug("Internal error", e);
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Parses only requested Definition from converted yaml service template
+     *
+     * @param id          Definitions Child id
+     * @param definitions converted definitions
+     * @return requested definitions
+     **/
+    private Definitions getRequestedDefinition(DefinitionsChildId id, Definitions definitions) {
+        if (id instanceof ArtifactTemplateId) {
+            String artifactName = getNameOfArtifactFromArtifactName(id.getQName().getLocalPart());
+            List<TArtifactTemplate> artifactTemplates = definitions.getArtifactTemplates();
+            List<TArtifactTemplate> requestedArtifactTemplates = new ArrayList<>();
+            for (TArtifactTemplate artifactTemplate : artifactTemplates) {
+                if (artifactTemplate.getId().equalsIgnoreCase(artifactName)) {
+                    requestedArtifactTemplates.add(artifactTemplate);
+                    Definitions.Builder requestedDefinitions = getEmptyDefinition(definitions);
+                    requestedDefinitions.addArtifactTemplates(requestedArtifactTemplates);
+                    return requestedDefinitions.build();
+                }
+            }
+            // we did not find the artifact template id (this should not happen!)
+            LOGGER.error("requested artifact template id (" + id.toReadableString() + ") cannot be extracted from definitions object!");
+            return definitions;
+        } else {
+            Definitions.Builder requestedDefinitions = getEmptyDefinition(definitions);
+
+            if (id instanceof NodeTypeId) {
+                requestedDefinitions.addNodeTypes(definitions.getNodeTypes());
+            } else if (id instanceof RelationshipTypeId) {
+                requestedDefinitions.addRelationshipTypes(definitions.getRelationshipTypes());
+            } else if (id instanceof NodeTypeImplementationId) {
+                requestedDefinitions.addNodeTypeImplementations(definitions.getNodeTypeImplementations());
+            } else if (id instanceof RelationshipTypeImplementationId) {
+                requestedDefinitions.addRelationshipTypeImplementations(definitions.getRelationshipTypeImplementations());
+            } else if (id instanceof ArtifactTypeId) {
+                requestedDefinitions.addArtifactTypes(definitions.getArtifactTypes());
+            } else if (id instanceof CapabilityTypeId) {
+                requestedDefinitions.addCapabilityTypes(definitions.getCapabilityTypes());
+            } else if (id instanceof RequirementTypeId) {
+                requestedDefinitions.addRequirementTypes(definitions.getRequirementTypes());
+            } else if (id instanceof PolicyTypeId) {
+                requestedDefinitions.addPolicyTypes(definitions.getPolicyTypes());
+            } else {
+                // we do not need to filter anything
+                return definitions;
+            }
+
+            return requestedDefinitions.build();
+        }
+    }
+
+    /**
+     * Creates empty definition to add requested definition later
+     *
+     * @param definitions converted definitions
+     * @return empty definition builder
+     **/
+    private Definitions.Builder getEmptyDefinition(Definitions definitions) {
+        return (new Definitions.Builder(definitions.getId(), definitions.getTargetNamespace()
+        ));
+    }
+
+    /**
+     * Checks if artifact templates exists in type
+     *
+     * @param targetPath target path of requested type
+     * @param qName      target QName
+     * @return boolean if it was found
+     **/
+    private boolean chechIfArtifactTemplateExists(Path targetPath, QName qName) {
+        try {
+            Definitions xmlDefinitions = convertToDefinitions(targetPath, getNameOfTypeFromArtifactName(qName.getLocalPart()), qName.getNamespaceURI());
+            List<TArtifactTemplate> artifacts = xmlDefinitions.getArtifactTemplates();
+            if (artifacts != null) {
+                for (TArtifactTemplate artifact : artifacts) {
+                    if (artifact.getId().equalsIgnoreCase(getNameOfArtifactFromArtifactName(qName.getLocalPart()))) {
+                        return true;
+                    }
+                }
+            }
+        } catch (IOException | MultiException e) {
+            LOGGER.debug("Internal error", e);
+        }
+        return false;
+    }
+
+    /**
+     * Reads service template from target path and converts it to XML Definition
+     *
+     * @param targetPath      target path of service template
+     * @param id              id of requested Definition
+     * @param targetNamespace targetNamespace of requested Definition
+     * @return xml definitions
+     **/
+    private Definitions convertToDefinitions(Path targetPath, String id, String targetNamespace) throws IOException, MultiException {
+        TServiceTemplate serviceTemplate = readServiceTemplate(targetPath);
+        Y2XConverter converter = new Y2XConverter();
+        return converter.convert(serviceTemplate, id, targetNamespace);
+    }
+
+    /**
+     * Reads service template from target path
+     *
+     * @param targetPath target path of service template
+     * @return yaml service template
+     **/
+    private TServiceTemplate readServiceTemplate(Path targetPath) throws IOException, MultiException {
+        InputStream in = newInputStream(targetPath);
+        return new Reader().parse(in);
+    }
+
+    /**
+     * Reads service template from referenced definition
+     *
+     * @param ref repository file reference
+     * @return yaml service template
+     **/
+    private TServiceTemplate readServiceTemplate(RepositoryFileReference ref) throws IOException, MultiException {
+        Path targetPath = ref2AbsolutePath(ref);
+        InputStream in = newInputStream(targetPath);
+        return new Reader().parse(in);
+    }
+
+    /**
+     * Converts incoming xml definitions input stream to xml definitions
+     *
+     * @param inputStream xml input stream
+     * @return xml definitions
+     **/
+    private Definitions readInputStream(InputStream inputStream) throws JAXBException {
+        JAXBContext jaxbContext = JAXBContext.newInstance(Definitions.class);
+        Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
+        return (Definitions) unmarshaller.unmarshal(inputStream);
+    }
+
+    /**
+     * Gets all artifact names from targeted type
+     *
+     * @param target          target path of service template
+     * @param idClass         id Class of requested Definition
+     * @param targetNamespace targetNamespace of requested Definition
+     * @return list of strings
+     **/
+    private <T extends DefinitionsChildId> List<String> getAllArtifactNamesFromType(Path target, Class<T> idClass, String targetNamespace) {
+        List<String> output = new ArrayList<>();
+        try {
+            String fileName = BackendUtils.getFileNameOfDefinitions(idClass);
+            String id = target.getFileName().toString();
+            target = target.resolve(fileName);
+            Definitions definitions = convertToDefinitions(target, id, targetNamespace);
+            List<TArtifactTemplate> artifactTemplates = definitions.getArtifactTemplates();
+            if (artifactTemplates != null) {
+                for (TArtifactTemplate artifactTemplate : artifactTemplates) {
+                    output.add(artifactTemplate.getId() + "@" + id);
+                }
+            }
+        } catch (MultiException | IOException e) {
+            LOGGER.debug("Internal error", e);
+        }
+        return output;
+    }
+
+    /**
+     * Converts incoming xml input stream to yaml service tempalte and writes it to file
+     *
+     * @param ref         repository file reference
+     * @param inputStream input stream to write to file
+     * @param mediaType   Media Type
+     **/
+    @Override
+    public void putContentToFile(RepositoryFileReference ref, InputStream inputStream, MediaType mediaType) throws IOException {
+//        if (mediaType == null) {
+//            // quick hack for storing mime type called this method
+//            assert (ref.getFileName().endsWith(Constants.SUFFIX_MIMETYPE));
+//            // we do not need to store the mime type of the file containing the mime type information
+//        } else {
+//            this.setMimeType(ref, mediaType);
+//        }
+        Path targetPath = this.ref2AbsolutePath(ref);
+        inputStream = convertToServiceTemplate(ref, inputStream, mediaType);
+        writeInputStreamToPath(targetPath, inputStream);
+        if (ref.getParent() instanceof NodeTypeImplementationId || ref.getParent() instanceof RelationshipTypeImplementationId) {
+            clearCache();
+        }
+    }
+
+    /**
+     * Reads xml definition input stream converts it to yaml service template and writes it to input stream
+     *
+     * @param ref         Repository File Reference
+     * @param inputStream Input Stream
+     * @return yaml service template input stream
+     **/
+    private InputStream convertToServiceTemplate(RepositoryFileReference ref, InputStream inputStream, MediaType mediaType) {
+
+        //ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+        if (mediaType.equals(MediaTypes.MEDIATYPE_TOSCA_DEFINITIONS)) {
+            try {
+                //IOUtils.copy(inputStream, outputStream);
+                //Definitions definitions = readInputStream(new ByteArrayInputStream(outputStream.toByteArray()));
+                Definitions definitions = (Definitions) JAXBSupport.createUnmarshaller().unmarshal(inputStream);
+
+                X2YConverter converter = new X2YConverter(this);
+                TServiceTemplate serviceTemplate;
+                if (ref.getParent() instanceof NodeTypeImplementationId) {
+                    serviceTemplate = readServiceTemplate(ref);
+                    serviceTemplate = converter.convertNodeTypeImplementation(serviceTemplate, definitions.getNodeTypeImplementations().get(0));
+                } else if (ref.getParent() instanceof RelationshipTypeImplementationId) {
+                    serviceTemplate = readServiceTemplate(ref);
+                    serviceTemplate = converter.convertRelationshipTypeImplementation(serviceTemplate, definitions.getRelationshipTypeImplementations().get(0));
+                } else if (ref.getParent() instanceof NodeTypeId) {
+                    serviceTemplate = converter.convert(definitions);
+                    if (exists(ref)) {
+                        TServiceTemplate oldServiceTemplate = readServiceTemplate(ref);
+                        serviceTemplate = replaceOldWithNewData(serviceTemplate, oldServiceTemplate);
+                    }
+                } else if (ref.getParent() instanceof RelationshipTypeId) {
+                    serviceTemplate = converter.convert(definitions);
+                    if (exists(ref)) {
+                        TServiceTemplate oldServiceTemplate = readServiceTemplate(ref);
+                        serviceTemplate = replaceOldRelationshipTypeithNewData(serviceTemplate, oldServiceTemplate);
+                    }
+                } else if (ref.getParent() instanceof ArtifactTemplateId) {
+                    ArtifactTemplateId id = (ArtifactTemplateId) ref.getParent();
+                    TArtifactTemplate artifactTemplate = definitions.getArtifactTemplates().get(0);
+                    TArtifactDefinition artifact = converter.convertArtifactTemplate(artifactTemplate);
+                    List<TMapImportDefinition> imports = converter.convertImports();
+                    Path targetPath = ref2AbsolutePath(ref);
+                    if (Files.exists(targetPath)) {
+                        serviceTemplate = readServiceTemplate(targetPath);
+                        if (serviceTemplate == null) {
+                            serviceTemplate = createNewCacheNodeTypeWithArtifact(ref, artifactTemplate, artifact, imports);
+                        } else if (getTypeFromArtifactName(id.getQName().getLocalPart()).equalsIgnoreCase("nodetypes")) {
+                            TNodeType nodeType = serviceTemplate.getNodeTypes().entrySet().iterator().next().getValue();
+                            Map<String, TArtifactDefinition> artifacts = nodeType.getArtifacts();
+                            if (artifacts.containsKey(artifactTemplate.getIdFromIdOrNameField())) {
+                                artifacts.replace(artifactTemplate.getIdFromIdOrNameField(), artifact);
+                            } else {
+                                artifacts.put(artifactTemplate.getIdFromIdOrNameField(), artifact);
+                            }
+                            nodeType.setArtifacts(artifacts);
+                            serviceTemplate.getNodeTypes().entrySet().iterator().next().setValue(nodeType);
+                            serviceTemplate.setImports(addImports(serviceTemplate.getImports(), imports));
+                        } else {
+                            TRelationshipType relationshipType = serviceTemplate.getRelationshipTypes().entrySet().iterator().next().getValue();
+                            Map<String, TInterfaceDefinition> interfaceDefinitionMap = relationshipType.getInterfaces();
+                            relationshipType.setInterfaces(addArtifactToInterfaces(interfaceDefinitionMap, artifact, artifactTemplate.getIdFromIdOrNameField()));
+                        }
+                    } else {
+                        serviceTemplate = createNewCacheNodeTypeWithArtifact(ref, artifactTemplate, artifact, imports);
+                    }
+                } else {
+                    serviceTemplate = converter.convert(definitions);
+                }
+                Writer writer = new Writer();
+                return writer.writeToInputStream(serviceTemplate);
+            } catch (Exception e) {
+                LOGGER.error("Error converting service template. Reason: {}", e.getMessage(), e);
+            }
+            return null;
+        } else {
+            return inputStream;
+        }
+    }
+
+    /**
+     * Adds artifact to interface for implementation artifact
+     *
+     * @param interfaces interfaces of type
+     * @param id         name of artifact
+     * @param artifact   artifact
+     * @return edited interfaces
+     **/
+    private Map<String, TInterfaceDefinition> addArtifactToInterfaces(Map<String, TInterfaceDefinition> interfaces, TArtifactDefinition artifact, String id) {
+        if (artifact.getFiles().isEmpty()) {
+            return interfaces;
+        }
+        for (Map.Entry<String, TInterfaceDefinition> interfaceDefinitionEntry : interfaces.entrySet()) {
+            interfaceDefinitionEntry.setValue(addArtifactFileToTargetOperation(interfaceDefinitionEntry.getValue(), artifact, id));
+        }
+        return interfaces;
+    }
+
+    /**
+     * Adds artifacts filepath to interfaces for relationship type artifact templates
+     *
+     * @param interfaces interfaces of type
+     * @param target     name of artifact
+     * @param artifact   artifact
+     * @return edited interfaces
+     **/
+    private TInterfaceDefinition addArtifactFileToTargetOperation(TInterfaceDefinition interfaces, TArtifactDefinition artifact, String target) {
+        Map<String, TOperationDefinition> operations = interfaces.getOperations();
+        for (Map.Entry<String, TOperationDefinition> operation : operations.entrySet()) {
+            if (operation.getKey().equalsIgnoreCase(target)) {
+                TImplementation implementation = operation.getValue().getImplementation();
+                implementation.setPrimary(new QName(artifact.getFiles().get(0)));
+                TOperationDefinition operationDefinition = operation.getValue();
+                operationDefinition.setImplementation(implementation);
+                operation.setValue(operationDefinition);
+            } else {
+                TOperationDefinition operationDefinition = operation.getValue();
+                if (operationDefinition.getImplementation() != null) {
+                    if (operationDefinition.getImplementation().getPrimary() != null) {
+                        if (operationDefinition.getImplementation().getPrimary().getLocalPart().equalsIgnoreCase(target)) {
+                            TImplementation implementation = operationDefinition.getImplementation();
+                            implementation.setPrimary(new QName(artifact.getFiles().get(0)));
+                            operationDefinition.setImplementation(implementation);
+                        }
+                    }
+                }
+                operation.setValue(operationDefinition);
+            }
+        }
+        interfaces.setOperations(operations);
+        return interfaces;
+    }
+
+    /**
+     * Adds new import to existing imports
+     *
+     * @param oldImports existing imports
+     * @param newImport  new import
+     * @return edited imports
+     **/
+    private List<TMapImportDefinition> addImports(List<TMapImportDefinition> oldImports, List<TMapImportDefinition> newImport) {
+        if (newImport.isEmpty()) {
+            return oldImports;
+        }
+        if (newImport.get(0).isEmpty()) {
+            return oldImports;
+        }
+        Map.Entry<String, TImportDefinition> targetImport = newImport.get(0).entrySet().iterator().next();
+        for (TMapImportDefinition tMapImportDefinition : oldImports) {
+            for (Map.Entry<String, TImportDefinition> tImportDefinitionEntry : tMapImportDefinition.entrySet()) {
+                if (tImportDefinitionEntry.getKey().equalsIgnoreCase(targetImport.getKey())) {
+                    if (tImportDefinitionEntry.getValue().equals(targetImport.getValue())) {
+                        return oldImports;
+                    }
+                }
+            }
+        }
+        oldImports.get(0).put(targetImport.getKey(), targetImport.getValue());
+        return oldImports;
+    }
+
+    /**
+     * Creates new cache node type and saves artifact until it's referenced
+     *
+     * @param ref              repository file reference
+     * @param artifactTemplate new artifact template
+     * @param artifact         yaml artifact
+     * @param imports          imports
+     * @return new yaml service template
+     **/
+    private TServiceTemplate createNewCacheNodeTypeWithArtifact(RepositoryFileReference ref, TArtifactTemplate artifactTemplate, TArtifactDefinition artifact, List<TMapImportDefinition> imports) {
+        TServiceTemplate serviceTemplate = createEmptyCacheNodeType(((ArtifactTemplateId) ref.getParent()).getQName().getNamespaceURI());
+        Map<String, TArtifactDefinition> artifacts = new LinkedHashMap<>();
+        artifacts.put(artifactTemplate.getIdFromIdOrNameField(), artifact);
+        serviceTemplate.getNodeTypes().entrySet().iterator().next().getValue().setArtifacts(artifacts);
+        serviceTemplate.setImports(imports);
+        return serviceTemplate;
+    }
+
+    /**
+     * Creates new cache node type to save artifact until it's referenced
+     *
+     * @param targetNamespace target Namespace of cache node type
+     * @return new yaml service template
+     **/
+    private TServiceTemplate createEmptyCacheNodeType(String targetNamespace) {
+        return new TServiceTemplate.Builder(Defaults.TOSCA_DEFINITIONS_VERSION)
+            .setNodeType("Cache", (new TNodeType.Builder().addMetadata("targetNamespace", targetNamespace).build()))
+            .build();
+    }
+
+    /**
+     * Clears cache Checks if Cache node types can get deleted
+     **/
+    private void clearCache() {
+        SortedSet<ArtifactTemplateId> artifacts = getAllDefinitionsChildIds(ArtifactTemplateId.class);
+        for (ArtifactTemplateId artifact : artifacts) {
+            if (getNameOfTypeFromArtifactName(artifact.getQName().getLocalPart()).equalsIgnoreCase("cache")) {
+                for (ArtifactTemplateId otherArtifact : artifacts) {
+                    if (otherArtifact.getQName().getNamespaceURI().equalsIgnoreCase(artifact.getQName().getNamespaceURI())
+                        && getNameOfArtifactFromArtifactName(otherArtifact.getQName().getLocalPart()).equalsIgnoreCase(getNameOfArtifactFromArtifactName(artifact.getQName().getLocalPart()))
+                        && !getNameOfTypeFromArtifactName(otherArtifact.getQName().getLocalPart()).equalsIgnoreCase("cache")) {
+                        forceDelete(artifact);
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Replaces old data of yaml node type with new data from xml node type to prevent deletion of implementation
+     * artifacts
+     *
+     * @param newData new saved node type
+     * @param oldData already saved node type
+     * @return edited yaml service template
+     **/
+    private TServiceTemplate replaceOldWithNewData(TServiceTemplate newData, TServiceTemplate oldData) {
+        TNodeType oldNodeType = oldData.getNodeTypes().entrySet().iterator().next().getValue();
+        TNodeType newNodeType = newData.getNodeTypes().entrySet().iterator().next().getValue();
+        oldNodeType.setMetadata(newNodeType.getMetadata());
+        oldNodeType.setProperties(newNodeType.getProperties());
+        oldNodeType.setDerivedFrom(newNodeType.getDerivedFrom());
+        oldNodeType.setDescription(newNodeType.getDescription());
+        oldNodeType.setRequirements(newNodeType.getRequirements());
+        oldNodeType.setCapabilities(newNodeType.getCapabilities());
+        oldNodeType.setInterfaces(replaceInterfaceDefinitions(oldNodeType.getInterfaces(), newNodeType.getInterfaces()));
+        oldData.getNodeTypes().entrySet().iterator().next().setValue(oldNodeType);
+        return oldData;
+    }
+
+    /**
+     * Replaces old data of yaml relationship type with new data from xml relationship type to prevent deletion of
+     * implementation artifacts
+     *
+     * @param newData new saved relationship type
+     * @param oldData already saved relationship type
+     * @return edited yaml service template
+     **/
+    private TServiceTemplate replaceOldRelationshipTypeithNewData(TServiceTemplate newData, TServiceTemplate oldData) {
+        TRelationshipType oldRelationshipType = oldData.getRelationshipTypes().entrySet().iterator().next().getValue();
+        TRelationshipType newRelationshipType = newData.getRelationshipTypes().entrySet().iterator().next().getValue();
+        oldRelationshipType.setMetadata(newRelationshipType.getMetadata());
+        oldRelationshipType.setProperties(newRelationshipType.getProperties());
+        oldRelationshipType.setDerivedFrom(newRelationshipType.getDerivedFrom());
+        oldRelationshipType.setDescription(newRelationshipType.getDescription());
+        oldRelationshipType.setInterfaces(replaceInterfaceDefinitions(oldRelationshipType.getInterfaces(), newRelationshipType.getInterfaces()));
+        oldData.getRelationshipTypes().entrySet().iterator().next().setValue(oldRelationshipType);
+        return oldData;
+    }
+
+    /**
+     * Saves already defined interface implementations to be deleted by transmitting them to the new interfaces
+     *
+     * @param oldInterfaces existing interfaces
+     * @param newInterfaces new interfaces
+     * @return edited yaml service template
+     **/
+    private Map<String, TInterfaceDefinition> replaceInterfaceDefinitions(Map<String, TInterfaceDefinition> oldInterfaces, Map<String, TInterfaceDefinition> newInterfaces) {
+        for (Map.Entry<String, TInterfaceDefinition> oldInterface : oldInterfaces.entrySet()) {
+            TInterfaceDefinition newInterfaceDefinition = newInterfaces.get(oldInterface.getKey());
+            if (newInterfaceDefinition != null) {
+                Map<String, TOperationDefinition> oldOperationDefinitions = oldInterface.getValue().getOperations();
+                Map<String, TOperationDefinition> newOperationDefinitions = newInterfaceDefinition.getOperations();
+                for (Map.Entry<String, TOperationDefinition> oldOperationDefinition : oldOperationDefinitions.entrySet()) {
+                    TOperationDefinition newOperationDefinition = newOperationDefinitions.get(oldOperationDefinition.getKey());
+                    if (newOperationDefinition != null) {
+                        newOperationDefinition.setImplementation(oldOperationDefinition.getValue().getImplementation());
+                        newOperationDefinitions.remove(oldOperationDefinition.getKey());
+                        newOperationDefinitions.put(oldOperationDefinition.getKey(), newOperationDefinition);
+                    }
+                }
+                newInterfaceDefinition.setOperations(newOperationDefinitions);
+            }
+            newInterfaces.remove(oldInterface.getKey());
+            newInterfaces.put(oldInterface.getKey(), newInterfaceDefinition);
+        }
+        return newInterfaces;
+    }
+
+    /**
+     * Creates Set of Definitions Child Id Mapps xml definition to compatible yaml definition
+     *
+     * @param inputIdClass            requested id class
+     * @param omitDevelopmentVersions omit development versions
+     * @return set of definitions child id
+     **/
+    @Override
+    public <T extends DefinitionsChildId> SortedSet<T> getDefinitionsChildIds(Class<T> inputIdClass, boolean omitDevelopmentVersions) {
+        SortedSet<T> res = new TreeSet<>();
+        List<Class<T>> idClasses = new ArrayList<>();
+        idClasses.add(inputIdClass);
+        idClasses = convertDefinitionsChildIdIfNeeded(idClasses);
+        for (Class<T> idClass : idClasses) {
+            String rootPathFragment = Util.getRootPathFragment(idClass);
+            Path dir = this.getRepositoryRoot().resolve(rootPathFragment);
+            if (!Files.exists(dir)) {
+                // return empty list if no ids are available
+                return res;
+            }
+            assert (Files.isDirectory(dir));
+
+            final OnlyNonHiddenDirectories onhdf = new OnlyNonHiddenDirectories();
+
+            // list all directories contained in this directory
+            try (DirectoryStream<Path> ds = Files.newDirectoryStream(dir, onhdf)) {
+                for (Path nsP : ds) {
+                    // the current path is the namespace
+                    Namespace ns = new Namespace(nsP.getFileName().toString(), true);
+                    try (DirectoryStream<Path> idDS = Files.newDirectoryStream(nsP, onhdf)) {
+                        for (Path idP : idDS) {
+
+                            List<XmlId> xmlIds = new ArrayList<>();
+                            if (ArtifactTemplateId.class.isAssignableFrom(inputIdClass)) {
+                                List<String> artifactNames = getAllArtifactNamesFromType(idP, idClass, ns.getDecoded());
+                                for (String artifactName : artifactNames) {
+                                    xmlIds.add(new XmlId(artifactName + "@" + Util.getFolderName(idClass), true));
+                                }
+                            } else {
+                                xmlIds.add(new XmlId(idP.getFileName().toString(), true));
+                            }
+
+                            for (XmlId xmlId : xmlIds) {
+                                if (omitDevelopmentVersions) {
+                                    WineryVersion version = VersionUtils.getVersion(xmlId.getDecoded());
+
+                                    if (version.toString().length() > 0 && version.getWorkInProgressVersion() > 0) {
+                                        continue;
+                                    }
+                                }
+                                Constructor<T> constructor;
+                                try {
+                                    constructor = inputIdClass.getConstructor(Namespace.class, XmlId.class);
+                                } catch (Exception e) {
+                                    LOGGER.debug("Internal error at determining id constructor", e);
+                                    // abort everything, return invalid result
+                                    return res;
+                                }
+                                T id;
+                                try {
+                                    id = constructor.newInstance(ns, xmlId);
+                                } catch (InstantiationException
+                                    | IllegalAccessException
+                                    | IllegalArgumentException
+                                    | InvocationTargetException e) {
+                                    LOGGER.debug("Internal error at invocation of id constructor", e);
+                                    // abort everything, return invalid result
+                                    return res;
+                                }
+                                res.add(id);
+                            }
+                        }
+                    }
+                }
+            } catch (IOException e) {
+                LOGGER.debug("Cannot close ds", e);
+            }
+        }
+        return res;
+    }
+
+    @Override
+    public void getReferencedRequirementTypeIds(Collection<DefinitionsChildId> ids, TNodeTemplate n) {
+        // Do nothing. In Yaml mode, there are no requirement types!
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/X2YConverter.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/X2YConverter.java
new file mode 100644
index 000000000..f782a20c0
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/X2YConverter.java
@@ -0,0 +1,1035 @@
+/********************************************************************************
+ * Copyright (c) 2017-2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import javax.xml.namespace.QName;
+
+import org.eclipse.winery.common.ids.definitions.ArtifactTemplateId;
+import org.eclipse.winery.common.ids.definitions.ArtifactTypeId;
+import org.eclipse.winery.common.ids.definitions.CapabilityTypeId;
+import org.eclipse.winery.common.ids.definitions.DefinitionsChildId;
+import org.eclipse.winery.common.ids.definitions.NodeTypeId;
+import org.eclipse.winery.common.ids.definitions.NodeTypeImplementationId;
+import org.eclipse.winery.common.ids.definitions.PolicyTemplateId;
+import org.eclipse.winery.common.ids.definitions.PolicyTypeId;
+import org.eclipse.winery.common.ids.definitions.RelationshipTypeId;
+import org.eclipse.winery.common.ids.definitions.RelationshipTypeImplementationId;
+import org.eclipse.winery.common.ids.definitions.RequirementTypeId;
+import org.eclipse.winery.model.tosca.Definitions;
+import org.eclipse.winery.model.tosca.TArtifactReference;
+import org.eclipse.winery.model.tosca.TArtifactTemplate;
+import org.eclipse.winery.model.tosca.TBoolean;
+import org.eclipse.winery.model.tosca.TBoundaryDefinitions;
+import org.eclipse.winery.model.tosca.TCapability;
+import org.eclipse.winery.model.tosca.TDeploymentArtifact;
+import org.eclipse.winery.model.tosca.TDeploymentArtifacts;
+import org.eclipse.winery.model.tosca.TDocumentation;
+import org.eclipse.winery.model.tosca.TEntityTemplate;
+import org.eclipse.winery.model.tosca.TEntityType;
+import org.eclipse.winery.model.tosca.TImplementationArtifact;
+import org.eclipse.winery.model.tosca.TImplementationArtifacts;
+import org.eclipse.winery.model.tosca.TInterface;
+import org.eclipse.winery.model.tosca.TInterfaces;
+import org.eclipse.winery.model.tosca.TNodeTypeImplementation;
+import org.eclipse.winery.model.tosca.TOperation;
+import org.eclipse.winery.model.tosca.TParameter;
+import org.eclipse.winery.model.tosca.TPolicy;
+import org.eclipse.winery.model.tosca.TPolicyTemplate;
+import org.eclipse.winery.model.tosca.TRelationshipTypeImplementation;
+import org.eclipse.winery.model.tosca.TRequirement;
+import org.eclipse.winery.model.tosca.TRequirementType;
+import org.eclipse.winery.model.tosca.TTag;
+import org.eclipse.winery.model.tosca.TTags;
+import org.eclipse.winery.model.tosca.TTopologyTemplate;
+import org.eclipse.winery.model.tosca.kvproperties.PropertyDefinitionKV;
+import org.eclipse.winery.model.tosca.kvproperties.WinerysPropertiesDefinition;
+import org.eclipse.winery.model.tosca.utils.ModelUtilities;
+import org.eclipse.winery.model.tosca.yaml.TArtifactDefinition;
+import org.eclipse.winery.model.tosca.yaml.TArtifactType;
+import org.eclipse.winery.model.tosca.yaml.TCapabilityAssignment;
+import org.eclipse.winery.model.tosca.yaml.TCapabilityDefinition;
+import org.eclipse.winery.model.tosca.yaml.TCapabilityType;
+import org.eclipse.winery.model.tosca.yaml.TImplementation;
+import org.eclipse.winery.model.tosca.yaml.TImportDefinition;
+import org.eclipse.winery.model.tosca.yaml.TInterfaceDefinition;
+import org.eclipse.winery.model.tosca.yaml.TNodeTemplate;
+import org.eclipse.winery.model.tosca.yaml.TNodeType;
+import org.eclipse.winery.model.tosca.yaml.TOperationDefinition;
+import org.eclipse.winery.model.tosca.yaml.TPolicyDefinition;
+import org.eclipse.winery.model.tosca.yaml.TPolicyType;
+import org.eclipse.winery.model.tosca.yaml.TPropertyAssignment;
+import org.eclipse.winery.model.tosca.yaml.TPropertyAssignmentOrDefinition;
+import org.eclipse.winery.model.tosca.yaml.TPropertyDefinition;
+import org.eclipse.winery.model.tosca.yaml.TRelationshipAssignment;
+import org.eclipse.winery.model.tosca.yaml.TRelationshipDefinition;
+import org.eclipse.winery.model.tosca.yaml.TRelationshipTemplate;
+import org.eclipse.winery.model.tosca.yaml.TRelationshipType;
+import org.eclipse.winery.model.tosca.yaml.TRequirementAssignment;
+import org.eclipse.winery.model.tosca.yaml.TRequirementDefinition;
+import org.eclipse.winery.model.tosca.yaml.TServiceTemplate;
+import org.eclipse.winery.model.tosca.yaml.TSubstitutionMappings;
+import org.eclipse.winery.model.tosca.yaml.TTopologyTemplateDefinition;
+import org.eclipse.winery.model.tosca.yaml.support.Defaults;
+import org.eclipse.winery.model.tosca.yaml.support.Metadata;
+import org.eclipse.winery.model.tosca.yaml.support.TMapImportDefinition;
+import org.eclipse.winery.model.tosca.yaml.support.TMapRequirementAssignment;
+import org.eclipse.winery.model.tosca.yaml.support.TMapRequirementDefinition;
+import org.eclipse.winery.repository.backend.filebased.YamlRepository;
+import org.eclipse.winery.repository.backend.filebased.converter.support.Namespaces;
+import org.eclipse.winery.repository.backend.filebased.converter.support.ValueConverter;
+import org.eclipse.winery.repository.backend.filebased.converter.support.exception.MultiException;
+import org.eclipse.winery.repository.backend.filebased.converter.support.xml.TypeConverter;
+
+import org.eclipse.collections.impl.bimap.mutable.HashBiMap;
+import org.eclipse.jdt.annotation.NonNull;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class X2YConverter {
+    public final static Logger LOGGER = LoggerFactory.getLogger(X2YConverter.class);
+
+    private final YamlRepository repository;
+//    private final Path path;
+
+    private HashBiMap<String, String> prefixNamespace;
+    private Map<DefinitionsChildId, Definitions> importDefinitions;
+
+    public X2YConverter(YamlRepository repository) {
+        this.repository = repository;
+        this.prefixNamespace = new HashBiMap<>();
+        this.importDefinitions = new LinkedHashMap<>();
+    }
+
+    /**
+     * Converts TOSCA XML Definitions to TOSCA YAML ServiceTemplates
+     */
+    @NonNull
+    public TServiceTemplate convert(Definitions node) throws MultiException {
+
+        LOGGER.debug("Convert TServiceTemplate: {}", node.getIdFromIdOrNameField());
+
+        TServiceTemplate.Builder builder = new TServiceTemplate.Builder(Defaults.TOSCA_DEFINITIONS_VERSION)
+            .setDescription(convertDocumentation(node.getDocumentation()))
+            .setArtifactTypes(convert(node.getArtifactTypes()))
+            .setCapabilityTypes(convert(node.getCapabilityTypes()))
+            .setRelationshipTypes(convert(node.getRelationshipTypes()))
+            .setNodeTypes(convert(node.getNodeTypes()))
+            .setPolicyTypes(convert(node.getPolicyTypes()));
+
+        if (node.getServiceTemplates().size() == 1) {
+            builder.setTopologyTemplate(convert(node.getServiceTemplates().get(0)));
+//            if (Objects.nonNull(node.getServiceTemplates().get(0).getName())) {
+//                tmpName = new QName(node.getServiceTemplates().get(0).getName());
+//            }
+            builder.addMetadata("targetNamespace", node.getTargetNamespace());
+        }
+
+        builder.setImports(convertImports());
+
+        return builder.build();
+    }
+
+    public List<TMapImportDefinition> convertImports() {
+        List<TMapImportDefinition> imports = new ArrayList<>();
+        TMapImportDefinition tMapImportDefinition = new TMapImportDefinition();
+        for (Map.Entry<DefinitionsChildId, Definitions> importDefinition : importDefinitions.entrySet()) {
+            TImportDefinition tImportDefinition = new TImportDefinition.Builder(repository.id2AbsolutePath(importDefinition.getKey()).toString())
+                .setNamespacePrefix(getNamespacePrefix(importDefinition.getKey().getQName().getNamespaceURI()))
+                .setNamespaceUri(importDefinition.getKey().getQName().getNamespaceURI())
+                .build();
+            tMapImportDefinition.put(importDefinition.getKey().getQName().getLocalPart(), tImportDefinition);
+        }
+        if (!tMapImportDefinition.isEmpty()) {
+            imports.add(tMapImportDefinition);
+            return imports;
+        } else {
+            return null;
+        }
+    }
+
+    public Map<String, TPropertyAssignment> convert(TEntityTemplate tEntityTemplate, TEntityTemplate.Properties node) {
+        if (Objects.isNull(node)) return null;
+        Map<String, String> propertiesKV = ModelUtilities.getPropertiesKV(tEntityTemplate);
+        if (Objects.isNull(propertiesKV)) return null;
+        return propertiesKV.entrySet().stream()
+            .map(entry ->
+                new LinkedHashMap.SimpleEntry<>(
+                    String.valueOf(entry.getKey()),
+                    new TPropertyAssignment.Builder()
+                        .setValue("\"" + ValueConverter.INSTANCE.convert(entry.getValue()) + "\"")
+                        .build()
+                )
+            )
+            .collect(Collectors.toMap(
+                Map.Entry::getKey,
+                Map.Entry::getValue
+            ));
+    }
+
+    public TTopologyTemplateDefinition convert(org.eclipse.winery.model.tosca.TServiceTemplate node) {
+        if (Objects.isNull(node)) return null;
+        return convert(node.getTopologyTemplate(), node.getBoundaryDefinitions());
+    }
+
+    public TTopologyTemplateDefinition convert(TTopologyTemplate node, TBoundaryDefinitions boundary) {
+        if (Objects.isNull(node)) return null;
+        return new TTopologyTemplateDefinition.Builder()
+            .setDescription(convertDocumentation(node.getDocumentation()))
+            .setNodeTemplates(convert(node.getNodeTemplates(), node.getRelationshipTemplates()))
+            .setRelationshipTemplates(convert(node.getRelationshipTemplates()))
+            .setPolicies(convert(
+                node.getNodeTemplates().stream()
+                    .filter(Objects::nonNull)
+                    .map(org.eclipse.winery.model.tosca.TNodeTemplate::getPolicies)
+                    .filter(Objects::nonNull)
+                    .flatMap(p -> p.getPolicy().stream())
+                    .filter(Objects::nonNull)
+                    .collect(Collectors.toList())
+            ))
+            // TODO substitution mappings are currently not converted
+            //.setSubstitutionMappings(convert(boundary))
+            .build();
+    }
+
+    public Map<String, TNodeTemplate> convert(List<org.eclipse.winery.model.tosca.TNodeTemplate> nodes, List<org.eclipse.winery.model.tosca.TRelationshipTemplate> rTs) {
+        if (Objects.isNull(nodes)) return null;
+        return nodes.stream()
+            .filter(Objects::nonNull)
+            .flatMap(entry -> convert(entry, Optional.ofNullable(rTs).orElse(new ArrayList<>())).entrySet().stream())
+            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
+    }
+
+    @NonNull
+    public Map<String, TNodeTemplate> convert(org.eclipse.winery.model.tosca.TNodeTemplate node, @NonNull List<org.eclipse.winery.model.tosca.TRelationshipTemplate> rTs) {
+        if (Objects.isNull(node)) {
+            return new LinkedHashMap<>();
+        }
+        Metadata meta = new Metadata();
+        if (Objects.nonNull(node.getX()) && Objects.nonNull(node.getY())) {
+            meta.add(org.eclipse.winery.repository.backend.filebased.converter.support.Defaults.X_COORD, node.getX());
+            meta.add(org.eclipse.winery.repository.backend.filebased.converter.support.Defaults.Y_COORD, node.getY());
+        }
+
+        return Collections.singletonMap(
+            node.getIdFromIdOrNameField(),
+            new TNodeTemplate.Builder(
+                convert(
+                    node.getType(),
+                    new NodeTypeId(node.getType())
+                ))
+                .setProperties(convert(node, node.getProperties()))
+                .setMetadata(meta)
+                .setRequirements(convert(node.getRequirements()))
+                .setCapabilities(convert(node.getCapabilities()))
+                .setArtifacts(convert(node.getDeploymentArtifacts()))
+                .build()
+        );
+    }
+
+    @NonNull
+    public Map<String, TRelationshipTemplate> convert(org.eclipse.winery.model.tosca.TRelationshipTemplate node) {
+        if (Objects.isNull(node)) return new LinkedHashMap<>();
+        return Collections.singletonMap(
+            node.getIdFromIdOrNameField(),
+            new TRelationshipTemplate.Builder(convert(node.getType(), new RelationshipTypeId(node.getType())))
+                .setProperties(convert(node, node.getProperties()))
+                .build()
+        );
+    }
+
+    public <T extends org.eclipse.winery.model.tosca.yaml.TEntityType.Builder<T>> T convert(TEntityType node, T builder, Class<? extends TEntityType> clazz) {
+        return builder.setDescription(convertDocumentation(node.getDocumentation()))
+            .setDerivedFrom(convert(node.getDerivedFrom(), clazz))
+            .setMetadata(convert(node.getTags()))
+            .addMetadata("targetNamespace", node.getTargetNamespace())
+            .addMetadata("abstract", node.getAbstract().value())
+            .addMetadata("final", node.getFinal().value())
+            .setProperties(convert(node, node.getPropertiesDefinition()));
+    }
+
+    public Map<String, TPropertyDefinition> convert(TEntityType type, TEntityType.PropertiesDefinition node) {
+        // TODO convert properties beside simple winery properties
+        WinerysPropertiesDefinition properties = type.getWinerysPropertiesDefinition();
+        if (Objects.isNull(properties) ||
+            Objects.isNull(properties.getPropertyDefinitionKVList()) ||
+            properties.getPropertyDefinitionKVList().isEmpty()) return null;
+        return properties.getPropertyDefinitionKVList().stream()
+            .collect(Collectors.toMap(
+                PropertyDefinitionKV::getKey,
+                entry -> new TPropertyDefinition.Builder(convertType(entry.getType()))
+                    .setRequired(entry.isRequired())
+                    .setDefault(entry.getDefaultValue())
+                    .setDescription(entry.getDescription())
+                    .build()
+            ));
+    }
+
+    public Map<String, TArtifactType> convert(org.eclipse.winery.model.tosca.TArtifactType node) {
+        return Collections.singletonMap(
+            node.getIdFromIdOrNameField(),
+            convert(node, new TArtifactType.Builder(), org.eclipse.winery.model.tosca.TArtifactType.class).build()
+        );
+    }
+
+    public Map<String, TNodeType> convert(org.eclipse.winery.model.tosca.TNodeType node) {
+        if (Objects.isNull(node)) return null;
+        // TNodeTypeImplementation impl = getNodeTypeImplementation(new QName(node.getTargetNamespace(), node.getName()));
+
+        String nodeFullName = node.getIdFromIdOrNameField();
+        if (node.getTargetNamespace() != null) {
+            nodeFullName = node.getTargetNamespace().concat(".").concat(node.getIdFromIdOrNameField());
+        }
+
+        return Collections.singletonMap(
+            nodeFullName,
+            convert(node, new TNodeType.Builder(), org.eclipse.winery.model.tosca.TNodeType.class)
+                .setRequirements(convert(node.getRequirementDefinitions()))
+                .setCapabilities(convert(node.getCapabilityDefinitions()))
+                .setInterfaces(convert(node.getInterfaces()))
+                .build()
+        );
+    }
+
+    public Map<String, TArtifactDefinition> convert(TNodeTypeImplementation node, Map<String, TArtifactDefinition> artifacts) {
+        if (Objects.isNull(node)) return null;
+        String suffix = "@" + node.getNodeType().getLocalPart() + "@" + "nodetypes";
+        return Stream.of(convert(node.getDeploymentArtifacts(), artifacts), convert(node.getImplementationArtifacts(), artifacts))
+            .filter(Objects::nonNull)
+            .flatMap(entry -> entry.entrySet().stream())
+            .filter(Objects::nonNull)
+            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
+    }
+
+//    public Map<String, TRelationshipType> convert(org.eclipse.winery.model.tosca.TRelationshipType node) {
+//        if (Objects.isNull(node)) return null;
+//        // TODO Use TRelationshipTypeImplementation artifacts
+//        TRelationshipTypeImplementation impl = getRelationshipTypeImplementation(new QName(node.getTargetNamespace(), node.getName()));
+//        return Collections.singletonMap(
+//            node.getIdFromIdOrNameField(),
+//            convert(node, new TRelationshipType.Builder(), org.eclipse.winery.model.tosca.TRelationshipType.class)
+//                .addInterfaces(convert(node.getSourceInterfaces(), impl))
+//                .addInterfaces(convert(node.getTargetInterfaces(), impl))
+//                .build()
+//        );
+//    }
+
+    public Map<String, TRelationshipType> convert(org.eclipse.winery.model.tosca.TRelationshipType node) {
+        if (Objects.isNull(node)) return null;
+        return Collections.singletonMap(
+            node.getIdFromIdOrNameField(),
+            convert(node, new TRelationshipType.Builder(), org.eclipse.winery.model.tosca.TRelationshipType.class)
+                .addInterfaces(convert(node.getInterfaces()))
+                .addInterfaces(convert(node.getSourceInterfaces(), "SourceInterfaces"))
+                .addInterfaces(convert(node.getTargetInterfaces(), "TargetInterfaces"))
+                .addValidTargetTypes(convertTargets(node.getValidSource(), node.getValidTarget()))
+                .build()
+        );
+    }
+
+    private List<QName> convertTargets(org.eclipse.winery.model.tosca.TRelationshipType.ValidSource validSource, org.eclipse.winery.model.tosca.TRelationshipType.ValidTarget validTarget) {
+        if (validSource != null && validTarget != null) {
+            List<QName> output = new ArrayList<>();
+            output.add(new QName(validSource.getTypeRef().getNamespaceURI(), validSource.getTypeRef().getLocalPart()));
+            output.add(new QName(validTarget.getTypeRef().getNamespaceURI(), validSource.getTypeRef().getLocalPart()));
+            return output;
+        }
+        return null;
+    }
+
+    public Map<String, TInterfaceDefinition> convert(TInterfaces node, TRelationshipTypeImplementation implementation) {
+        if (Objects.isNull(node)) return null;
+        return node.getInterface().stream()
+            .filter(Objects::nonNull)
+            .map(entry -> convert(
+                entry,
+                Optional.ofNullable(implementation.getImplementationArtifacts()).orElse(new TImplementationArtifacts())
+                    .getImplementationArtifact().stream()
+                    .filter(impl -> Objects.nonNull(impl) && impl.getInterfaceName().equals(entry.getName()))
+                    .collect(Collectors.toList())
+                )
+            )
+            .flatMap(entry -> entry.entrySet().stream())
+            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
+    }
+
+    @NonNull
+    public Map<String, TCapabilityType> convert(org.eclipse.winery.model.tosca.TCapabilityType node) {
+        if (Objects.isNull(node)) return new LinkedHashMap<>();
+        return Collections.singletonMap(
+            node.getName(),
+            convert(node, new TCapabilityType.Builder(), org.eclipse.winery.model.tosca.TCapabilityType.class)
+                .addValidSourceTypes(node.getValidNodeTypes())
+                .build()
+        );
+    }
+
+    @NonNull
+    public Map<String, TPolicyType> convert(org.eclipse.winery.model.tosca.TPolicyType node) {
+        if (Objects.isNull(node)) return new LinkedHashMap<>();
+        return Collections.singletonMap(
+            node.getName(),
+            convert(node, new TPolicyType.Builder(), org.eclipse.winery.model.tosca.TPolicyType.class)
+                .build()
+        );
+    }
+
+    public TSubstitutionMappings convert(TBoundaryDefinitions node) {
+        if (Objects.isNull(node)) return null;
+        return new TSubstitutionMappings.Builder()
+            // TODO Convert Boundary definitions
+            .build();
+    }
+
+    @NonNull
+    public Map<String, TPolicyDefinition> convert(TPolicy node) {
+        if (Objects.isNull(node)) return new LinkedHashMap<>();
+        return Collections.singletonMap(
+            node.getName(),
+            new TPolicyDefinition.Builder(
+                convert(
+                    node.getPolicyType(),
+                    new PolicyTypeId(node.getPolicyRef())
+                ))
+                .setProperties(convertPropertyAssignment(repository.getElement(new PolicyTemplateId(node.getPolicyRef()))))
+                .build()
+        );
+    }
+
+    public Map<String, TPropertyAssignment> convertPropertyAssignment(TPolicyTemplate node) {
+        if (Objects.isNull(node)) return null;
+        return convert(node, node.getProperties());
+    }
+
+    /**
+     * Converts TOSCA XML list of Documentations to TOSCA YAML Description of type string
+     */
+    public String convertDocumentation(@NonNull List<TDocumentation> doc) {
+        return doc.stream()
+            .map(TDocumentation::getContent)
+            .flatMap(List::stream)
+            .map(Object::toString)
+            .collect(Collectors.joining("\n"));
+    }
+
+    public QName convert(TEntityType.DerivedFrom node, Class<? extends TEntityType> clazz) {
+        if (Objects.isNull(node)) return null;
+        DefinitionsChildId id;
+        if (clazz.equals(org.eclipse.winery.model.tosca.TNodeType.class)) {
+            id = new NodeTypeId(node.getTypeRef());
+        } else if (clazz.equals(org.eclipse.winery.model.tosca.TRelationshipType.class)) {
+            id = new RelationshipTypeId(node.getTypeRef());
+        } else if (clazz.equals(TRequirementType.class)) {
+            id = new RequirementTypeId(node.getTypeRef());
+        } else if (clazz.equals(org.eclipse.winery.model.tosca.TCapabilityType.class)) {
+            id = new CapabilityTypeId(node.getTypeRef());
+        } else if (clazz.equals(org.eclipse.winery.model.tosca.TArtifactType.class)) {
+            id = new ArtifactTypeId(node.getTypeRef());
+        } else {
+            id = new PolicyTypeId(node.getTypeRef());
+        }
+        return getQName(
+            id,
+            node.getTypeRef().getNamespaceURI(),
+            node.getTypeRef().getLocalPart());
+    }
+
+    public Metadata convert(TTags node) {
+        if (Objects.isNull(node)) return null;
+        return node.getTag().stream()
+            .filter(Objects::nonNull)
+            .collect(Collectors.toMap(
+                TTag::getName,
+                TTag::getValue,
+                (a, b) -> a + "|" + b,
+                Metadata::new));
+    }
+
+//    public Map<String, TInterfaceDefinition> convert(TInterfaces node) {
+//        if (Objects.isNull(node)) return null;
+//        return node.getInterface().stream()
+//            .filter(Objects::nonNull)
+//            .map(entry -> convert(entry)
+//            )
+//            .flatMap(entry -> entry.entrySet().stream())
+//            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
+//    }
+
+    public Map<String, TInterfaceDefinition> convert(TInterface node) {
+        if (Objects.isNull(node)) return new LinkedHashMap<>();
+        return Collections.singletonMap(
+            node.getName(),
+            new TInterfaceDefinition.Builder()
+                .setOperations(convertOperations(node.getOperation()))
+                .build()
+        );
+    }
+
+    public Map<String, TOperationDefinition> convertOperations(List<TOperation> nodes) {
+        if (Objects.isNull(nodes)) return null;
+        return nodes.stream()
+            .filter(Objects::nonNull)
+            .flatMap(node -> convert(node)
+                .entrySet().stream())
+            .filter(Objects::nonNull)
+            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
+    }
+
+    @NonNull
+    public Map<String, TOperationDefinition> convert(TOperation node) {
+        if (Objects.isNull(node)) return new LinkedHashMap<>();
+        return Collections.singletonMap(
+            node.getName(),
+            new TOperationDefinition.Builder()
+                .setInputs(convert(node.getInputParameters()))
+                .setOutputs(convert(node.getOutputParameters()))
+                .build()
+        );
+    }
+
+    public Map<String, TInterfaceDefinition> convert(TInterfaces node, TNodeTypeImplementation implementation) {
+        if (Objects.isNull(node)) return null;
+        return node.getInterface().stream()
+            .filter(Objects::nonNull)
+            .map(entry -> convert(
+                entry,
+                Optional.ofNullable(implementation.getImplementationArtifacts()).orElse(new TImplementationArtifacts())
+                    .getImplementationArtifact().stream()
+                    .filter(impl -> Objects.nonNull(impl) && impl.getInterfaceName().equals(entry.getName()))
+                    .collect(Collectors.toList())
+                )
+            )
+            .flatMap(entry -> entry.entrySet().stream())
+            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
+    }
+
+    @NonNull
+    public Map<String, TInterfaceDefinition> convert(TInterface node, @NonNull List<TImplementationArtifact> impl) {
+        if (Objects.isNull(node)) return new LinkedHashMap<>();
+        return Collections.singletonMap(
+            node.getName(),
+            new TInterfaceDefinition.Builder()
+                .setOperations(convertOperations(node.getOperation(), impl))
+                .build()
+        );
+    }
+
+    public Map<String, TOperationDefinition> convertOperations(List<TOperation> nodes, @NonNull List<TImplementationArtifact> impl) {
+        if (Objects.isNull(nodes)) return null;
+        return nodes.stream()
+            .filter(Objects::nonNull)
+            .flatMap(node -> convert(
+                node,
+                impl.stream()
+                    .filter(entry -> Objects.nonNull(entry)
+                        && Objects.nonNull(entry.getOperationName())
+                        && entry.getOperationName().equals(node.getName()))
+                    .collect(Collectors.toList())
+            ).entrySet().stream())
+            .filter(Objects::nonNull)
+            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
+    }
+
+    @NonNull
+    public Map<String, TOperationDefinition> convert(TOperation node, List<TImplementationArtifact> impl) {
+        if (Objects.isNull(node)) return new LinkedHashMap<>();
+        return Collections.singletonMap(
+            node.getName(),
+            new TOperationDefinition.Builder()
+                .setInputs(convert(node.getInputParameters()))
+                .setOutputs(convert(node.getOutputParameters()))
+//                .setImplementation(convertImplementation(impl))
+                .build()
+        );
+    }
+
+    public TServiceTemplate convertNodeTypeImplementation(TServiceTemplate type, TNodeTypeImplementation node) {
+        if (Objects.isNull(node)) return null;
+        TNodeType nodeType = type.getNodeTypes().entrySet().iterator().next().getValue();
+        nodeType.setArtifacts(convert(node, nodeType.getArtifacts()));
+        nodeType.setInterfaces(convertInterfaces(nodeType.getInterfaces(), node.getImplementationArtifacts()));
+        type.getNodeTypes().entrySet().iterator().next().setValue(nodeType);
+        type.setImports(addNewImports(type.getImports()));
+        return type;
+    }
+
+    public TServiceTemplate convertRelationshipTypeImplementation(TServiceTemplate type, TRelationshipTypeImplementation node) {
+        if (Objects.isNull(node)) return null;
+        TRelationshipType relationshipType = type.getRelationshipTypes().entrySet().iterator().next().getValue();
+        relationshipType.setInterfaces(convertRelationshipInterfaces(relationshipType.getInterfaces(), node.getImplementationArtifacts()));
+        type.getRelationshipTypes().entrySet().iterator().next().setValue(relationshipType);
+        return type;
+    }
+
+    private List<TMapImportDefinition> addNewImports(List<TMapImportDefinition> imports) {
+        List<TMapImportDefinition> newImportsList = convertImports();
+        if (newImportsList.isEmpty()) {
+            return imports;
+        }
+        if (imports.isEmpty()) {
+            return newImportsList;
+        }
+        TMapImportDefinition newImports = newImportsList.get(0);
+        TMapImportDefinition existingImports = imports.get(0);
+        for (Map.Entry<String, TImportDefinition> newImport : newImports.entrySet()) {
+            Boolean found = false;
+            for (Map.Entry<String, TImportDefinition> existingImport : existingImports.entrySet()) {
+                if (newImport.getKey().equalsIgnoreCase(existingImport.getKey()) && newImport.getValue().equals(existingImport.getValue())) {
+                    found = true;
+                }
+            }
+            if (!found) {
+                existingImports.put(newImport.getKey(), newImport.getValue());
+            }
+        }
+        imports.set(0, newImports);
+        return imports;
+    }
+
+    private Map<String, TInterfaceDefinition> convertRelationshipInterfaces(Map<String, TInterfaceDefinition> interfaces, TImplementationArtifacts implementationArtifacts) {
+        if (implementationArtifacts == null) {
+            return interfaces;
+        }
+        List<TImplementationArtifacts.ImplementationArtifact> listImplArt = implementationArtifacts.getImplementationArtifact();
+        for (TImplementationArtifacts.ImplementationArtifact implementationArtifact : listImplArt) {
+            TInterfaceDefinition selectedInterface = interfaces.get(implementationArtifact.getInterfaceName());
+            if (selectedInterface != null) {
+                TOperationDefinition operation = selectedInterface.getOperations().get(implementationArtifact.getOperationName());
+                operation.setImplementation(convertrelationshipImplementation(implementationArtifact, operation.getImplementation()));
+            }
+        }
+        return interfaces;
+    }
+
+    public TImplementation convertrelationshipImplementation(TImplementationArtifacts.ImplementationArtifact node, TImplementation implementation) {
+        if (Objects.isNull(node)) return null;
+        QName name = new QName(node.getArtifactRef().getLocalPart());
+        if (implementation.getPrimary() == null) {
+            implementation.setPrimary(name);
+            return implementation;
+        } else if (implementation.getPrimary().getLocalPart().equalsIgnoreCase("null")) {
+            implementation.setPrimary(name);
+            return implementation;
+        } else if (implementation.getPrimary().equals(name)) {
+            return implementation;
+        } else if (implementation.getDependencies() != null) {
+            if (implementation.getDependencies().contains(name)) {
+                return implementation;
+            } else {
+                List<QName> dependencies = implementation.getDependencies();
+                dependencies.add(name);
+                implementation.setDependencies(dependencies);
+                return implementation;
+            }
+        } else {
+            List<QName> dependencies = new ArrayList<>();
+            dependencies.add(name);
+            implementation.setDependencies(dependencies);
+            return implementation;
+        }
+    }
+
+    private Map<String, TInterfaceDefinition> convertInterfaces(Map<String, TInterfaceDefinition> interfaces, TImplementationArtifacts implementationArtifacts) {
+        if (implementationArtifacts == null) {
+            return interfaces;
+        }
+        List<TImplementationArtifacts.ImplementationArtifact> listImplArt = implementationArtifacts.getImplementationArtifact();
+        for (TImplementationArtifacts.ImplementationArtifact implementationArtifact : listImplArt) {
+            TInterfaceDefinition selectedInterface = interfaces.get(implementationArtifact.getInterfaceName());
+            if (selectedInterface != null) {
+                TOperationDefinition operation = selectedInterface.getOperations().get(implementationArtifact.getOperationName());
+                operation.setImplementation(convertImplementation(implementationArtifact, operation.getImplementation()));
+            }
+        }
+        return interfaces;
+    }
+
+    public TImplementation convertImplementation(TImplementationArtifacts.ImplementationArtifact node, TImplementation implementation) {
+        if (Objects.isNull(node)) return null;
+        QName name = new QName(node.getArtifactRef().getLocalPart());
+        if (implementation.getPrimary() == null) {
+            implementation.setPrimary(name);
+            return implementation;
+        } else if (implementation.getPrimary().getLocalPart().equalsIgnoreCase("null")) {
+            implementation.setPrimary(name);
+            return implementation;
+        } else if (implementation.getPrimary().equals(name)) {
+            return implementation;
+        } else if (implementation.getDependencies() != null) {
+            if (implementation.getDependencies().contains(name)) {
+                return implementation;
+            } else {
+                List<QName> dependencies = implementation.getDependencies();
+                dependencies.add(name);
+                implementation.setDependencies(dependencies);
+                return implementation;
+            }
+        } else {
+            List<QName> dependencies = new ArrayList<>();
+            dependencies.add(name);
+            implementation.setDependencies(dependencies);
+            return implementation;
+        }
+    }
+
+    public List<TMapRequirementDefinition> convert(org.eclipse.winery.model.tosca.TNodeType.RequirementDefinitions node) {
+        if (Objects.isNull(node)) return null;
+        return node.getRequirementDefinition().stream()
+            .filter(Objects::nonNull)
+            .map(this::convert)
+            .filter(Objects::nonNull)
+            .collect(Collectors.toList());
+    }
+
+    public Map<String, TArtifactDefinition> convert(TDeploymentArtifacts node) {
+        if (Objects.isNull(node)) return null;
+        return node.getDeploymentArtifact().stream()
+            .filter(Objects::nonNull)
+            .map(ia -> new LinkedHashMap.SimpleEntry<>(ia.getArtifactRef().getLocalPart(), convertArtifactReference(new QName(ia.getArtifactRef().getNamespaceURI(), ia.getArtifactRef().getLocalPart()))))
+            .filter(Objects::nonNull)
+            .filter(entry -> Objects.nonNull(entry.getValue()))
+            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
+    }
+
+    public Map<String, TArtifactDefinition> convert(TDeploymentArtifacts node, Map<String, TArtifactDefinition> artifacts) {
+        if (Objects.isNull(node)) return null;
+        Map<String, TArtifactDefinition> output = new LinkedHashMap<>();
+        for (TDeploymentArtifact deploymentArtifact : node.getDeploymentArtifact()) {
+            if (artifacts.containsKey(deploymentArtifact.getArtifactRef().getLocalPart())) {
+                output.put(deploymentArtifact.getArtifactRef().getLocalPart(), artifacts.get(deploymentArtifact.getArtifactRef().getLocalPart()));
+            } else {
+                output.put(deploymentArtifact.getArtifactRef().getLocalPart(), convertArtifactReference(deploymentArtifact.getArtifactRef()));
+            }
+        }
+
+        return output;
+    }
+
+    public Map<String, TArtifactDefinition> convert(TImplementationArtifacts node, Map<String, TArtifactDefinition> artifacts) {
+        if (Objects.isNull(node)) return null;
+        Map<String, TArtifactDefinition> output = new LinkedHashMap<>();
+        for (TImplementationArtifact implementationArtifact : node.getImplementationArtifact()) {
+            if (artifacts.containsKey(implementationArtifact.getArtifactRef().getLocalPart())) {
+                output.put(implementationArtifact.getArtifactRef().getLocalPart(), artifacts.get(implementationArtifact.getArtifactRef().getLocalPart()));
+            } else {
+                output.put(implementationArtifact.getArtifactRef().getLocalPart(), convertArtifactReference(implementationArtifact.getArtifactRef()));
+            }
+        }
+        return output;
+    }
+
+    public TArtifactDefinition convertArtifactReference(QName ref) {
+        if (Objects.isNull(ref)) return null;
+        return convert(new ArtifactTemplateId(ref));
+    }
+
+    public TArtifactDefinition convert(ArtifactTemplateId id) {
+        TArtifactTemplate node = repository.getElement(id);
+//        List<String> files = Optional.ofNullable(repository.getContainedFiles(new ArtifactTemplateFilesDirectoryId(id)))
+//            .orElse(new TreeSet<>())
+//            .stream()
+//            .map(ref -> {
+//                try {
+//                    InputStream inputStream = repository.newInputStream(ref);
+//                    Path path = this.path.resolve(id.getGroup())
+//                        .resolve(id.getNamespace().getEncoded())
+//                        .resolve(node.getIdFromIdOrNameField())
+//                        .resolve(ref.getFileName());
+//                    if (!path.toFile().exists()) {
+//                        //noinspection ResultOfMethodCallIgnored
+//                        path.getParent().toFile().mkdirs();
+//                        Files.copy(inputStream, path);
+//                    }
+//                    return this.path.relativize(path).toString();
+//                } catch (IOException e) {
+//                    LOGGER.error("Failed to copy Artifact file", e);
+//                    return null;
+//                }
+//            })
+//            .filter(Objects::nonNull)
+//            .collect(Collectors.toList());
+        return convertArtifactTemplate(node);
+    }
+
+    public TArtifactDefinition convertArtifactTemplate(TArtifactTemplate node) {
+        List<String> files = new ArrayList<>();
+        TArtifactTemplate.ArtifactReferences artifactReferences = node.getArtifactReferences();
+        if (artifactReferences != null) {
+            List<TArtifactReference> artifactReferenceList = artifactReferences.getArtifactReference();
+            if (artifactReferenceList != null) {
+                for (TArtifactReference artifactReference : artifactReferenceList) {
+                    files.add(artifactReference.getReference());
+                }
+            }
+        }
+        if (Objects.isNull(node) || Objects.isNull(node.getType()))
+            return null;
+        return new TArtifactDefinition.Builder(getQName(
+            new ArtifactTypeId(node.getType()),
+            node.getType().getNamespaceURI(),
+            node.getType().getLocalPart()
+        ), files)
+            .build();
+    }
+
+    public TMapRequirementDefinition convert(org.eclipse.winery.model.tosca.TRequirementDefinition node) {
+        if (Objects.isNull(node))
+            return null;
+        TRequirementDefinition.Builder builder = new TRequirementDefinition.Builder(node.getCapability())
+            .setDescription(convertDocumentation(node.getDocumentation()))
+            .setOccurrences(node.getLowerBound(), node.getUpperBound())
+            .setNode(node.getNode());
+
+        if (node.getRelationship() != null) {
+            TRelationshipDefinition.Builder relationshipDefBuilder = new TRelationshipDefinition.Builder(node.getRelationship());
+            builder = builder.setRelationship(relationshipDefBuilder.build());
+        }
+
+        return new TMapRequirementDefinition().setMap(
+            Collections.singletonMap(
+                node.getName(),
+                builder.build()
+            ));
+    }
+
+    public QName convert(@NonNull TRequirementType node) {
+        return getQName(
+            new CapabilityTypeId(node.getRequiredCapabilityType()),
+            node.getRequiredCapabilityType().getNamespaceURI(),
+            node.getRequiredCapabilityType().getLocalPart()
+        );
+    }
+
+    public Map<String, TCapabilityDefinition> convert(org.eclipse.winery.model.tosca.TNodeType.CapabilityDefinitions node) {
+        if (Objects.isNull(node) || node.getCapabilityDefinition().isEmpty()) return null;
+        return node.getCapabilityDefinition().stream()
+            .filter(Objects::nonNull)
+            .collect(Collectors.toMap(
+                org.eclipse.winery.model.tosca.TCapabilityDefinition::getName,
+                this::convert
+            ));
+    }
+
+    public TCapabilityDefinition convert(org.eclipse.winery.model.tosca.TCapabilityDefinition node) {
+        return new TCapabilityDefinition.Builder(
+            convert(
+                node.getCapabilityType(),
+                new CapabilityTypeId(node.getCapabilityType())
+            ))
+            .setDescription(convertDocumentation(node.getDocumentation()))
+            .setOccurrences(node.getLowerBound(), node.getUpperBound())
+            .build();
+    }
+
+    public QName convert(QName node, DefinitionsChildId id) {
+        if (Objects.isNull(node)) return null;
+        return getQName(
+            id,
+            node.getNamespaceURI(),
+            node.getLocalPart()
+        );
+    }
+
+    public Map<String, TInterfaceDefinition> convert(TInterfaces node, String type) {
+        if (Objects.isNull(node)) return null;
+        return node.getInterface().stream()
+            .filter(Objects::nonNull)
+            .collect(Collectors.toMap(
+                TInterface::getName,
+                entry -> new TInterfaceDefinition.Builder()
+                    .setType(new QName(type))
+                    .addOperations(convertOperations(entry.getOperation(), new ArrayList<>()))
+                    .build()
+            ));
+    }
+
+    public Map<String, TInterfaceDefinition> convert(TInterfaces node) {
+        if (Objects.isNull(node)) return null;
+        return node.getInterface().stream()
+            .filter(Objects::nonNull)
+            .collect(Collectors.toMap(
+                TInterface::getName,
+                entry -> new TInterfaceDefinition.Builder()
+                    .addOperations(convertOperations(entry.getOperation(), new ArrayList<>()))
+                    .build()
+            ));
+    }
+
+    public Map<String, TPropertyAssignmentOrDefinition> convert(TOperation.InputParameters node) {
+        if (Objects.isNull(node)) return null;
+        return node.getInputParameter().stream()
+            .filter(Objects::nonNull)
+            .collect(Collectors.toMap(
+                TParameter::getName,
+                entry -> new TPropertyDefinition.Builder(convertType(entry.getType()))
+                    .setRequired(convert(entry.getRequired()))
+                    .build()
+            ));
+    }
+
+    public Map<String, TPropertyAssignmentOrDefinition> convert(TOperation.OutputParameters node) {
+        if (Objects.isNull(node)) return null;
+        return node.getOutputParameter().stream()
+            .filter(Objects::nonNull)
+            .collect(Collectors.toMap(
+                TParameter::getName,
+                entry -> new TPropertyDefinition.Builder(convertType(entry.getType()))
+                    .setRequired(convert(entry.getRequired()))
+                    .build()
+            ));
+    }
+
+    public boolean convert(TBoolean node) {
+        return Objects.nonNull(node) && node.equals(TBoolean.YES);
+    }
+
+    private QName convertType(String type) {
+        return TypeConverter.INSTANCE.convert(type);
+    }
+
+    public Map<String, TCapabilityAssignment> convert(org.eclipse.winery.model.tosca.TNodeTemplate.Capabilities node) {
+        if (Objects.isNull(node)) return null;
+        return node.getCapability().stream()
+            .filter(Objects::nonNull)
+            .map(this::convert)
+            .filter(Objects::nonNull)
+            .flatMap(map -> map.entrySet().stream())
+            .filter(Objects::nonNull)
+            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
+    }
+
+    public Map<String, TCapabilityAssignment> convert(TCapability node) {
+        if (Objects.isNull(node)) return null;
+
+        // skip empty capability assignments
+        if (node.getProperties() == null || node.getProperties().getKVProperties() == null || node.getProperties().getKVProperties().size() == 0) {
+            return null;
+        }
+
+        return Collections.singletonMap(
+            node.getName(),
+            new TCapabilityAssignment.Builder()
+                .setProperties(convert(node, node.getProperties()))
+                .build()
+        );
+    }
+
+    public List<TMapRequirementAssignment> convert(org.eclipse.winery.model.tosca.TNodeTemplate.Requirements node) {
+        if (Objects.isNull(node)) return null;
+        return node.getRequirement().stream()
+            .filter(Objects::nonNull)
+            .map(this::convert)
+            .filter(Objects::nonNull)
+            .collect(Collectors.toList());
+    }
+
+    public TMapRequirementAssignment convert(TRequirement node) {
+        if (Objects.isNull(node)) return null;
+        TRequirementAssignment.Builder builder = new TRequirementAssignment.Builder();
+        // here we assume the assignment to include template names only (no types!)
+        // todo make s more generic TRequirement conversion
+        // todo allow changing occurrences in TRequirement in topology modeler
+        // todo allow passing relationship assignment parameters
+
+        if (node.getCapability() != null) {
+            builder = builder.setCapability(QName.valueOf(node.getCapability()));
+        }
+
+        if (node.getNode() != null) {
+            builder = builder.setNode(QName.valueOf(node.getNode()));
+        }
+
+        if (node.getRelationship() != null) {
+            builder = builder.setRelationship(new TRelationshipAssignment.Builder(QName.valueOf(node.getRelationship())).build());
+        }
+
+        return new TMapRequirementAssignment().setMap(Collections.singletonMap(
+            node.getName(),
+            builder.build()
+        ));
+    }
+
+    private <T, K> Map<String, K> convert(List<T> nodes) {
+        return nodes.stream()
+            .filter(Objects::nonNull)
+            .flatMap(node -> {
+                if (node instanceof org.eclipse.winery.model.tosca.TRelationshipTemplate) {
+                    return convert((org.eclipse.winery.model.tosca.TRelationshipTemplate) node).entrySet().stream();
+                } else if (node instanceof org.eclipse.winery.model.tosca.TArtifactType) {
+                    return convert((org.eclipse.winery.model.tosca.TArtifactType) node).entrySet().stream();
+                } else if (node instanceof org.eclipse.winery.model.tosca.TCapabilityType) {
+                    return convert((org.eclipse.winery.model.tosca.TCapabilityType) node).entrySet().stream();
+                } else if (node instanceof org.eclipse.winery.model.tosca.TRelationshipType) {
+                    return convert((org.eclipse.winery.model.tosca.TRelationshipType) node).entrySet().stream();
+                } else if (node instanceof org.eclipse.winery.model.tosca.TNodeType) {
+                    return convert((org.eclipse.winery.model.tosca.TNodeType) node).entrySet().stream();
+                } else if (node instanceof org.eclipse.winery.model.tosca.TPolicyType) {
+                    return convert((org.eclipse.winery.model.tosca.TPolicyType) node).entrySet().stream();
+                }
+                throw new AssertionError();
+            })
+            .peek(entry -> LOGGER.debug("entry: {}", entry))
+            .filter(Objects::nonNull)
+            .collect(Collectors.toMap(Map.Entry::getKey, entry -> (K) entry.getValue()));
+    }
+
+    private String getNamespacePrefix(String uri) {
+        if (!prefixNamespace.containsValue(uri)) {
+            String prefix = repository.getNamespaceManager().getPrefix(uri);
+            if ("tosca".equals(prefix) && !uri.equals(Namespaces.TOSCA_NS)) prefix = prefix.concat("_xml");
+            prefixNamespace.put(prefix, uri);
+        }
+        return prefixNamespace.inverse().get(uri);
+    }
+
+    private QName getQName(DefinitionsChildId id, String namespaceURI, String localPart) {
+        setImportDefinition(id);
+        return new QName(
+            namespaceURI,
+            localPart,
+            this.getNamespacePrefix(namespaceURI)
+        );
+    }
+
+    private void setImportDefinition(DefinitionsChildId id) {
+        this.importDefinitions.put(
+            id, repository.getDefinitions(id)
+        );
+    }
+
+    private TNodeTypeImplementation getNodeTypeImplementation(QName nodeType) {
+        return repository.getAllDefinitionsChildIds(NodeTypeImplementationId.class)
+            .stream()
+            .map(repository::getElement)
+            .filter(entry -> entry.getNodeType().equals(nodeType))
+            .findAny().orElse(new TNodeTypeImplementation());
+    }
+
+    private TRelationshipTypeImplementation getRelationshipTypeImplementation(QName relationshipType) {
+        return repository.getAllDefinitionsChildIds(RelationshipTypeImplementationId.class)
+            .stream()
+            .map(repository::getElement)
+            .filter(entry -> entry.getRelationshipType().equals(relationshipType))
+            .findAny().orElse(new TRelationshipTypeImplementation());
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/Y2XConverter.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/Y2XConverter.java
new file mode 100644
index 000000000..87ece9b03
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/Y2XConverter.java
@@ -0,0 +1,1285 @@
+/********************************************************************************
+ * Copyright (c) 2017-2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+
+package org.eclipse.winery.repository.backend.filebased.converter;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import javax.xml.namespace.QName;
+
+import org.eclipse.winery.common.Util;
+import org.eclipse.winery.common.ids.definitions.NodeTypeId;
+import org.eclipse.winery.model.tosca.Definitions;
+import org.eclipse.winery.model.tosca.TAppliesTo;
+import org.eclipse.winery.model.tosca.TArtifactReference;
+import org.eclipse.winery.model.tosca.TArtifactTemplate;
+import org.eclipse.winery.model.tosca.TArtifactType;
+import org.eclipse.winery.model.tosca.TBoundaryDefinitions;
+import org.eclipse.winery.model.tosca.TCapability;
+import org.eclipse.winery.model.tosca.TCapabilityDefinition;
+import org.eclipse.winery.model.tosca.TCapabilityType;
+import org.eclipse.winery.model.tosca.TDeploymentArtifact;
+import org.eclipse.winery.model.tosca.TDeploymentArtifacts;
+import org.eclipse.winery.model.tosca.TEntityTemplate;
+import org.eclipse.winery.model.tosca.TEntityType;
+import org.eclipse.winery.model.tosca.TExtensibleElements;
+import org.eclipse.winery.model.tosca.TImplementationArtifacts;
+import org.eclipse.winery.model.tosca.TImport;
+import org.eclipse.winery.model.tosca.TInterface;
+import org.eclipse.winery.model.tosca.TNodeTemplate;
+import org.eclipse.winery.model.tosca.TNodeType;
+import org.eclipse.winery.model.tosca.TNodeTypeImplementation;
+import org.eclipse.winery.model.tosca.TOperation;
+import org.eclipse.winery.model.tosca.TParameter;
+import org.eclipse.winery.model.tosca.TPolicy;
+import org.eclipse.winery.model.tosca.TPolicyTemplate;
+import org.eclipse.winery.model.tosca.TPolicyType;
+import org.eclipse.winery.model.tosca.TRelationshipTemplate;
+import org.eclipse.winery.model.tosca.TRelationshipType;
+import org.eclipse.winery.model.tosca.TRelationshipTypeImplementation;
+import org.eclipse.winery.model.tosca.TRequirement;
+import org.eclipse.winery.model.tosca.TRequirementDefinition;
+import org.eclipse.winery.model.tosca.TRequirementType;
+import org.eclipse.winery.model.tosca.TServiceTemplate;
+import org.eclipse.winery.model.tosca.TTag;
+import org.eclipse.winery.model.tosca.TTags;
+import org.eclipse.winery.model.tosca.TTopologyTemplate;
+import org.eclipse.winery.model.tosca.kvproperties.PropertyDefinitionKV;
+import org.eclipse.winery.model.tosca.kvproperties.PropertyDefinitionKVList;
+import org.eclipse.winery.model.tosca.kvproperties.WinerysPropertiesDefinition;
+import org.eclipse.winery.model.tosca.yaml.TArtifactDefinition;
+import org.eclipse.winery.model.tosca.yaml.TAttributeDefinition;
+import org.eclipse.winery.model.tosca.yaml.TCapabilityAssignment;
+import org.eclipse.winery.model.tosca.yaml.TImplementation;
+import org.eclipse.winery.model.tosca.yaml.TImportDefinition;
+import org.eclipse.winery.model.tosca.yaml.TInterfaceDefinition;
+import org.eclipse.winery.model.tosca.yaml.TInterfaceType;
+import org.eclipse.winery.model.tosca.yaml.TOperationDefinition;
+import org.eclipse.winery.model.tosca.yaml.TPolicyDefinition;
+import org.eclipse.winery.model.tosca.yaml.TPropertyAssignment;
+import org.eclipse.winery.model.tosca.yaml.TPropertyAssignmentOrDefinition;
+import org.eclipse.winery.model.tosca.yaml.TPropertyDefinition;
+import org.eclipse.winery.model.tosca.yaml.TRequirementAssignment;
+import org.eclipse.winery.model.tosca.yaml.TTopologyTemplateDefinition;
+import org.eclipse.winery.model.tosca.yaml.support.Metadata;
+import org.eclipse.winery.repository.backend.RepositoryFactory;
+import org.eclipse.winery.repository.backend.filebased.converter.support.Defaults;
+import org.eclipse.winery.repository.backend.filebased.converter.support.Namespaces;
+import org.eclipse.winery.repository.backend.filebased.converter.support.yaml.AssignmentBuilder;
+import org.eclipse.winery.repository.backend.filebased.converter.support.yaml.TypeConverter;
+import org.eclipse.winery.repository.backend.filebased.converter.support.yaml.extension.TImplementationArtifactDefinition;
+
+import org.eclipse.jdt.annotation.NonNull;
+import org.eclipse.jdt.annotation.Nullable;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class Y2XConverter {
+    public final static Logger LOGGER = LoggerFactory.getLogger(Y2XConverter.class);
+    private org.eclipse.winery.model.tosca.yaml.TServiceTemplate root;
+    private org.eclipse.winery.model.tosca.yaml.TNodeTemplate currentNodeTemplate;
+    private String currentNodeTemplateName;
+    private String namespace;
+    private List<TNodeTypeImplementation> nodeTypeImplementations;
+    private List<TRelationshipTypeImplementation> relationshipTypeImplementations;
+    private Map<String, TArtifactTemplate> artifactTemplates;
+    private List<TPolicyTemplate> policyTemplates;
+    private List<TRequirementType> requirementTypes;
+    private List<TImport> imports;
+    private Map<QName, TInterfaceType> interfaceTypes;
+    private Map<String, List<TPolicy>> policies;
+    private Map<String, Map.Entry<String, String>> relationshipSTMap;
+    private Map<String, TNodeTemplate> nodeTemplateMap;
+    private AssignmentBuilder assignmentBuilder;
+//    private ReferenceVisitor referenceVisitor;
+
+    public Y2XConverter() {
+    }
+
+    private void reset() {
+        this.nodeTypeImplementations = new ArrayList<>();
+        this.relationshipTypeImplementations = new ArrayList<>();
+        this.artifactTemplates = new LinkedHashMap<>();
+        this.policyTemplates = new ArrayList<>();
+        this.requirementTypes = new ArrayList<>();
+        this.imports = new ArrayList<>();
+        this.policies = new LinkedHashMap<>();
+        this.relationshipSTMap = new LinkedHashMap<>();
+        this.nodeTemplateMap = new LinkedHashMap<>();
+        this.currentNodeTemplate = null;
+        this.currentNodeTemplateName = null;
+        this.interfaceTypes = new LinkedHashMap<>();
+    }
+
+    /**
+     * Processes knowledge from TServiceTemplate needed to construct XML result
+     */
+    private void init(org.eclipse.winery.model.tosca.yaml.TServiceTemplate node) {
+        // no interface type for xml -> interface type information inserted into interface definitions
+        convert(node.getInterfaceTypes());
+        this.assignmentBuilder = new AssignmentBuilder(new LinkedHashMap<>());
+    }
+
+    /**
+     * Converts TOSCA YAML ServiceTemplates to TOSCA XML Definitions
+     *
+     * @return TOSCA XML Definitions
+     */
+    @NonNull
+    public Definitions convert(org.eclipse.winery.model.tosca.yaml.TServiceTemplate node, String id, String target_namespace) {
+        if (node == null) return new Definitions();
+        // LOGGER.debug("Converting TServiceTemplate");
+        this.root = node;
+
+        // Reset
+        this.reset();
+//        this.referenceVisitor = new ReferenceVisitor(node, target_namespace);
+        this.namespace = target_namespace;
+
+        init(node);
+
+        Definitions definitions = new Definitions.Builder(id + "_Definitions", target_namespace)
+            .setImport(convert(node.getImports()))
+            .addTypes(convert(node.getDataTypes()))
+            .addTypes(convert(node.getGroupTypes()))
+            .addServiceTemplates(convertServiceTemplate(node, id, target_namespace))
+            .addNodeTypes(convert(node.getNodeTypes()))
+            .addNodeTypeImplementations(this.nodeTypeImplementations)
+            .addRelationshipTypes(convert(node.getRelationshipTypes()))
+            .addRelationshipTypeImplementations(this.relationshipTypeImplementations)
+            .addCapabilityTypes(convert(node.getCapabilityTypes()))
+            .addArtifactTypes(convert(node.getArtifactTypes()))
+            .addArtifactTemplates(this.artifactTemplates.entrySet().stream().map(Map.Entry::getValue).collect(Collectors.toList()))
+            .addPolicyTypes(convert(node.getPolicyTypes()))
+            .setName(id)
+            .addImports(this.imports)
+            .addRequirementTypes(this.requirementTypes)
+            .addPolicyTemplates(this.policyTemplates)
+            .build();
+//        WriterUtils.storeDefinitions(definitions, true, path);
+        return definitions;
+    }
+
+    /**
+     * Converts TOSCA YAML ServiceTemplates to TOSCA XML ServiceTemplates
+     *
+     * @param node TOSCA YAML ServiceTemplate
+     * @return TOSCA XML ServiceTemplate
+     */
+    @Nullable
+    private TServiceTemplate convertServiceTemplate(org.eclipse.winery.model.tosca.yaml.TServiceTemplate node, String id, String targetNamespace) {
+        if (node == null) return null;
+
+        return new TServiceTemplate.Builder(id, convert(node.getTopologyTemplate()))
+            .addDocumentation(node.getDescription())
+            .setBoundaryDefinitions(
+                new TBoundaryDefinitions.Builder()
+                    .addPolicies(this.policies.get("boundary")).build()
+            )
+            .setName(id)
+            .setTargetNamespace(targetNamespace)
+            .build();
+    }
+
+    /**
+     * Converts TPropertyDefinition and TAttributeDefinition to an xml schema
+     *
+     * @return TOSCA XML PropertyDefinition with referencing the schema of the Properties
+     */
+    private TEntityType.PropertiesDefinition convertPropertyDefinition(String name) {
+        this.imports.add(
+            new TImport.Builder(Namespaces.XML_NS)
+                .setNamespace(this.namespace)
+                .setLocation("types" + File.separator + name + ".xsd").build()
+        );
+
+        TEntityType.PropertiesDefinition propertiesDefinition = new TEntityType.PropertiesDefinition();
+        propertiesDefinition.setElement(new QName(name));
+        return propertiesDefinition;
+    }
+
+    /**
+     * Converts TOSCA YAML EntityTypes to TOSCA XML EntityTypes
+     * <p>
+     * Additional element version added to tag. Missing elements abstract, final will not be set. Missing element
+     * targetNamespace is searched in metadata
+     *
+     * @param node TOSCA YAML EntityType
+     * @return TOSCA XML EntityType
+     */
+    private <T extends TEntityType.Builder<T>> T convert(org.eclipse.winery.model.tosca.yaml.TEntityType node, T builder) {
+        builder.addDocumentation(node.getDescription())
+            .setDerivedFrom(node.getDerivedFrom())
+            .addTags(convertMetadata(node.getMetadata()))
+            .setTargetNamespace(node.getMetadata().get("targetNamespace"));
+
+        if (node.getVersion() != null) {
+            TTag tag = new TTag();
+            tag.setName("version");
+            tag.setValue(node.getVersion().getVersion());
+            builder.addTags(tag);
+        }
+
+//        if (!node.getProperties().isEmpty()) {
+//            builder.setPropertiesDefinition(convertPropertyDefinition(builder.build().getIdFromIdOrNameField() + "_Properties"));
+//        }
+
+        if (!node.getProperties().isEmpty()) {
+            builder.addAny(convertWineryPropertiesDefinition(node.getProperties(), builder.build().getTargetNamespace(), builder.build().getIdFromIdOrNameField()));
+        }
+
+        return builder;
+    }
+
+    private WinerysPropertiesDefinition convertWineryPropertiesDefinition(Map<String, TPropertyDefinition> properties, String targetNamespace, String typeName) {
+        WinerysPropertiesDefinition winerysPropertiesDefinition = new WinerysPropertiesDefinition();
+        winerysPropertiesDefinition.setElementName("properties");
+        winerysPropertiesDefinition.setNamespace(targetNamespace + "/propertiesDefinition/" + typeName);
+
+        PropertyDefinitionKVList wineryProperties = new PropertyDefinitionKVList();
+        for (Map.Entry<String, TPropertyDefinition> property : properties.entrySet()) {
+            TPropertyDefinition tPropDef = property.getValue();
+            wineryProperties.add(
+                new PropertyDefinitionKV(property.getKey(),
+                    "xsd:" + tPropDef.getType().getLocalPart(),
+                    tPropDef.getRequired(),
+                    tPropDef.getDefault() != null ? tPropDef.getDefault().toString() : null,
+                    tPropDef.getDescription()
+                )
+            );
+        }
+        winerysPropertiesDefinition.setPropertyDefinitionKVList(wineryProperties);
+        return winerysPropertiesDefinition;
+    }
+
+    /**
+     * Converts TOSCA YAML metadata to TOSCA XML Tags
+     *
+     * @param metadata map of strings
+     * @return TOSCA XML Tags
+     */
+    @NonNull
+    private TTags convertMetadata(Metadata metadata) {
+        return new TTags.Builder()
+            .addTag(
+                metadata.entrySet().stream()
+                    .filter(Objects::nonNull)
+                    .map(entry -> new TTag.Builder().setName(entry.getKey()).setValue(entry.getValue()).build())
+                    .filter(Objects::nonNull)
+                    .collect(Collectors.toList())
+            )
+            .build();
+    }
+
+    /**
+     * Converts TOSCA YAML ArtifactTypes to TOSCA XML ArtifactTypes. Both objects have a super type EntityType.
+     * Additional elements mime_type and file_ext from TOSCA YAML are moved to tags in TOSCA XML
+     *
+     * @param node the YAML ArtifactType
+     * @return TOSCA XML ArtifactType
+     */
+    private TArtifactType convert(org.eclipse.winery.model.tosca.yaml.TArtifactType node, String id) {
+        if (node == null) return null;
+        TArtifactType.Builder builder = new TArtifactType.Builder(id);
+        convert(node, builder);
+        if (node.getFileExt() != null) {
+            builder.addTags("file_ext", "[" + node.getFileExt().stream().map(Object::toString)
+                .collect(Collectors.joining(",")) + "]");
+        }
+        if (node.getMimeType() != null) {
+            builder.addTags("mime_type", node.getMimeType());
+        }
+        return builder.build();
+    }
+
+    /**
+     * Converts a TOSCA YAML ArtifactDefinition to a TOSCA XML ArtifactTemplate
+     *
+     * @param node TOSCA YAML ArtifactDefinition
+     * @return TOSCA XML ArtifactTemplate
+     */
+    @NonNull
+    private TArtifactTemplate convert(TArtifactDefinition node, String id) {
+        TArtifactTemplate.Builder builder = new TArtifactTemplate.Builder(id, node.getType());
+        if (node.getFiles() != null) {
+            builder.addArtifactReferences(node.getFiles().stream()
+                .filter(Objects::nonNull)
+                // TODO change filepath
+                .map(file -> new TArtifactReference.Builder(file).build())
+                .collect(Collectors.toList())
+            );
+        }
+        if (node.getProperties() != null) {
+            builder.setProperties(convertPropertyAssignments(node.getProperties()));
+        }
+        return builder.build();
+    }
+
+    /**
+     * Converts TOSCA YAML ArtifactDefinitions to TOSCA XML DeploymentArtifacts
+     *
+     * @param artifactDefinitionMap map of TOSCA YAML ArtifactDefinitions
+     * @return TOSCA XML DeploymentArtifacts
+     */
+    private TDeploymentArtifacts convertDeploymentArtifacts(@NonNull Map<String, TArtifactDefinition> artifactDefinitionMap, String targetNamespace) {
+        if (artifactDefinitionMap.isEmpty()) return null;
+        return new TDeploymentArtifacts.Builder(artifactDefinitionMap.entrySet().stream()
+            .filter(Objects::nonNull)
+            .map(entry -> {
+                TArtifactTemplate artifactTemplate = convert(entry.getValue(), entry.getKey());
+                this.artifactTemplates.put(artifactTemplate.getId(), artifactTemplate);
+                return new TDeploymentArtifact.Builder(entry.getKey(), entry.getValue().getType())
+                    .setArtifactRef(new QName(targetNamespace, artifactTemplate.getId()))
+                    .build();
+            })
+            .collect(Collectors.toList()))
+            .build();
+    }
+
+    /**
+     * Converts TOSCA YAML ArtifactDefinitions to TOSCA XML DeploymentArtifacts
+     *
+     * @param artifactDefinitionMap map of TOSCA YAML ArtifactDefinitions
+     * @return TOSCA XML DeploymentArtifacts
+     */
+    private TDeploymentArtifacts convertDeploymentArtifacts(@NonNull Map<String, TArtifactDefinition> artifactDefinitionMap) {
+        if (artifactDefinitionMap.isEmpty()) return null;
+        return new TDeploymentArtifacts.Builder(artifactDefinitionMap.entrySet().stream()
+            .filter(Objects::nonNull)
+            .map(entry -> {
+                TArtifactTemplate artifactTemplate = convert(entry.getValue(), entry.getKey());
+                this.artifactTemplates.put(artifactTemplate.getId(), artifactTemplate);
+                return new TDeploymentArtifact.Builder(entry.getKey(), entry.getValue().getType())
+                    .setArtifactRef(new QName(artifactTemplate.getId()))
+                    .build();
+            })
+            .collect(Collectors.toList()))
+            .build();
+    }
+//
+//    /**
+//     * Converts TOSCA YAML ArtifactDefinitions to TOSCA XML ImplementationArtifacts
+//     *
+//     * @param artifactDefinitionMap map of TOSCA YAML ArtifactDefinitions
+//     * @return TOSCA XML ImplementationArtifacts
+//     */
+//    private TImplementationArtifacts convertImplementationArtifact(@NonNull Map<String, TArtifactDefinition> artifactDefinitionMap) {
+//        if (artifactDefinitionMap.isEmpty()) return null;
+//        TImplementationArtifacts output = new TImplementationArtifacts.Builder(artifactDefinitionMap.entrySet().stream()
+//            .filter(entry -> Objects.nonNull(entry) && Objects.nonNull(entry.getValue()))
+//            .map(entry -> {
+//                TArtifactTemplate artifactTemplate = convert(entry.getValue(), entry.getKey());
+//                this.artifactTemplates.put(artifactTemplate.getId(), artifactTemplate);
+//                return new TImplementationArtifacts.ImplementationArtifact.Builder(entry.getValue().getType())
+//                    .setName(entry.getKey())
+//                    .setArtifactRef(new QName(artifactTemplate.getId()))
+//                    .setInterfaceName(convertInterfaceName(entry.getValue()))
+//                    .setOperationName(convertOperationName(entry.getValue()))
+//                    .build();
+//            })
+//            .collect(Collectors.toList()))
+//            .build();
+//        return output;
+//    }
+
+    /**
+     * Converts TOSCA YAML ArtifactDefinitions to TOSCA XML ImplementationArtifacts
+     *
+     * @param artifactDefinitionMap map of TOSCA YAML ArtifactDefinitions
+     * @return TOSCA XML ImplementationArtifacts
+     */
+    private TImplementationArtifacts convertImplementationArtifact(@NonNull Map<String, TArtifactDefinition> artifactDefinitionMap, String targetNamespace) {
+        if (artifactDefinitionMap.isEmpty()) return null;
+        TImplementationArtifacts output = new TImplementationArtifacts.Builder(artifactDefinitionMap.entrySet().stream()
+            .filter(entry -> Objects.nonNull(entry) && Objects.nonNull(entry.getValue()))
+            .map(entry -> {
+                TArtifactTemplate artifactTemplate = convert(entry.getValue(), entry.getKey());
+                this.artifactTemplates.put(artifactTemplate.getId(), artifactTemplate);
+                return new TImplementationArtifacts.ImplementationArtifact.Builder(entry.getValue().getType())
+                    .setName(entry.getKey())
+                    .setArtifactRef(new QName(targetNamespace, artifactTemplate.getId()))
+                    .setInterfaceName(convertInterfaceName(entry.getValue()))
+                    .setOperationName(convertOperationName(entry.getValue()))
+                    .build();
+            })
+            .collect(Collectors.toList()))
+            .build();
+        return output;
+    }
+
+    @Nullable
+    public String convertInterfaceName(@NonNull TArtifactDefinition node) {
+        if (node instanceof TImplementationArtifactDefinition)
+            return ((TImplementationArtifactDefinition) node).getInterfaceName();
+        return null;
+    }
+
+    @Nullable
+    public String convertOperationName(@NonNull TArtifactDefinition node) {
+        if (node instanceof TImplementationArtifactDefinition)
+            return ((TImplementationArtifactDefinition) node).getOperationName();
+        return null;
+    }
+
+    /**
+     * Inserts operation output definitions defined in attributes "{ get_operation_output: [ SELF, interfaceName,
+     * operationName, propertyName ] }" into interfaceDefinitions
+     */
+    private Map<String, TInterfaceDefinition> refactor(Map<String, TInterfaceDefinition> map, org.eclipse.winery.model.tosca.yaml.TNodeType node) {
+        if (Objects.isNull(map) || map.isEmpty() || node.getAttributes().isEmpty()) return map;
+
+        // Extract Outputs from Attributes and attach them to the Operations (if possible)
+        // Template: attribute.default: { get_operation_output: [ SELF, interfaceName, operationName, propertyName ] }
+        for (Map.Entry<String, TAttributeDefinition> entry : node.getAttributes().entrySet()) {
+            TAttributeDefinition attr = entry.getValue();
+            if (attr.getDefault() != null && attr.getDefault() instanceof Map) {
+                @SuppressWarnings("unchecked")
+                Map<String, Object> aDefault = (Map<String, Object>) attr.getDefault();
+                if (aDefault != null && aDefault.containsKey("get_operation_output")) {
+                    @SuppressWarnings("unchecked")
+                    List<String> values = (List<String>) aDefault.get("get_operation_output");
+                    if (values.size() == 4 &&
+                        values.get(0).equals("SELF") &&
+                        map.containsKey(values.get(1)) &&
+                        map.get(values.get(1)).getOperations().containsKey(values.get(2)) &&
+                        !map.get(values.get(1)).getOperations().get(values.get(2)).getOutputs().containsKey(values.get(3))
+                    ) {
+                        TPropertyDefinition.Builder pBuilder = new TPropertyDefinition.Builder(attr.getType());
+                        map.get(values.get(1)).getOperations().get(values.get(2)).getOutputs().put(values.get(3), pBuilder.build());
+                    }
+                }
+            }
+        }
+
+        return map;
+    }
+
+    private Map<String, TArtifactDefinition> refactorDeploymentArtifacts(Map<String, TArtifactDefinition> map) {
+        return map.entrySet().stream()
+            // Filter for deployment artifacts
+            .filter(entry -> Objects.nonNull(entry.getValue()))
+            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
+    }
+
+    private Map<String, TArtifactDefinition> refactorImplementationArtifacts(Map<String, TArtifactDefinition> map, org.eclipse.winery.model.tosca.yaml.TNodeType node) {
+        Map<String, TArtifactDefinition> implementationArtifacts = new LinkedHashMap<>(map.entrySet().stream()
+            // Filter for deployment artifacts
+            .filter(entry -> Objects.nonNull(entry.getValue()))
+            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)));
+
+        // Convert Interface.Operations Artifacts to ArtifactDefinition
+        for (Map.Entry<String, TInterfaceDefinition> entry : node.getInterfaces().entrySet()) {
+            entry.getValue().getOperations()
+                .entrySet().stream()
+                .filter(operation -> operation.getValue() != null && operation.getValue().getImplementation() != null)
+                .forEach(operation -> {
+                    String interfaceName = entry.getKey();
+                    String operationName = operation.getKey();
+                    TImplementation implementation = operation.getValue().getImplementation();
+                    List<QName> list = implementation.getDependencies();
+                    if (implementation.getPrimary() != null) {
+                        list.add(implementation.getPrimary());
+                    }
+                    for (QName artifactQName : list) {
+                        String artifactName = artifactQName.getLocalPart();
+                        if (implementationArtifacts.containsKey(artifactName)) {
+                            TImplementationArtifactDefinition.Builder iABuilder = new TImplementationArtifactDefinition.Builder(implementationArtifacts.get(artifactName));
+                            TArtifactDefinition old = implementationArtifacts.get(artifactName);
+                            // TODO write Test!!!! (see Restrictions section in Artifacts.md
+                            // Check if implementation artifact is already defined for other interfaces
+                            if (!(old instanceof TImplementationArtifactDefinition)
+                                || ((TImplementationArtifactDefinition) old).getInterfaceName() == null
+                                || ((TImplementationArtifactDefinition) old).getInterfaceName().equals(interfaceName)) {
+                                iABuilder.setInterfaceName(interfaceName);
+                                // Check if ArtifactDefinition is used in more than one operation implementation 
+                                if (old instanceof TImplementationArtifactDefinition
+                                    && ((TImplementationArtifactDefinition) old).getInterfaceName().equals(interfaceName)
+                                    && !(((TImplementationArtifactDefinition) old).getOperationName().equals(operationName))) {
+                                    iABuilder.setOperationName(null);
+                                } else {
+                                    iABuilder.setOperationName(operationName);
+                                }
+                            } else {
+                                // if interface is not ImplementationArtifactDefinition
+                                // or interface not set
+                                // or interface already defined
+                                iABuilder.setInterfaceName(null);
+                            }
+                            iABuilder.setOperationName(operationName);
+
+                            implementationArtifacts.put(artifactName, iABuilder.build());
+                        }
+                    }
+                });
+        }
+
+        return implementationArtifacts;
+    }
+
+    /**
+     * Converts TOSCA YAML NodeTypes to TOSCA XML NodeTypes
+     *
+     * @param node TOSCA YAML NodeType
+     * @return TOSCA XML NodeType
+     */
+    private TNodeType convert(org.eclipse.winery.model.tosca.yaml.TNodeType node, String id) {
+        if (Objects.isNull(node)) return null;
+        TNodeType.Builder builder = convert(node, new TNodeType.Builder(id))
+            .addRequirementDefinitions(convert(node.getRequirements()))
+            .addCapabilityDefinitions(convert(node.getCapabilities()))
+            .addInterfaces(convert(refactor(node.getInterfaces(), node)));
+        TNodeType output = builder.build();
+        convertNodeTypeImplementation(
+            refactorImplementationArtifacts(node.getArtifacts(), node),
+            refactorDeploymentArtifacts(node.getArtifacts()),
+            id, output.getTargetNamespace()
+        );
+        return output;
+    }
+
+    /**
+     * Converts TOSCA YAML NodeTemplates to TOSCA XML NodeTemplates Additional TOSCA YAML element metadata is put into
+     * TOSCA XML documentation element Additional TOSCA YAML elements directives and copy are not converted
+     *
+     * @param node TOSCA YAML NodeTemplate
+     * @return TOSCA XML NodeTemplate
+     */
+    private TNodeTemplate convert(org.eclipse.winery.model.tosca.yaml.TNodeTemplate node, String id) {
+        if (Objects.isNull(node)) {
+            return null;
+        }
+        this.currentNodeTemplate = node;
+        this.currentNodeTemplateName = id;
+        TNodeTemplate.Builder builder = new TNodeTemplate.Builder(id, node.getType())
+            .addDocumentation(node.getDescription())
+            .addDocumentation(node.getMetadata())
+            .setName(id)
+            .setX(node.getMetadata().getOrDefault(Defaults.X_COORD, "0"))
+            .setY(node.getMetadata().getOrDefault(Defaults.Y_COORD, "0"))
+            .setProperties(convertPropertyAssignments(node.getProperties()))
+            .addRequirements(convert(node.getRequirements()))
+            .addCapabilities(convert(node.getCapabilities()))
+            .setDeploymentArtifacts(convertDeploymentArtifacts(node.getArtifacts()));
+        TNodeTemplate nodeTemplate = builder.build();
+        this.nodeTemplateMap.put(id, nodeTemplate);
+
+        return nodeTemplate;
+    }
+
+    /**
+     * Constructs the the name of the PropertyType for a given type
+     */
+    private QName getPropertyTypeName(QName type) {
+        return new QName(type.getNamespaceURI(), type.getLocalPart() + "_Properties");
+    }
+
+    /**
+     * Converts TOSCA YAML RequirementDefinition to TOSCA XML RequirementDefinition
+     *
+     * @param node TOSCA YAML RequirementDefinition
+     * @return TOSCA XML RequirementDefinition
+     */
+    private TRequirementDefinition convert(org.eclipse.winery.model.tosca.yaml.TRequirementDefinition node, String id) {
+        if (Objects.isNull(node)) return null;
+        // TOSCA YAML does not have RequirementTypes:
+        // * construct TOSCA XML RequirementType from TOSCA YAML Requirement Definition	
+        TRequirementDefinition.Builder builder = new TRequirementDefinition.Builder(id)
+            .setLowerBound(node.getLowerBound())
+            .setUpperBound(node.getUpperBound())
+            .setCapability(node.getCapability())
+            .setNode(node.getNode());
+
+        if (node.getRelationship() != null) {
+            builder = builder.setRelationship(node.getRelationship().getType());
+        }
+
+        return builder.build();
+    }
+
+    /**
+     * Converts TOSCA YAML RequirementAssignments to TOSCA XML Requirements Additional TOSCA YAML elements node_filter
+     * and occurrences are not converted
+     *
+     * @param node TOSCA YAML RequirementAssignments
+     * @return return List of TOSCA XML Requirements
+     */
+    private TRequirement convert(TRequirementAssignment node, String id) {
+        if (Objects.isNull(node)) return null;
+        String reqId = this.currentNodeTemplateName + "_" + id;
+        TRequirement.Builder builder = new TRequirement.Builder(reqId, id, null);
+
+        if (node.getCapability() != null) {
+            builder = builder.setCapability(node.getCapability().toString());
+        } else {
+            // when exporting, this must be caught, but while developing, it is tolerated
+            // todo check if this is the case during export!
+            LOGGER.error("TRequirementAssignment has no capability!");
+        }
+
+        if (node.getRelationship() != null && node.getRelationship().getType() != null) {
+            builder = builder.setRelationship(node.getRelationship().getType().toString());
+        }
+
+        if (node.getNode() != null) {
+            builder = builder.setNode(node.getNode().toString());
+        }
+
+        return builder.build();
+    }
+
+    private TCapability convert(TCapabilityAssignment node, String id) {
+        if (Objects.isNull(node)) return null;
+        String capId = this.currentNodeTemplateName + "_" + id;
+        QName capType = this.getCapabilityTypeOfCapabilityName(id);
+        TCapability.Builder builder = new TCapability.Builder(capId, capType, id);
+
+        if (node.getProperties().entrySet().size() > 0) {
+            Map<String, String> properties = node.getProperties()
+                .entrySet()
+                .stream()
+                .collect(Collectors.toMap(
+                    Map.Entry::getKey,
+                    entry -> Objects.requireNonNull(entry.getValue().getValue()).toString()));
+            TEntityTemplate.Properties toscaProperties = new TEntityTemplate.Properties();
+            toscaProperties.setKVProperties(properties);
+            return builder.setProperties(toscaProperties).build();
+        }
+
+        return builder.build();
+    }
+
+    private TCapabilityDefinition getCapabilityDefinitionOfCapabilityName(String capName, QName nodeType) {
+        // todo this has to search the entire nodeType hierarchy!!
+        Definitions nodeTypes = RepositoryFactory.getRepository().getDefinitions(new NodeTypeId(nodeType));
+        TExtensibleElements theNodeType = nodeTypes
+            .getServiceTemplateOrNodeTypeOrNodeTypeImplementation()
+            .stream()
+            .findFirst()
+            .orElse(null);
+
+        if (theNodeType instanceof TNodeType) {
+            if (((TNodeType) theNodeType).getCapabilityDefinitions() != null) {
+
+                return ((TNodeType) theNodeType)
+                    .getCapabilityDefinitions()
+                    .getCapabilityDefinition()
+                    .stream()
+                    .filter(capDef -> capDef.getName().equals(capName))
+                    .findFirst().orElse(null);
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Gets the capability type of a capability identified by its name as present in the capability definition or
+     * capability assignment
+     */
+    private QName getCapabilityTypeOfCapabilityName(String capName) {
+        if (this.currentNodeTemplate != null) {
+            QName nodeType = this.currentNodeTemplate.getType();
+            TCapabilityDefinition capDef = this.getCapabilityDefinitionOfCapabilityName(capName, nodeType);
+
+            if (capDef != null) {
+                return capDef.getCapabilityType();
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Converts TOSCA YAML CapabilityTypes to TOSCA XML CapabilityTypes
+     *
+     * @param node TOSCA YAML CapabilityType
+     * @return TOSCA XML CapabilityType
+     */
+    private TCapabilityType convert(org.eclipse.winery.model.tosca.yaml.TCapabilityType node, String id) {
+        if (Objects.isNull(node)) return null;
+        return convert(node, new TCapabilityType.Builder(id))
+            .setValidSourceTypes(node.getValidSourceTypes())
+            .build();
+    }
+
+    /**
+     * Converts TOSCA YAML CapabilityDefinitions to TOSCA XML CapabilityDefinitions Additional TOSCA YAML elements
+     * properties, attributes and valid_source_types are not converted
+     *
+     * @param node TOSCA YAML CapabilityDefinition
+     * @return TOSCA XML CapabilityDefinition
+     */
+    private TCapabilityDefinition convert(org.eclipse.winery.model.tosca.yaml.TCapabilityDefinition node, String id) {
+        if (Objects.isNull(node)) return null;
+        TCapabilityDefinition result = new TCapabilityDefinition.Builder(id, node.getType())
+            .addDocumentation(node.getDescription())
+            .setLowerBound(node.getLowerBound())
+            .setUpperBound(node.getUpperBound())
+            .build();
+
+        return result;
+    }
+
+    /**
+     * Converts TOSCA YAML InterfaceDefinitions to TOSCA XML Interface Additional TOSCA YAML element input with
+     * PropertyAssignment or PropertyDefinition is not converted
+     *
+     * @param node TOSCA YAML InterfaceDefinition
+     * @return TOSCA XML Interface
+     */
+    private TInterface convert(TInterfaceDefinition node, String id) {
+        List<TOperation> operation = new ArrayList<>();
+        if (this.interfaceTypes.containsKey(node.getType())) {
+            operation.addAll(convert(this.interfaceTypes.get(node.getType()).getOperations()));
+        }
+
+        operation.addAll(convert(node.getOperations()));
+
+        TInterface.Builder builder = new TInterface.Builder(id, operation);
+
+        return builder.build();
+    }
+
+    /**
+     * Convert TOSCA YAML TopologyTemplatesDefinition to TOSCA XML TopologyTemplates Additional TOSCA YAML elements
+     * inputs, outputs, groups, policies, substitution_mappings and workflows are not converted
+     *
+     * @param node TOSCA YAML TopologyTemplateDefinition
+     * @return TOSCA XML TopologyTemplate
+     */
+    private TTopologyTemplate convert(TTopologyTemplateDefinition node) {
+        if (node == null) {
+            return null;
+        }
+
+        TTopologyTemplate.Builder builder = new TTopologyTemplate.Builder();
+        builder.addDocumentation(node.getDescription());
+
+        builder.setNodeTemplates(convert(node.getNodeTemplates()));
+        builder.setRelationshipTemplates(convert(node.getRelationshipTemplates()));
+        convert(node.getPolicies());
+
+        return builder.build();
+    }
+
+    /**
+     * Converts TOSCA YAML RelationshipTypes to TOSCA XML RelationshipTypes Additional element valid_target_types
+     * (specifying Capability Types) is not converted
+     *
+     * @param node TOSCA YAML RelationshipType
+     * @return TOSCA XML RelationshipType
+     */
+    private TRelationshipType convert(org.eclipse.winery.model.tosca.yaml.TRelationshipType node, String id) {
+        if (Objects.isNull(node)) return null;
+        TRelationshipType output = convert(node, new TRelationshipType.Builder(id))
+            .addSourceInterfaces(convert(node.getInterfaces(), "SourceInterfaces"))
+            .addInterfaces(convert(node.getInterfaces(), null))
+            .addTargetInterfaces(convert(node.getInterfaces(), "TargetInterfaces"))
+            .setValidSource(convertValidTargetSource(node.getValidTargetTypes(), true))
+            .setValidTarget(convertValidTargetSource(node.getValidTargetTypes(), false))
+            .build();
+        convertRelationshipTypeImplementation(node.getInterfaces(), id, node.getMetadata().get("targetNamespace"));
+        return output;
+    }
+
+    private QName convertValidTargetSource(List<QName> targets, Boolean isSource) {
+        if (targets != null) {
+            if (targets.size() > 1) {
+                if (isSource) {
+                    return targets.get(0);
+                } else {
+                    return targets.get(1);
+                }
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Converts TOSCA YAML InterfaceDefinitions to TOSCA XML Interface Additional TOSCA YAML element input with
+     * PropertyAssignment or PropertyDefinition is not converted
+     *
+     * @return TOSCA XML Interface
+     */
+    private List<TInterface> convert(Map<String, TInterfaceDefinition> nodes, String type) {
+        List<TInterface> output = new ArrayList<>();
+        for (Map.Entry<String, TInterfaceDefinition> node : nodes.entrySet()) {
+            if (type == null && node.getValue().getType() == null) {
+                output.add(convert(node.getValue(), node.getKey()));
+            } else if (type != null && node.getValue().getType() != null) {
+                if (node.getValue().getType().getLocalPart().equalsIgnoreCase(type)) {
+                    output.add(convert(node.getValue(), node.getKey()));
+                }
+            }
+        }
+        return output;
+    }
+
+    /**
+     * Converts TOSCA YAML RelationshipTemplate to TOSCA XML RelationshipTemplate Additional TOSCA YAML element
+     * interfaces is not converted
+     *
+     * @param node TOSCA YAML RelationshipTemplate
+     * @return TOSCA XML RelationshipTemplate
+     */
+    private TRelationshipTemplate convert(org.eclipse.winery.model.tosca.yaml.TRelationshipTemplate node, String id) {
+        if (node == null) {
+            return null;
+        }
+        // First, we find the source node template
+        TNodeTemplate sourceNT = this.nodeTemplateMap
+            .values()
+            .stream()
+            .filter(nodeTemplate -> nodeTemplate.getRequirements() != null &&
+                nodeTemplate
+                    .getRequirements()
+                    .getRequirement()
+                    .stream()
+                    .anyMatch(req -> req.getRelationship() != null && req.getRelationship().equals(id))
+            )
+            .findFirst()
+            .orElse(null);
+        if (sourceNT != null) {
+            // now we get the source requirement
+            assert sourceNT.getRequirements() != null;
+            TRequirement requirement = sourceNT
+                .getRequirements()
+                .getRequirement()
+                .stream()
+                .filter(req -> req.getRelationship() != null && req.getRelationship().equals(id))
+                .findFirst()
+                .orElse(null);
+
+            if (requirement != null) {
+                // now lets get the target capability
+                if (requirement.getNode() != null && requirement.getCapability() != null) {
+                    if (this.nodeTemplateMap.containsKey(requirement.getNode())) {
+                        TNodeTemplate targetNT = this.nodeTemplateMap.get(requirement.getNode());
+                        TCapability capability;
+
+                        if (targetNT.getCapabilities() != null &&
+                            targetNT.getCapabilities()
+                                .getCapability()
+                                .stream()
+                                .anyMatch(cap -> cap.getName().equals(requirement.getCapability()))) {
+                            capability =
+                                targetNT.getCapabilities()
+                                    .getCapability()
+                                    .stream()
+                                    .filter(cap -> cap.getName().equals(requirement.getCapability()))
+                                    .findFirst()
+                                    .orElse(null);
+                        } else {
+                            // the capability is not present in the node template. We take the default one from the node type!
+                            QName nodeTyp = targetNT.getType();
+                            TCapabilityDefinition capDef = this.getCapabilityDefinitionOfCapabilityName(requirement.getCapability(), nodeTyp);
+
+                            if (capDef != null) {
+                                String capId = targetNT.getName() + "_" + capDef.getName();
+                                capability = new TCapability
+                                    .Builder(capId, capDef.getCapabilityType(), capDef.getName())
+                                    .build();
+                                if (targetNT.getCapabilities() == null) {
+                                    targetNT.setCapabilities(new TNodeTemplate.Capabilities());
+                                }
+                                targetNT.getCapabilities().getCapability().add(capability);
+                            } else {
+                                LOGGER.error("The capability {} referenced by the relationship {} cannot be found!",
+                                    requirement.getCapability(), requirement.getName());
+                                throw new RuntimeException("Unable to convert relationship template: " + id);
+                            }
+                        }
+                        assert capability != null;
+                        TRelationshipTemplate.SourceOrTargetElement sourceElement = new TRelationshipTemplate.SourceOrTargetElement();
+                        sourceElement.setRef(requirement);
+                        TRelationshipTemplate.SourceOrTargetElement targetElement = new TRelationshipTemplate.SourceOrTargetElement();
+                        targetElement.setRef(capability);
+                        return new TRelationshipTemplate.Builder(id, node.getType(), sourceElement, targetElement)
+                            .setName(node.getType().getLocalPart())
+                            .setProperties(convertPropertyAssignments(node.getProperties()))
+                            .build();
+                    } else {
+                        LOGGER.error("the node {} specified by the requirement {} cannot be found!", requirement.getNode().toString(),
+                            requirement.getName());
+                    }
+                } else {
+                    LOGGER.error("requirement {} has no node or capability specified!", requirement.getName());
+                }
+            } else {
+                LOGGER.error("The source requirement for the relationship {} cannot be deteremined.", id);
+            }
+        } else {
+            LOGGER.error("The source node template for the relationship {} cannot be determined.", id);
+        }
+
+        throw new RuntimeException("Unable to convert relationship template: " + id);
+    }
+
+    /**
+     * Converts TOSCA YAML PolicyTypes to TOSCA XML  PolicyTypes Additional TOSCA YAML element triggers is not
+     * converted
+     *
+     * @param node TOSCA YAML PolicyType
+     * @return TOSCA XML PolicyType
+     */
+    private TPolicyType convert(org.eclipse.winery.model.tosca.yaml.TPolicyType node, String id) {
+        if (node == null) {
+            return null;
+        }
+
+        TPolicyType.Builder builder = new TPolicyType.Builder(id);
+        convert(node, builder);
+        builder.setAppliesTo(convertTargets(node.getTargets()));
+
+        return builder.build();
+    }
+
+    /**
+     * Converts TOSCA YAML PolicyDefinitions to TOSCA XML Policy and PolicyTemplate Additional TOSCA YAML element
+     * trigger is not converted
+     *
+     * @param node TOSCA YAML PolicyDefinition
+     */
+    private void convert(TPolicyDefinition node, String id) {
+        if (node == null) {
+            return;
+        }
+
+        TPolicyTemplate.Builder builder = new TPolicyTemplate.Builder(id + "_templ", node.getType());
+        builder.setName(id);
+        builder.setProperties(convertPropertyAssignments(node.getProperties()));
+        this.policyTemplates.add(builder.build());
+
+        TPolicy.Builder pbuilder = new TPolicy.Builder(node.getType());
+        pbuilder.setName(id);
+        pbuilder.setPolicyRef(new QName(id + "_templ"));
+
+        /* if PolicyDefinition has targets the resulting Policy is added to the target else its added to the
+         * BoundaryDefinition of the Service Template
+         */
+        if (node.getTargets() == null || node.getTargets().size() == 0) {
+            this.addPolicy("boundary", pbuilder.build());
+        } else {
+            for (QName target : node.getTargets()) {
+                this.addPolicy(target.toString(), pbuilder.build());
+            }
+        }
+    }
+
+    /**
+     * Adds TOSCA XML Policy to Map<String, TPolicy> policies
+     *
+     * @param target Key of the map
+     */
+    private void addPolicy(String target, TPolicy policy) {
+        if (this.policies.containsKey(target)) {
+            this.policies.get(target).add(policy);
+        } else {
+            List<TPolicy> policies = new ArrayList<>();
+            policies.add(policy);
+            this.policies.put(target, policies);
+        }
+    }
+
+    /**
+     * Converts TOSCA YAML TImportDefinitions and returns list of TOSCA XML TImports
+     */
+    private TImport convert(TImportDefinition node, String name) {
+//        Reader reader = Reader.getReader();
+//        String namespace = node.getNamespaceUri() == null ? this.namespace : node.getNamespaceUri();
+//        try {
+//            org.eclipse.winery.model.tosca.yaml.TServiceTemplate serviceTemplate = reader.readImportDefinition(node, path, namespace);
+//            Converter converter = new Converter(this.repository);
+//            Definitions definitions = converter.convertY2X(serviceTemplate, getFileNameFromFile(node.getFile()), namespace, path, outPath);
+//            WriterUtils.saveDefinitions(definitions, outPath, namespace, name);
+//            TImport.Builder builder = new TImport.Builder(Namespaces.XML_NS);
+//            builder.setLocation(WriterUtils.getDefinitionsLocation(namespace, name));
+//            builder.setNamespace(namespace);
+//            return builder.build();
+//        } catch (MultiException e) {
+//            e.printStackTrace();
+//        }
+        return null;
+    }
+
+    private String getFileNameFromFile(String filename) {
+        return filename.substring(filename.lastIndexOf(File.separator) + 1, filename.lastIndexOf("."));
+    }
+
+    /**
+     * Convert A list of TOSCA YAML PolicyType targets to TOSCA XML PolicyType AppliesTo
+     *
+     * @param targetList list of TOSCA YAML PolicyType targets
+     * @return TOSCA XML PolicyType AppliesTo
+     */
+    private TAppliesTo convertTargets(List<QName> targetList) {
+        if (targetList == null || targetList.size() == 0) {
+            return null;
+        }
+
+        List<TAppliesTo.NodeTypeReference> references = new ArrayList<>();
+        for (QName nodeRef : targetList) {
+            TAppliesTo.NodeTypeReference ref = new TAppliesTo.NodeTypeReference();
+            ref.setTypeRef(nodeRef);
+            references.add(ref);
+        }
+
+        TAppliesTo appliesTo = new TAppliesTo();
+        appliesTo.getNodeTypeReference().addAll(references);
+        return appliesTo;
+    }
+
+    /**
+     * Converts a map of TOSCA YAML PropertyAssignment to TOSCA XML EntityTemplate.Properties
+     */
+    private TEntityTemplate.Properties convertPropertyAssignments(Map<String, TPropertyAssignment> propertyMap) {
+        if (Objects.isNull(propertyMap) || propertyMap.isEmpty()) return null;
+        //properties.setAny(assignmentBuilder.getAssignment(propertyMap, type));
+        return new TEntityTemplate.Properties();
+    }
+
+    /**
+     * Converts TOSCA YAML ArtifactDefinitions to TOSCA XML NodeTypeImplementations and ArtifactTemplates
+     */
+    private void convertNodeTypeImplementation(
+        Map<String, TArtifactDefinition> implArtifacts,
+        Map<String, TArtifactDefinition> deplArtifacts, String type, String targetNamespace) {
+        for (Map.Entry<String, TArtifactDefinition> implArtifact : implArtifacts.entrySet()) {
+            for (Map.Entry<String, TArtifactDefinition> deplArtifact : deplArtifacts.entrySet()) {
+                if (implArtifact.getKey().equalsIgnoreCase(deplArtifact.getKey())) {
+                    deplArtifacts.remove(deplArtifact.getKey());
+                }
+            }
+        }
+        TNodeTypeImplementation.Builder builder = (new TNodeTypeImplementation.Builder(type + "_impl", new QName(targetNamespace, type))
+            .setTargetNamespace(targetNamespace)
+            .setDeploymentArtifacts(convertDeploymentArtifacts(deplArtifacts, targetNamespace))
+        );
+        TImplementationArtifacts implementationArtifacts = convertImplementationArtifact(implArtifacts, targetNamespace);
+        builder.setImplementationArtifacts(implementationArtifacts);
+        this.nodeTypeImplementations.add(builder.build());
+    }
+
+    /**
+     * Converts TOSCA YAML ArtifactDefinitions to TOSCA XML NodeTypeImplementations and ArtifactTemplates
+     */
+    private void convertRelationshipTypeImplementation(
+        Map<String, TInterfaceDefinition> implArtifacts, String type, String targetNamespace) {
+        this.relationshipTypeImplementations.add(new TRelationshipTypeImplementation.Builder(type + "_impl", new QName(targetNamespace, type))
+            .setTargetNamespace(targetNamespace)
+            .addImplementationArtifacts(convertImplmentationsFromInterfaces(implArtifacts, targetNamespace))
+            .build()
+        );
+    }
+
+    private List<TImplementationArtifacts.ImplementationArtifact> convertImplmentationsFromInterfaces(Map<String, TInterfaceDefinition> interfaces, String targetNamespace) {
+        QName type = new QName("http://opentosca.org/artifacttypes", "ScriptArtifact");
+        List<TImplementationArtifacts.ImplementationArtifact> output = new ArrayList<>();
+        for (Map.Entry<String, TInterfaceDefinition> interfaceDefinitionEntry : interfaces.entrySet()) {
+            if (interfaceDefinitionEntry.getValue() != null) {
+                if (interfaceDefinitionEntry.getValue().getOperations() != null) {
+                    for (Map.Entry<String, TOperationDefinition> operation : interfaceDefinitionEntry.getValue().getOperations().entrySet()) {
+                        if (operation.getValue().getImplementation() != null) {
+                            if (operation.getValue().getImplementation().getPrimary() != null) {
+                                if (operation.getValue().getImplementation().getPrimary().getLocalPart().contains("/")) {
+                                    TArtifactTemplate artifactTemplate = new TArtifactTemplate.Builder(operation.getKey(), type)
+                                        .addArtifactReferences((new TArtifactReference.Builder(operation.getValue().getImplementation().getPrimary().getLocalPart())).build())
+                                        .build();
+                                    this.artifactTemplates.put(operation.getKey(), artifactTemplate);
+                                    output.add(new TImplementationArtifacts.ImplementationArtifact.Builder(artifactTemplate.getType())
+                                        .setName(operation.getKey())
+                                        .setArtifactRef(new QName(targetNamespace, artifactTemplate.getId()))
+                                        .setInterfaceName(interfaceDefinitionEntry.getKey())
+                                        .setOperationName(operation.getKey())
+                                        .build());
+                                } else if (!operation.getValue().getImplementation().getPrimary().getLocalPart().equalsIgnoreCase("null")) {
+                                    TArtifactTemplate artifactTemplate = new TArtifactTemplate.Builder(operation.getValue().getImplementation().getPrimary().getLocalPart(), type)
+                                        .build();
+                                    this.artifactTemplates.put(operation.getValue().getImplementation().getPrimary().getLocalPart(), artifactTemplate);
+                                    output.add(new TImplementationArtifacts.ImplementationArtifact.Builder(artifactTemplate.getType())
+                                        .setName(operation.getKey())
+                                        .setArtifactRef(new QName(targetNamespace, artifactTemplate.getId()))
+                                        .setInterfaceName(interfaceDefinitionEntry.getKey())
+                                        .setOperationName(operation.getKey())
+                                        .build());
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        if (output.isEmpty()) {
+            return null;
+        }
+        return output;
+    }
+
+    private TOperation convert(TOperationDefinition node, String id) {
+        return new TOperation.Builder(id)
+            .addDocumentation(node.getDescription())
+            .addInputParameters(convertParameters(node.getInputs()))
+            .addOutputParameters(convertParameters(node.getOutputs()))
+            .build();
+    }
+
+    private List<TParameter> convertParameters(Map<String, TPropertyAssignmentOrDefinition> node) {
+        return node.entrySet().stream()
+            .map(entry -> {
+                if (entry.getValue() instanceof TPropertyDefinition) {
+                    return convertParameter((TPropertyDefinition) entry.getValue(), entry.getKey());
+                } else {
+                    return null;
+                }
+            }).filter(Objects::nonNull)
+            .collect(Collectors.toList());
+    }
+
+    private TParameter convertParameter(TPropertyDefinition node, String id) {
+        return new TParameter.Builder(
+            id,
+            TypeConverter.INSTANCE.convert(node.getType()).getLocalPart(),
+            node.getRequired()
+        ).build();
+    }
+
+    public void convert(TAttributeDefinition node, String id) {
+        // Attributes are not converted
+    }
+
+    private Object convert(org.eclipse.winery.model.tosca.yaml.TGroupType node, String name) {
+        // GroupTypes are not converted
+        return null;
+    }
+
+    public Object convert(org.eclipse.winery.model.tosca.yaml.TDataType node, String name) {
+        TImport importDefinition = new TImport.Builder(Namespaces.XML_NS)
+            .setLocation(Util.URLencode(this.namespace) + ".xsd")
+            .build();
+        if (!this.imports.contains(importDefinition)) {
+            this.imports.add(importDefinition);
+        }
+        return null;
+    }
+
+    @SuppressWarnings( {"unchecked"})
+    private <V, T> List<T> convert(List<? extends Map<String, V>> node) {
+        return node.stream()
+            .flatMap(map -> map.entrySet().stream())
+            .map((Map.Entry<String, V> entry) -> {
+                if (entry.getValue() instanceof TImportDefinition) {
+                    return (T) convert((TImportDefinition) entry.getValue(), entry.getKey());
+                } else if (entry.getValue() instanceof org.eclipse.winery.model.tosca.yaml.TRequirementDefinition) {
+                    return (T) convert((org.eclipse.winery.model.tosca.yaml.TRequirementDefinition) entry.getValue(), entry.getKey());
+                } else if (entry.getValue() instanceof TRequirementAssignment) {
+                    return (T) convert((TRequirementAssignment) entry.getValue(), entry.getKey());
+                } else {
+                    V v = entry.getValue();
+                    assert (v instanceof TImportDefinition ||
+                        v instanceof org.eclipse.winery.model.tosca.yaml.TRequirementDefinition ||
+                        v instanceof TRequirementAssignment);
+                    return null;
+                }
+            })
+            .filter(Objects::nonNull)
+            .collect(Collectors.toList());
+    }
+
+    @SuppressWarnings( {"unchecked"})
+    private <V, T> List<T> convert(@NonNull Map<String, V> map) {
+        return map.entrySet().stream()
+            .map((Map.Entry<String, V> entry) -> {
+                if (entry.getValue() == null) {
+                    return null;
+                } else if (entry.getValue() instanceof org.eclipse.winery.model.tosca.yaml.TRelationshipType) {
+                    return convert((org.eclipse.winery.model.tosca.yaml.TRelationshipType) entry.getValue(), entry.getKey());
+                } else if (entry.getValue() instanceof org.eclipse.winery.model.tosca.yaml.TRelationshipTemplate) {
+                    return convert((org.eclipse.winery.model.tosca.yaml.TRelationshipTemplate) entry.getValue(), entry.getKey());
+                } else if (entry.getValue() instanceof org.eclipse.winery.model.tosca.yaml.TArtifactType) {
+                    return convert((org.eclipse.winery.model.tosca.yaml.TArtifactType) entry.getValue(), entry.getKey());
+                } else if (entry.getValue() instanceof TArtifactDefinition) {
+                    return convert((TArtifactDefinition) entry.getValue(), entry.getKey());
+                } else if (entry.getValue() instanceof org.eclipse.winery.model.tosca.yaml.TCapabilityType) {
+                    return convert((org.eclipse.winery.model.tosca.yaml.TCapabilityType) entry.getValue(), entry.getKey());
+                } else if (entry.getValue() instanceof org.eclipse.winery.model.tosca.yaml.TCapabilityDefinition) {
+                    return convert((org.eclipse.winery.model.tosca.yaml.TCapabilityDefinition) entry.getValue(), entry.getKey());
+                } else if (entry.getValue() instanceof org.eclipse.winery.model.tosca.yaml.TPolicyType) {
+                    return convert((org.eclipse.winery.model.tosca.yaml.TPolicyType) entry.getValue(), entry.getKey());
+                } else if (entry.getValue() instanceof org.eclipse.winery.model.tosca.yaml.TRequirementDefinition) {
+                    return convert((org.eclipse.winery.model.tosca.yaml.TRequirementDefinition) entry.getValue(), entry.getKey());
+                } else if (entry.getValue() instanceof TInterfaceType) {
+                    assert (!interfaceTypes.containsKey(new QName(entry.getKey())));
+                    this.interfaceTypes.put(new QName(entry.getKey()), (TInterfaceType) entry.getValue());
+                    return null;
+                } else if (entry.getValue() instanceof TInterfaceDefinition) {
+                    return convert((TInterfaceDefinition) entry.getValue(), entry.getKey());
+                } else if (entry.getValue() instanceof TOperationDefinition) {
+                    return convert((TOperationDefinition) entry.getValue(), entry.getKey());
+                } else if (entry.getValue() instanceof org.eclipse.winery.model.tosca.yaml.TNodeTemplate) {
+                    return convert((org.eclipse.winery.model.tosca.yaml.TNodeTemplate) entry.getValue(), entry.getKey());
+                } else if (entry.getValue() instanceof org.eclipse.winery.model.tosca.yaml.TDataType) {
+                    return convert((org.eclipse.winery.model.tosca.yaml.TDataType) entry.getValue(), entry.getKey());
+                } else if (entry.getValue() instanceof org.eclipse.winery.model.tosca.yaml.TGroupType) {
+                    return convert((org.eclipse.winery.model.tosca.yaml.TGroupType) entry.getValue(), entry.getKey());
+                } else if (entry.getValue() instanceof org.eclipse.winery.model.tosca.yaml.TNodeType) {
+                    return convert((org.eclipse.winery.model.tosca.yaml.TNodeType) entry.getValue(), entry.getKey());
+                } else if (entry.getValue() instanceof TImportDefinition) {
+                    return convert((TImportDefinition) entry.getValue(), entry.getKey());
+                } else if (entry.getValue() instanceof org.eclipse.winery.model.tosca.yaml.TPolicyType) {
+                    return convert((org.eclipse.winery.model.tosca.yaml.TPolicyType) entry.getValue(), entry.getKey());
+                } else if (entry.getValue() instanceof TCapabilityAssignment) {
+                    return convert((TCapabilityAssignment) entry.getValue(), entry.getKey());
+                } else {
+                    V v = entry.getValue();
+                    System.err.println(v);
+                    assert (v instanceof org.eclipse.winery.model.tosca.yaml.TRelationshipType ||
+                        v instanceof org.eclipse.winery.model.tosca.yaml.TRelationshipTemplate ||
+                        v instanceof org.eclipse.winery.model.tosca.yaml.TArtifactType ||
+                        v instanceof TArtifactDefinition ||
+                        v instanceof org.eclipse.winery.model.tosca.yaml.TCapabilityType ||
+                        v instanceof org.eclipse.winery.model.tosca.yaml.TCapabilityDefinition ||
+                        v instanceof TCapabilityAssignment ||
+                        v instanceof org.eclipse.winery.model.tosca.yaml.TPolicyType ||
+                        v instanceof org.eclipse.winery.model.tosca.yaml.TRequirementDefinition ||
+                        v instanceof TInterfaceType ||
+                        v instanceof TInterfaceDefinition ||
+                        v instanceof TOperationDefinition ||
+                        v instanceof org.eclipse.winery.model.tosca.yaml.TNodeTemplate ||
+                        v instanceof org.eclipse.winery.model.tosca.yaml.TDataType ||
+                        v instanceof org.eclipse.winery.model.tosca.yaml.TGroupType ||
+                        v instanceof org.eclipse.winery.model.tosca.yaml.TNodeType ||
+                        v instanceof TImportDefinition ||
+                        v instanceof TPolicyDefinition
+                    );
+                    return null;
+                }
+            })
+            .flatMap(entry -> {
+                if (entry instanceof List) {
+                    return ((List<T>) entry).stream();
+                } else {
+                    return (Stream<T>) Stream.of(entry);
+                }
+            })
+            .filter(Objects::nonNull)
+            .collect(Collectors.toList());
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/Defaults.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/Defaults.java
new file mode 100644
index 000000000..5ce7c0ffa
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/Defaults.java
@@ -0,0 +1,103 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import javax.xml.namespace.QName;
+
+public class Defaults {
+    public static final String TOSCA_NORMATIVE_TYPES = "tosca_simple_yaml_1_1.yml";
+    public static final String TOSCA_NONNORMATIVE_TYPES = "tosca_simple_yaml_non-normative_1_1.yml";
+    public static final List<String> YAML_TYPES = new ArrayList<>(Arrays.asList("string", "integer", "float", "boolean", "timestamp", "null"));
+    public static final List<String> TOSCA_TYPES = new ArrayList<>(Arrays.asList("list", "map"));
+    public static final String TOSCA_DEFINITIONS_VERSION_PATTERN = "tosca_simple_yaml_\\d_\\d|http://docs\\.oasis-open\\.org/tosca/ns/simple/yaml/\\d\\.\\d";
+    public static final List<String> TOSCA_NORMATIVE_NAMES = new ArrayList<>(Arrays.asList(
+        "tosca.datatypes.Root",
+        "tosca.datatypes.TimeInterval", "TimeInterval",
+        "tosca.datatypes.network.NetworkInfo", "NetworkInfo",
+        "tosca.datatypes.network.PortInfo", "PortInfo",
+        "tosca.datatypes.network.PortDef", "PortDef",
+        "tosca.datatypes.network.PortSpec", "PortSpec",
+        "tosca.artifacts.Root",
+        "tosca.artifacts.File", "File",
+        "tosca.artifacts.Deployment",
+        "tosca.artifacts.Deployment.Image", "Deployment.Image",
+        "tosca.artifacts.Deployment.Image.VM",
+        "tosca.artifacts.Implementation",
+        "tosca.artifacts.Implementation.Bash", "Bash",
+        "tosca.artifacts.Implementation.Python", "Python",
+        "tosca.capabilities.Root",
+        "tosca.capabilities.Node", "Node",
+        "tosca.capabilities.Compute", "Compute",
+        "tosca.capabilities.Network", "Network",
+        "tosca.capabilities.Storage", "Storage",
+        "tosca.capabilities.Container", "Container",
+        "tosca.capabilities.Endpoint", "Endpoint",
+        "tosca.capabilities.Endpoint.Public", "Endpoint.Public",
+        "tosca.capabilities.Endpoint.Admin", "Endpoint.Admin",
+        "tosca.capabilities.Endpoint.Database", "Endpoint.Database",
+        "tosca.capabilities.Attachment", "Attachment",
+        "tosca.capabilities.OperatingSystem", "OperatingSystem",
+        "tosca.capabilities.Scalable", "Scalable",
+        "tosca.capabilities.network.Bindable", "network.Bindable",
+        "tosca.relationships.Root",
+        "tosca.relationships.DependsOn", "DependsOn",
+        "tosca.relationships.HostedOn", "HostedOn",
+        "tosca.relationships.ConnectsTo", "ConnectsTo",
+        "tosca.relationships.AttachesTo", "AttachesTo",
+        "tosca.relationships.RoutesTo", "RoutesTo",
+        "tosca.interfaces.Root",
+        "tosca.interfaces.node.lifecycle.Standard", "Standard",
+        "tosca.interfaces.relationship.Configure", "Configure",
+        "tosca.nodes.Root",
+        "tosca.nodes.Compute", "Compute",
+        "tosca.nodes.SoftwareComponent", "SoftwareComponent",
+        "tosca.nodes.WebServer", "WebServer",
+        "tosca.nodes.WebApplication", "WebApplication",
+        "tosca.nodes.DBMS",
+        "tosca.nodes.Database", "Database",
+        "tosca.nodes.Storage.ObjectStorage", "ObjectStorage",
+        "tosca.nodes.Storage.BlockStorage", "BlockStorage",
+        "tosca.nodes.Container.Runtime", "Container.Runtime",
+        "tosca.nodes.Container.Application", "Container.Application",
+        "tosca.nodes.LoadBalancer", "LoadBalancer",
+        "tosca.groups.Root",
+        "tosca.policies.Root",
+        "tosca.policies.Placement",
+        "tosca.policies.Scaling",
+        "tosca.policies.Update",
+        "tosca.policies.Performance"));
+
+    public static final List<String> TOSCA_NONNORMATIVE_NAMES = new ArrayList<>(Arrays.asList(
+        "tosca.artifacts.Deployment.Image.Container.Docker", "Image.Container.Docker",
+        "tosca.artifacts.Deployment.Image.VM.ISO", "Image.VM.ISO",
+        "tosca.artifacts.Deployment.Image.VM.QCOW2", "Image.VM.QCOW2",
+        "tosca.capabilities.Container.Docker", "Container.Docker",
+        "tosca.nodes.Database.MySQL", "Database.MySQL",
+        "tosca.nodes.DBMS.MySQL", "DBMS.MySQL",
+        "tosca.nodes.WebServer.Apache", "Apache",
+        "tosca.nodes.WebApplication.WordPress", "WordPress",
+        "tosca.nodes.WebServer.Nodejs", "Nodejs",
+        "tosca.nodes.Container.Application.Docker", "Application.Docker"
+    ));
+
+    public static final QName IMPLEMENTATION_ARTIFACTS = new QName(Namespaces.TOSCA_NS, "tosca.artifacts.Implementation");
+    public static final QName DEPLOYMENT_ARTIFACTS = new QName(Namespaces.TOSCA_NS, "tosca.artifacts.Deployment");
+
+    public static final String X_COORD = "x";
+    public static final String Y_COORD = "y";
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/Namespaces.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/Namespaces.java
new file mode 100644
index 000000000..61c9f9fcb
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/Namespaces.java
@@ -0,0 +1,27 @@
+/********************************************************************************
+ * Copyright (c) 2017-2018 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support;
+
+import javax.xml.XMLConstants;
+
+/**
+ * Defines namespaces of YAML and related ones. For general namespaces used in Winery, see {@link
+ * org.eclipse.winery.model.tosca.constants.Namespaces}
+ */
+public class Namespaces {
+    public static final String TOSCA_NS = "http://docs.oasis-open.org/tosca/ns/simple/yaml/1.1";
+    public static final String DEFAULT_NS = "http://www.eclipse.org/winery/ns/simple/yaml/1.1/default";
+    public static final String YAML_NS = "http://www.yaml.org/type";
+    public static final String XML_NS = XMLConstants.W3C_XML_SCHEMA_NS_URI;
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/Parameter.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/Parameter.java
new file mode 100644
index 000000000..304d96e07
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/Parameter.java
@@ -0,0 +1,88 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support;
+
+import java.nio.file.Path;
+
+import javax.xml.namespace.QName;
+
+import org.eclipse.winery.model.tosca.yaml.visitor.AbstractParameter;
+
+public class Parameter extends AbstractParameter<Parameter> {
+    private final String namespace;
+    private Path path;
+    // SchemaVisitor
+    private QName datatype;
+    private Boolean buildSchema;
+    private Boolean buildComplexType;
+
+    public Parameter(Path path, String namespace) {
+        this.namespace = namespace;
+        this.path = path;
+        this.buildSchema = true;
+        this.buildComplexType = true;
+    }
+
+    public Path getPath() {
+        return path;
+    }
+
+    public Parameter setPath(Path path) {
+        this.path = path;
+        return this;
+    }
+
+    public String getNamespace() {
+        return namespace;
+    }
+
+    public QName getDatatype() {
+        return this.datatype;
+    }
+
+    public Parameter setDatatype(QName datatype) {
+        this.datatype = datatype;
+        return this;
+    }
+
+    public Boolean getBuildComplexType() {
+        return buildComplexType;
+    }
+
+    public Parameter setBuildComplexType(Boolean buildComplexType) {
+        this.buildComplexType = buildComplexType;
+        return this;
+    }
+
+    public Boolean getBuildSchema() {
+        return buildSchema;
+    }
+
+    public Parameter setBuildSchema(Boolean buildSchema) {
+        this.buildSchema = buildSchema;
+        return this;
+    }
+
+    @Override
+    public Parameter copy() {
+        Parameter parameter = new Parameter(this.path, this.namespace);
+        parameter.getContext().addAll(this.getContext());
+        return parameter.setDatatype(this.datatype).setBuildSchema(this.buildSchema);
+    }
+
+    @Override
+    public Parameter self() {
+        return this;
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/Utils.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/Utils.java
new file mode 100644
index 000000000..367ba8dec
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/Utils.java
@@ -0,0 +1,123 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.Objects;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipInputStream;
+import java.util.zip.ZipOutputStream;
+
+import org.eclipse.winery.repository.backend.filebased.FileUtils;
+
+import org.apache.commons.codec.digest.DigestUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class Utils {
+    private static final Logger logger = LoggerFactory.getLogger(Utils.class);
+    private static Path tmpBase;
+
+    public static String getFile(String path, String name) {
+        return path + File.separator + name;
+    }
+
+    public static String getFileName(String file) {
+        return file.substring(file.lastIndexOf(File.separator) + 1);
+    }
+
+    public static String getFileName(File file) {
+        return file.getName();
+    }
+
+    public static Path unzipFile(InputStream in) {
+        Path dir = Utils.getTmpDir(Paths.get("zip"));
+        FileUtils.forceDelete(dir);
+        try (ZipInputStream inputStream = new ZipInputStream(in)) {
+            ZipEntry entry;
+            while (Objects.nonNull(entry = inputStream.getNextEntry())) {
+                if (!entry.isDirectory()) {
+                    Path targetPath = dir.resolve(entry.getName());
+                    Files.createDirectories(targetPath.getParent());
+                    Files.copy(inputStream, targetPath);
+                    logger.debug("Write tmp file: {}", targetPath.toString());
+                }
+            }
+        } catch (Exception e) {
+            logger.error("Create zip tmp file error: ", e);
+        }
+        return dir;
+    }
+
+    public static InputStream zipPath(Path path) {
+        File zipFile = new File(path.getParent().toString() + File.separator + "tmp.zip");
+        try (
+            FileOutputStream fos = new FileOutputStream(zipFile);
+            ZipOutputStream zos = new ZipOutputStream(fos)
+        ) {
+            Files.walk(path)
+                .filter(Files::isRegularFile)
+                .forEach(file -> {
+                    try {
+                        zos.putNextEntry(new ZipEntry(path.relativize(file).toString()));
+                        Files.copy(file, zos);
+                        zos.closeEntry();
+                    } catch (Exception e) {
+
+                    }
+                });
+            return new FileInputStream(zipFile);
+        } catch (Exception e) {
+            logger.error("Create zip tmp file error: ", e);
+        }
+        return null;
+    }
+
+    public static Path getTmpDir(Path path) {
+        try {
+            if (Objects.isNull(tmpBase)) {
+                tmpBase = Files.createTempDirectory("winery");
+            }
+        } catch (Exception e) {
+            logger.error("Failed to create tmp dir with name 'winery'", e);
+        }
+
+        Path result = tmpBase.resolve(path);
+        try {
+            Files.createDirectories(result);
+        } catch (IOException e) {
+            logger.error("Failed to create tmp dir '{}':\n {}", result, e);
+        }
+        return result;
+    }
+
+    public static void deleteTmpDir(Path path) {
+        try {
+            Files.deleteIfExists(tmpBase);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static byte[] getHashValueOfFile(File file) throws IOException {
+        return DigestUtils.md5(new FileInputStream(file));
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/ValueConverter.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/ValueConverter.java
new file mode 100644
index 000000000..662378ecc
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/ValueConverter.java
@@ -0,0 +1,27 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support;
+
+public class ValueConverter {
+    public static ValueConverter INSTANCE = new ValueConverter();
+
+    public String convert(String value) {
+        if (value.matches("get_input:.*")) return "{ ".concat(value.trim()).concat(" }");
+        return value;
+    }
+
+    public String convert(Object value) {
+        return convert(value.toString());
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/ExceptionHierarchy.yml b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/ExceptionHierarchy.yml
new file mode 100644
index 000000000..1ec0327b5
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/ExceptionHierarchy.yml
@@ -0,0 +1,29 @@
+MultiException: *
+  - YamlParserException
+
+YamlParserException:
+  Invalid:
+    InvalidSyntax:
+      InvalidYamlSyntax
+      InvalidToscaSyntax:
+        InvalidDefinition
+    InvalidType:
+      InvalidParentType
+      InvalidTypeExtend
+    InvalidField:
+      InvalidToscaVersion
+  Undefined:
+    UndefinedType
+    UndefinedDefinition
+    UndefinedPrefix
+    UndefinedField:
+      UndefinedToscaVersion
+      UndefinedRequiredKeyname
+    UndefinedFile:
+      UndefinedImport
+
+Explanation:
+  Undefined: Something is used but not defined or missing
+  Invalid:
+    - Something is used defined but wrong
+    - Something is missing but MUST be used and defined
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/Invalid.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/Invalid.java
new file mode 100644
index 000000000..07dfee0b9
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/Invalid.java
@@ -0,0 +1,20 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.exception;
+
+public abstract class Invalid extends YAMLParserException {
+    public Invalid(String messagePattern, Object... args) {
+        super(messagePattern, args);
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/InvalidDefinition.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/InvalidDefinition.java
new file mode 100644
index 000000000..e8d9cb4d8
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/InvalidDefinition.java
@@ -0,0 +1,20 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.exception;
+
+public class InvalidDefinition extends InvalidToscaSyntax {
+    public InvalidDefinition(String messagePattern, Object... args) {
+        super(messagePattern, args);
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/InvalidField.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/InvalidField.java
new file mode 100644
index 000000000..46800d598
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/InvalidField.java
@@ -0,0 +1,20 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.exception;
+
+public class InvalidField extends Invalid {
+    public InvalidField(String messagePattern, Object... args) {
+        super(messagePattern, args);
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/InvalidParentType.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/InvalidParentType.java
new file mode 100644
index 000000000..cfb11af1e
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/InvalidParentType.java
@@ -0,0 +1,20 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.exception;
+
+public class InvalidParentType extends InvalidType {
+    public InvalidParentType(String messagePattern, Object... args) {
+        super(messagePattern, args);
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/InvalidSyntax.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/InvalidSyntax.java
new file mode 100644
index 000000000..1830725dd
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/InvalidSyntax.java
@@ -0,0 +1,20 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.exception;
+
+public class InvalidSyntax extends Invalid {
+    public InvalidSyntax(String messagePattern, Object... args) {
+        super(messagePattern, args);
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/InvalidToscaSyntax.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/InvalidToscaSyntax.java
new file mode 100644
index 000000000..74c462930
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/InvalidToscaSyntax.java
@@ -0,0 +1,20 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ ********************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.exception;
+
+public class InvalidToscaSyntax extends InvalidSyntax {
+    public InvalidToscaSyntax(String messagePattern, Object... args) {
+        super(messagePattern, args);
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/InvalidToscaVersion.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/InvalidToscaVersion.java
new file mode 100644
index 000000000..6e71bef84
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/InvalidToscaVersion.java
@@ -0,0 +1,20 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ ********************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.exception;
+
+public class InvalidToscaVersion extends InvalidField {
+    public InvalidToscaVersion(String messagePattern, Object... args) {
+        super(messagePattern, args);
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/InvalidType.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/InvalidType.java
new file mode 100644
index 000000000..76a633659
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/InvalidType.java
@@ -0,0 +1,20 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.exception;
+
+public class InvalidType extends Invalid {
+    public InvalidType(String messagePattern, Object... args) {
+        super(messagePattern, args);
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/InvalidTypeExtend.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/InvalidTypeExtend.java
new file mode 100644
index 000000000..37d208d68
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/InvalidTypeExtend.java
@@ -0,0 +1,20 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.exception;
+
+public class InvalidTypeExtend extends InvalidType {
+    public InvalidTypeExtend(String messagePattern, Object... args) {
+        super(messagePattern, args);
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/InvalidYamlSyntax.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/InvalidYamlSyntax.java
new file mode 100644
index 000000000..7cb0fef5e
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/InvalidYamlSyntax.java
@@ -0,0 +1,20 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.exception;
+
+public class InvalidYamlSyntax extends InvalidSyntax {
+    public InvalidYamlSyntax(String messagePattern, Object... args) {
+        super(messagePattern, args);
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/MultiException.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/MultiException.java
new file mode 100644
index 000000000..b10e93282
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/MultiException.java
@@ -0,0 +1,78 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.exception;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
+import java.util.stream.Collectors;
+
+public class MultiException extends Exception {
+    private List<Exception> exceptions;
+    private List<String> context;
+
+    public MultiException() {
+        this.exceptions = new ArrayList<>();
+        this.context = new ArrayList<>();
+    }
+
+    public String getMessage() {
+        return "\n".concat(this.exceptions.stream()
+            .filter(Objects::nonNull)
+            .map(exception -> exception.getClass().getSimpleName().concat(":\n   ")
+                .concat(exception.getMessage().replaceAll("\n(?!\n)", "\n   "))
+            )
+            .collect(Collectors.joining("\n")))
+            .concat("\nMultiException Context = ")
+            .concat(context.stream()
+                .collect(Collectors.joining("\n   "))
+            );
+    }
+
+    public MultiException add(Exception exception) {
+        exceptions.add(exception);
+        return this;
+    }
+
+    public MultiException add(List<Exception> exceptions) {
+        this.exceptions.addAll(exceptions);
+        return this;
+    }
+
+    public MultiException add(String context) {
+        this.context.add(context);
+        return this;
+    }
+
+    public Exception getException() {
+        if (exceptions.size() == 1) {
+            if (exceptions.get(0) instanceof MultiException) {
+                return ((MultiException) exceptions.get(0)).getException();
+            } else {
+                return exceptions.get(0);
+            }
+        } else {
+            return this;
+        }
+    }
+
+    public boolean hasException() {
+        return !isEmpty();
+    }
+
+    public boolean isEmpty() {
+        return exceptions.isEmpty();
+    }
+} 
+
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/Undefined.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/Undefined.java
new file mode 100644
index 000000000..38730c3f2
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/Undefined.java
@@ -0,0 +1,20 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.exception;
+
+public class Undefined extends YAMLParserException {
+    public Undefined(String messagePattern, Object... args) {
+        super(messagePattern, args);
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/UndefinedDefinition.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/UndefinedDefinition.java
new file mode 100644
index 000000000..0d4420040
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/UndefinedDefinition.java
@@ -0,0 +1,20 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.exception;
+
+public class UndefinedDefinition extends Undefined {
+    public UndefinedDefinition(String messagePattern, Object... args) {
+        super(messagePattern, args);
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/UndefinedField.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/UndefinedField.java
new file mode 100644
index 000000000..d125a9910
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/UndefinedField.java
@@ -0,0 +1,20 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.exception;
+
+public class UndefinedField extends Undefined {
+    public UndefinedField(String messagePattern, Object... args) {
+        super(messagePattern, args);
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/UndefinedFile.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/UndefinedFile.java
new file mode 100644
index 000000000..edcc24dfa
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/UndefinedFile.java
@@ -0,0 +1,20 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.exception;
+
+public class UndefinedFile extends Undefined {
+    public UndefinedFile(String messagePattern, Object... args) {
+        super(messagePattern, args);
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/UndefinedImport.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/UndefinedImport.java
new file mode 100644
index 000000000..2610d741f
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/UndefinedImport.java
@@ -0,0 +1,20 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.exception;
+
+public class UndefinedImport extends UndefinedFile {
+    public UndefinedImport(String messagePattern, Object... args) {
+        super(messagePattern, args);
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/UndefinedPrefix.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/UndefinedPrefix.java
new file mode 100644
index 000000000..2098cc0c2
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/UndefinedPrefix.java
@@ -0,0 +1,20 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.exception;
+
+public class UndefinedPrefix extends Undefined {
+    public UndefinedPrefix(String messagePattern, Object... args) {
+        super(messagePattern, args);
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/UndefinedRequiredKeyname.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/UndefinedRequiredKeyname.java
new file mode 100644
index 000000000..957df4d2d
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/UndefinedRequiredKeyname.java
@@ -0,0 +1,20 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.exception;
+
+public class UndefinedRequiredKeyname extends UndefinedField {
+    public UndefinedRequiredKeyname(String messagePattern, Object... args) {
+        super(messagePattern, args);
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/UndefinedToscaVersion.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/UndefinedToscaVersion.java
new file mode 100644
index 000000000..ba9bc03a8
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/UndefinedToscaVersion.java
@@ -0,0 +1,20 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.exception;
+
+public class UndefinedToscaVersion extends UndefinedField {
+    public UndefinedToscaVersion(String messagePattern, Object... args) {
+        super(messagePattern, args);
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/UndefinedType.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/UndefinedType.java
new file mode 100644
index 000000000..bfed38b31
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/UndefinedType.java
@@ -0,0 +1,20 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.exception;
+
+public class UndefinedType extends Undefined {
+    public UndefinedType(String messagePattern, Object... args) {
+        super(messagePattern, args);
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/YAMLParserException.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/YAMLParserException.java
new file mode 100644
index 000000000..89a4b505b
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/exception/YAMLParserException.java
@@ -0,0 +1,64 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.exception;
+
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Objects;
+
+import org.eclipse.jdt.annotation.NonNull;
+import org.slf4j.helpers.MessageFormatter;
+
+public abstract class YAMLParserException extends Exception {
+    private List<Object> argArray;
+    private String inlineContext;
+    private Path fileContext;
+
+    public YAMLParserException(@NonNull String messagePattern, Object... args) {
+        super(messagePattern);
+        argArray = new ArrayList<>();
+        if (Objects.nonNull(args)) argArray.addAll(Arrays.asList(args));
+    }
+
+    public YAMLParserException setContext(List<String> context) {
+        inlineContext = String.join(":", context);
+        return this;
+    }
+
+    public String getMessage() {
+        return MessageFormatter.arrayFormat(
+            super.getMessage(),
+            argArray.toArray()
+        ).getMessage().trim()
+            .concat(getFileContext())
+            .concat(getInlineContext());
+    }
+
+    public String getFileContext() {
+        if (Objects.isNull(fileContext)) return "";
+        return "\nContext::FILE = ".concat(String.valueOf(fileContext));
+    }
+
+    public YAMLParserException setFileContext(Path path) {
+        fileContext = path;
+        return this;
+    }
+
+    public String getInlineContext() {
+        if (Objects.isNull(inlineContext)) return "";
+        return "\nContext::INLINE = ".concat(String.valueOf(inlineContext));
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/reader/xml/Reader.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/reader/xml/Reader.java
new file mode 100644
index 000000000..4ec164800
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/reader/xml/Reader.java
@@ -0,0 +1,56 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.reader.xml;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.InputStream;
+import java.nio.file.Path;
+
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBException;
+import javax.xml.bind.Unmarshaller;
+
+import org.eclipse.winery.model.tosca.Definitions;
+
+public class Reader {
+    private Unmarshaller unmarshaller;
+
+    public Reader() {
+        try {
+            JAXBContext jaxbContext = JAXBContext.newInstance(Definitions.class);
+            unmarshaller = jaxbContext.createUnmarshaller();
+        } catch (JAXBException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public Definitions parse(InputStream inputStream) throws JAXBException {
+        return (Definitions) unmarshaller.unmarshal(inputStream);
+    }
+
+    public Definitions parse(Path fileName) throws JAXBException {
+        File file = fileName.toFile();
+        try {
+            return parse(new FileInputStream(file));
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    public Definitions parse(Path path, Path name) throws Exception {
+        return parse(path.resolve(name));
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/reader/yaml/Builder.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/reader/yaml/Builder.java
new file mode 100644
index 000000000..9b9d34f8c
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/reader/yaml/Builder.java
@@ -0,0 +1,1257 @@
+/********************************************************************************
+ * Copyright (c) 2017-2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+
+package org.eclipse.winery.repository.backend.filebased.converter.support.reader.yaml;
+
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Date;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.Set;
+import java.util.TimeZone;
+import java.util.function.BiFunction;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import javax.xml.namespace.QName;
+
+import org.eclipse.winery.common.version.VersionUtils;
+import org.eclipse.winery.model.tosca.yaml.TArtifactDefinition;
+import org.eclipse.winery.model.tosca.yaml.TArtifactType;
+import org.eclipse.winery.model.tosca.yaml.TAttributeAssignment;
+import org.eclipse.winery.model.tosca.yaml.TAttributeDefinition;
+import org.eclipse.winery.model.tosca.yaml.TCapabilityAssignment;
+import org.eclipse.winery.model.tosca.yaml.TCapabilityDefinition;
+import org.eclipse.winery.model.tosca.yaml.TCapabilityType;
+import org.eclipse.winery.model.tosca.yaml.TConstraintClause;
+import org.eclipse.winery.model.tosca.yaml.TDataType;
+import org.eclipse.winery.model.tosca.yaml.TEntityType;
+import org.eclipse.winery.model.tosca.yaml.TEntrySchema;
+import org.eclipse.winery.model.tosca.yaml.TGroupDefinition;
+import org.eclipse.winery.model.tosca.yaml.TGroupType;
+import org.eclipse.winery.model.tosca.yaml.TImplementation;
+import org.eclipse.winery.model.tosca.yaml.TImportDefinition;
+import org.eclipse.winery.model.tosca.yaml.TInterfaceAssignment;
+import org.eclipse.winery.model.tosca.yaml.TInterfaceDefinition;
+import org.eclipse.winery.model.tosca.yaml.TInterfaceType;
+import org.eclipse.winery.model.tosca.yaml.TNodeFilterDefinition;
+import org.eclipse.winery.model.tosca.yaml.TNodeTemplate;
+import org.eclipse.winery.model.tosca.yaml.TNodeType;
+import org.eclipse.winery.model.tosca.yaml.TOperationDefinition;
+import org.eclipse.winery.model.tosca.yaml.TParameterDefinition;
+import org.eclipse.winery.model.tosca.yaml.TPolicyDefinition;
+import org.eclipse.winery.model.tosca.yaml.TPolicyType;
+import org.eclipse.winery.model.tosca.yaml.TPropertyAssignment;
+import org.eclipse.winery.model.tosca.yaml.TPropertyAssignmentOrDefinition;
+import org.eclipse.winery.model.tosca.yaml.TPropertyDefinition;
+import org.eclipse.winery.model.tosca.yaml.TPropertyFilterDefinition;
+import org.eclipse.winery.model.tosca.yaml.TRelationshipAssignment;
+import org.eclipse.winery.model.tosca.yaml.TRelationshipDefinition;
+import org.eclipse.winery.model.tosca.yaml.TRelationshipTemplate;
+import org.eclipse.winery.model.tosca.yaml.TRelationshipType;
+import org.eclipse.winery.model.tosca.yaml.TRepositoryDefinition;
+import org.eclipse.winery.model.tosca.yaml.TRequirementAssignment;
+import org.eclipse.winery.model.tosca.yaml.TRequirementDefinition;
+import org.eclipse.winery.model.tosca.yaml.TServiceTemplate;
+import org.eclipse.winery.model.tosca.yaml.TStatusValue;
+import org.eclipse.winery.model.tosca.yaml.TSubstitutionMappings;
+import org.eclipse.winery.model.tosca.yaml.TTopologyTemplateDefinition;
+import org.eclipse.winery.model.tosca.yaml.TVersion;
+import org.eclipse.winery.model.tosca.yaml.support.Metadata;
+import org.eclipse.winery.model.tosca.yaml.support.TListString;
+import org.eclipse.winery.model.tosca.yaml.support.TMapImportDefinition;
+import org.eclipse.winery.model.tosca.yaml.support.TMapObject;
+import org.eclipse.winery.model.tosca.yaml.support.TMapPropertyFilterDefinition;
+import org.eclipse.winery.model.tosca.yaml.support.TMapRequirementAssignment;
+import org.eclipse.winery.model.tosca.yaml.support.TMapRequirementDefinition;
+import org.eclipse.winery.model.tosca.yaml.tosca.datatypes.Credential;
+import org.eclipse.winery.repository.backend.filebased.converter.support.Namespaces;
+import org.eclipse.winery.repository.backend.filebased.converter.support.exception.InvalidToscaSyntax;
+import org.eclipse.winery.repository.backend.filebased.converter.support.exception.MultiException;
+import org.eclipse.winery.repository.backend.filebased.converter.support.validator.FieldValidator;
+
+import org.eclipse.collections.api.tuple.Pair;
+import org.eclipse.collections.impl.tuple.Tuples;
+import org.eclipse.jdt.annotation.NonNull;
+import org.eclipse.jdt.annotation.Nullable;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class Builder {
+    public static final Logger LOGGER = LoggerFactory.getLogger(Builder.class);
+
+    private final String namespace;
+    private MultiException exception;
+    private Map<String, String> prefix2Namespace;
+    private FieldValidator validator;
+
+    public Builder(String namespace) {
+        this.namespace = namespace;
+        this.validator = new FieldValidator();
+        this.exception = new MultiException();
+    }
+
+    private void initPrefix2Namespace(Object object) {
+        this.prefix2Namespace = new LinkedHashMap<>();
+        this.prefix2Namespace.put("tosca", Namespaces.TOSCA_NS);
+
+        if (Objects.isNull(object)) return;
+
+        @SuppressWarnings("unchecked")
+        List<Map<String, Object>> list = (List<Map<String, Object>>) object;
+        for (Map<String, Object> map : list) {
+            for (Map.Entry<String, Object> entry : map.entrySet()) {
+                if (!(entry.getValue() instanceof String)) {
+                    @SuppressWarnings("unchecked")
+                    Map<String, Object> importDefinition = (Map<String, Object>) entry.getValue();
+                    if (importDefinition != null) {
+                        String namespacePrefix = stringValue(importDefinition.get("namespace_prefix"));
+                        String namespaceUri = stringValue(importDefinition.get("namespace_uri"));
+                        if (namespacePrefix != null && namespaceUri != null) {
+                            this.prefix2Namespace.put(namespacePrefix, namespaceUri);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private <T, K> boolean validate(Class<T> clazz, Object object, Parameter<K> parameter) {
+        if (object instanceof Map) {
+            if (!clazz.equals(TInterfaceType.class)) {
+                @SuppressWarnings("unchecked")
+                Map<String, Object> fields = (Map<String, Object>) object;
+                this.exception.add(validator.validate(clazz, fields, parameter));
+            }
+            return true;
+        } else if (object instanceof String) {
+            switch (clazz.getSimpleName()) {
+                case "TAttributeAssignment":
+                case "TRequirementAssignment":
+                case "TOperationDefinition":
+                    return true;
+                default:
+                    return false;
+            }
+        } else {
+            return false;
+        }
+    }
+
+    @Nullable
+    public TServiceTemplate buildServiceTemplate(Object object) throws MultiException {
+        if (Objects.isNull(object) || !validate(TServiceTemplate.class, object, new Parameter<>().addContext("service_template")))
+            return null;
+        Parameter<Object> parameter = new Parameter<>();
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        // build map between prefix and namespaces
+        initPrefix2Namespace(map.get("imports"));
+
+        TServiceTemplate.Builder builder = new TServiceTemplate.Builder(stringValue(
+            map.getOrDefault("tosca_definitions_version", "")
+        )).setMetadata(buildMetadata(map.get("metadata")))
+            .setDescription(buildDescription(map.get("description")))
+            .setDslDefinitions(buildMap(map.get("dsl_definitions"),
+                parameter.copy().addContext("dsl_definition").setBuilderOO((obj, p) -> obj)
+            ))
+            .setRepositories(buildMap(map, "repositories", this::buildRepositoryDefinition, parameter))
+            .setImports(buildList(map, "imports", this::buildMapImportDefinition, parameter))
+            .setArtifactTypes(buildMap(map, "artifact_types", this::buildArtifactType, parameter))
+            .setDataTypes(buildMap(map, "data_types", this::buildDataType, parameter))
+            .setCapabilityTypes(buildMap(map, "capability_types", this::buildCapabilityType, parameter))
+            .setInterfaceTypes(buildMap(map, "interface_types", this::buildInterfaceType, parameter))
+            .setRelationshipTypes(buildMap(map, "relationship_types", this::buildRelationshipType, parameter))
+            .setNodeTypes(buildMap(map, "node_types", this::buildNodeType, parameter))
+            .setGroupTypes(buildMap(map, "group_types", this::buildGroupType, parameter))
+            .setPolicyTypes(buildMap(map, "policy_types", this::buildPolicyType, parameter))
+            .setTopologyTemplate(buildTopologyTemplate(map.get("topology_template"),
+                parameter.copy().addContext("topology_template")
+            ));
+        if (this.exception.hasException()) throw this.exception;
+        return builder.build();
+    }
+
+    @Nullable
+    public TTopologyTemplateDefinition buildTopologyTemplate(Object object, Parameter<Object> parameter) {
+        if (Objects.isNull(object) || !validate(TTopologyTemplateDefinition.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return new TTopologyTemplateDefinition.Builder()
+            .setDescription(buildDescription(map.get("description")))
+            .setInputs(buildMap(map, "inputs", this::buildParameterDefinition, parameter))
+            .setNodeTemplates(buildMap(map, "node_templates", this::buildNodeTemplate, parameter))
+            .setRelationshipTemplates(buildMap(map, "relationship_templates", this::buildRelationshipTemplate, parameter))
+            .setGroups(buildMap(map, "groups", this::buildGroupDefinition, parameter))
+            .setPolicies(buildMap(map, "policies", this::buildPolicyDefinition, parameter))
+            .setOutputs(buildMap(map, "outputs", this::buildParameterDefinition, parameter))
+            .setSubstitutionMappings(buildSubstitutionMappings(map.get("substitution_mappings"),
+                parameter.copy().addContext("substitution_mappings")
+            ))
+            .build();
+    }
+
+    @Nullable
+    public Metadata buildMetadata(Object object) {
+        if (Objects.isNull(object)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> tmp = (Map<String, Object>) object;
+        Metadata metadata = new Metadata();
+        tmp.entrySet().stream()
+            .filter(entry -> Objects.nonNull(entry.getValue()))
+            .forEach(entry -> {
+                metadata.put(entry.getKey(), stringValue(entry.getValue()));
+                if (entry.getValue() instanceof Date) {
+                    SimpleDateFormat date = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSSSSSZ");
+                    date.setTimeZone(TimeZone.getTimeZone("UTC"));
+                    metadata.put(entry.getKey(), date.format(entry.getValue()));
+                }
+            });
+        return metadata;
+    }
+
+    @Nullable
+    public String buildDescription(Object object) {
+        if (Objects.isNull(object)) return null;
+        return stringValue(object);
+    }
+
+    @Nullable
+    public TRepositoryDefinition buildRepositoryDefinition(Object object, Parameter<TRepositoryDefinition> parameter) {
+        if (Objects.isNull(object)) return new TRepositoryDefinition();
+        if (object instanceof String) return new TRepositoryDefinition.Builder(stringValue(object)).build();
+        if (!validate(TRepositoryDefinition.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return new TRepositoryDefinition.Builder(stringValue(map.get("url")))
+            .setDescription(buildDescription(map.get("description")))
+            .setCredential(buildCredential(map.get("credential"),
+                new Parameter<Credential>(parameter.getContext()).addContext("credential")
+            ))
+            .build();
+    }
+
+    @Nullable
+    public Credential buildCredential(Object object, Parameter<Credential> parameter) {
+
+        if (Objects.isNull(object)) return null;
+        if (!validate(Credential.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        @SuppressWarnings("unchecked")
+        Map<String, String> keys = (Map<String, String>) map.get("keys");
+        return new Credential.Builder(stringValue(map.get("token_type")))
+            .setProtocol(stringValue(map.get("protocol")))
+            .setToken(stringValue(map.get("token")))
+            .setUser(stringValue(map.get("user")))
+            .setKeys(keys)
+            .build();
+    }
+
+    @Nullable
+    public TMapImportDefinition buildMapImportDefinition(Object object, Parameter<TMapImportDefinition> parameter) {
+        TMapImportDefinition mapImportDefinition = new TMapImportDefinition();
+        mapImportDefinition.put(stringValue(parameter.getValue()), buildImportDefinition(object,
+            new Parameter<>(parameter.getContext())
+        ));
+        return mapImportDefinition;
+    }
+
+    @Nullable
+    public TImportDefinition buildImportDefinition(Object object, Parameter<TImportDefinition> parameter) {
+        if (Objects.isNull(object)) return new TImportDefinition();
+        if (object instanceof String) return new TImportDefinition.Builder(stringValue(object)).build();
+        if (!validate(TImportDefinition.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return new TImportDefinition.Builder(stringValue(map.get("file")))
+            .setRepository(buildQName(stringValue(map.get("repository"))))
+            .setNamespaceUri(stringValue(map.get("namespace_uri")))
+            .setNamespacePrefix(stringValue(map.get("namespace_prefix")))
+            .build();
+    }
+
+    @Nullable
+    private QName buildQName(String name) {
+        if (Objects.isNull(name)) {
+            return null;
+        }
+        // TODO decide on namespace rules w.r.t Simple Profile spec
+        // current solution: use dotted notation for namespaces as in RADON particles
+
+        // ignore version when splitting the full name
+        String n = VersionUtils.getNameWithoutVersion(name);
+        int separatorPos = n.lastIndexOf(".");
+        if (separatorPos != -1) {
+            String namespace = name.substring(0, separatorPos);
+            String localPart = name.substring(separatorPos + 1);
+            return new QName(namespace, localPart);
+        }
+
+        return new QName(null, name);
+    }
+
+    @Nullable
+    public TArtifactType buildArtifactType(Object object, Parameter<TArtifactType> parameter) {
+        if (Objects.isNull(object) || !validate(TArtifactType.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return buildEntityType(object,
+            new Parameter<TArtifactType.Builder>(parameter.getContext())
+                .setBuilder(new TArtifactType.Builder())
+                .setClazz(TArtifactType.class))
+            .setMimeType(stringValue(map.get("mime_type")))
+            .setFileExt(buildListString(map.get("file_ext"),
+                new Parameter<List<String>>(parameter.getContext()).addContext("file_ext")
+            ))
+            .build();
+    }
+
+    @NonNull
+    public <T extends TEntityType.Builder<T>> T buildEntityType(Object object, Parameter<T> parameter) {
+        if (Objects.isNull(object) || !validate(parameter.getClazz(), object, parameter)) return parameter.getBuilder();
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return parameter.getBuilder()
+            .setDescription(buildDescription(map.get("description")))
+            .setVersion(buildVersion(map.get("version")))
+            .setDerivedFrom(buildQName(stringValue(map.get("derived_from"))))
+            .setProperties(buildMap(map, "properties", this::buildPropertyDefinition, TPropertyDefinition.class, parameter))
+            .setAttributes(buildMap(map, "attributes", this::buildAttributeDefinition, parameter))
+            .setMetadata(buildMetadata(map.get("metadata")));
+    }
+
+    @Nullable
+    public TVersion buildVersion(Object object) {
+        return Objects.isNull(object) ? null : new TVersion(stringValue(object));
+    }
+
+    @Nullable
+    public <T> TPropertyDefinition buildPropertyDefinition(Object object, Parameter<T> parameter) {
+        if (Objects.isNull(object)) return new TPropertyDefinition();
+        if (!validate(parameter.getClazz(), object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return new TPropertyDefinition.Builder(buildQName(stringValue(map.get("type"))))
+            .setDescription(buildDescription(map.get("description")))
+            .setRequired(buildRequired(map.get("required")))
+            .setDefault(map.get("default"))
+            .setStatus(buildStatus(map.get("status")))
+            .setConstraints(buildList(map, "constraints", this::buildConstraintClause, parameter))
+            .setEntrySchema(buildEntrySchema(map.get("entry_schema"),
+                new Parameter<TEntrySchema>(parameter.getContext()).addContext("entry_schema")
+            ))
+            .build();
+    }
+
+    @Nullable
+    public Boolean buildRequired(Object object) {
+        if (Objects.isNull(object)) return null;
+        if (object instanceof String) return "true".equals(object) ? Boolean.TRUE : Boolean.FALSE;
+        return object instanceof Boolean ? (Boolean) object : Boolean.FALSE;
+    }
+
+    @Nullable
+    public TStatusValue buildStatus(Object object) {
+        String status = stringValue(object);
+        if (Objects.isNull(status)) return null;
+        switch (status) {
+            case "supported":
+                return TStatusValue.supported;
+            case "unsupported":
+                return TStatusValue.unsupported;
+            case "experimental":
+                return TStatusValue.experimental;
+            case "deprecated":
+                return TStatusValue.deprecated;
+            default:
+                assert ("supported".equals(status) ||
+                    "unsupported".equals(status) ||
+                    "experimental".equals(status) ||
+                    "deprecated".equals(status));
+                return null;
+        }
+    }
+
+    @Nullable
+    public TConstraintClause buildConstraintClause(Object object, Parameter<TConstraintClause> parameter) {
+        if (Objects.isNull(object)) return null;
+        TConstraintClause constraintClause = new TConstraintClause();
+        switch (parameter.getValue()) {
+            case "equal":
+                constraintClause.setEqual(object);
+                break;
+            case "greater_than":
+                constraintClause.setGreaterThan(object);
+                break;
+            case "greater_or_equal":
+                constraintClause.setGreaterOrEqual(object);
+                break;
+            case "less_than":
+                constraintClause.setLessThan(object);
+                break;
+            case "less_or_equal":
+                constraintClause.setLessOrEqual(object);
+                break;
+            case "in_range":
+                constraintClause.setInRange(buildListObject(object));
+                break;
+            case "valid_values":
+                constraintClause.setValidValues(buildListObject(object));
+                break;
+            case "length":
+                constraintClause.setLength(object);
+                break;
+            case "min_length":
+                constraintClause.setMinLength(object);
+                break;
+            case "max_length":
+                constraintClause.setMaxLength(object);
+                break;
+            case "pattern":
+                constraintClause.setPattern(object);
+                break;
+            default:
+        }
+        return constraintClause;
+    }
+
+    @Nullable
+    public List<Object> buildListObject(Object object) {
+        if (Objects.isNull(object)) return null;
+        @SuppressWarnings("unchecked")
+        List<Object> result = (List<Object>) object;
+        return result;
+    }
+
+    @Nullable
+    public TEntrySchema buildEntrySchema(Object object, Parameter<TEntrySchema> parameter) {
+        if (Objects.isNull(object)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return new TEntrySchema.Builder()
+            .setType(buildQName(stringValue(map.get("type"))))
+            .setDescription(buildDescription(map.get("description")))
+            .setConstraints(buildList(map, "constraints", this::buildConstraintClause, parameter))
+            .build();
+    }
+
+    @Nullable
+    public <T> TAttributeDefinition buildAttributeDefinition(Object object, Parameter<T> parameter) {
+        if (Objects.isNull(object)) return new TAttributeDefinition();
+        if (!validate(TAttributeDefinition.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return new TAttributeDefinition.Builder(buildQName(stringValue(map.get("type"))))
+            .setDescription(buildDescription(map.get("description")))
+            .setDefault(map.get("default"))
+            .setStatus(buildStatus(map.get("status")))
+            .setEntrySchema(buildEntrySchema(map.get("entry_schema"),
+                new Parameter<TEntrySchema>(parameter.getContext()).addContext("entry_schema")
+            ))
+            .build();
+    }
+
+    @Nullable
+    public List<String> buildListString(Object object, Parameter<List<String>> parameter) {
+        if (Objects.isNull(object)) return null;
+        if (!(object instanceof List)) {
+            exception.add(new InvalidToscaSyntax(
+                "The value '{}' is invalid. Only arrays of form '[a,b]' are allowed",
+                object
+            ).setContext(new ArrayList<>(parameter.getContext())));
+            return new ArrayList<>();
+        }
+        @SuppressWarnings("unchecked")
+        List<String> tmp = ((List<Object>) object).stream()
+            .map(this::stringValue)
+            .filter(Objects::nonNull)
+            .collect(Collectors.toList());
+        return tmp;
+    }
+
+    @Nullable
+    public TDataType buildDataType(Object object, Parameter<TDataType> parameter) {
+        if (Objects.isNull(object) || !validate(TDataType.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return buildEntityType(object,
+            new Parameter<TDataType.Builder>(parameter.getContext())
+                .setBuilder(new TDataType.Builder())
+                .setClazz(TDataType.class))
+            .setConstraints(buildList(map, "constraints", this::buildConstraintClause, parameter))
+            .build();
+    }
+
+    @Nullable
+    public TCapabilityType buildCapabilityType(Object object, Parameter<TCapabilityType> parameter) {
+        if (Objects.isNull(object) || !validate(TCapabilityType.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return buildEntityType(object,
+            new Parameter<TCapabilityType.Builder>(parameter.getContext())
+                .setBuilder(new TCapabilityType.Builder())
+                .setClazz(TCapabilityType.class))
+            .setValidSourceTypes(buildListQName(buildListString(map.get("valid_source_types"),
+                new Parameter<List<String>>(parameter.getContext()).addContext("valid_source_types")
+            )))
+            .build();
+    }
+
+    @Nullable
+    public List<QName> buildListQName(List<String> list) {
+        if (Objects.isNull(list) || list.isEmpty()) return null;
+        return list.stream().map(this::buildQName)
+            .filter(Objects::nonNull)
+            .collect(Collectors.toList());
+    }
+
+    @Nullable
+    public TInterfaceType buildInterfaceType(Object object, Parameter<TInterfaceType> parameter) {
+        if (Objects.isNull(object) || !validate(TInterfaceType.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return buildEntityType(object,
+            new Parameter<TInterfaceType.Builder>(parameter.getContext())
+                .setBuilder(new TInterfaceType.Builder())
+                .setClazz(TInterfaceType.class))
+            .setInputs(buildMap(map, "inputs", this::buildPropertyDefinition,
+                TPropertyDefinition.class, parameter))
+            .setOperations(buildMap(object,
+                new Parameter<TOperationDefinition>(parameter.getContext()).addContext("(operations)")
+                    .setValue("TInterfaceType")
+                    .setBuilderOO(this::buildOperationDefinition)
+                    .setFilter(this::filterInterfaceTypeOperation)
+            ))
+            .build();
+    }
+
+    private Boolean filterInterfaceTypeOperation(Map.Entry<String, Object> entry) {
+        if (Objects.isNull(entry.getKey())) return false;
+        Set<String> keys = Stream.of("inputs", "description", "version", "derived_from",
+            "properties", "attributes", "metadata").collect(Collectors.toSet());
+        return !keys.contains(entry.getKey());
+    }
+
+    @Nullable
+    public TOperationDefinition buildOperationDefinition(Object object, Parameter<TOperationDefinition> parameter) {
+        if (Objects.isNull(object) || !validate(TOperationDefinition.class, object, parameter)) return null;
+        // short notation
+        if (object instanceof String) {
+            return new TOperationDefinition.Builder()
+                .setImplementation(new TImplementation.Builder(buildQName(stringValue(object))).build())
+                .build();
+        } else if (object instanceof Map) {
+            @SuppressWarnings("unchecked")
+            Map<String, Object> map = (Map<String, Object>) object;
+            return new TOperationDefinition.Builder()
+                .setDescription(buildDescription(map.get("description")))
+                .setInputs(buildPropertyAssignmentOrDefinition(map.get("inputs"),
+                    new Parameter<>(parameter.getContext()).addContext("Inputs")
+                        .setValue(parameter.getValue())
+                ))
+                .setOutputs(buildPropertyAssignmentOrDefinition(map.get("outputs"),
+                    new Parameter<>(parameter.getContext()).addContext("outputs")
+                        .setValue(parameter.getValue())
+                ))
+                .setImplementation(buildImplementation(map.get("implementation"),
+                    new Parameter<TImplementation>(parameter.getContext()).addContext("implementation")
+                ))
+                .build();
+        }
+        return null;
+    }
+
+    @Nullable
+    public Map<String, TPropertyAssignmentOrDefinition> buildPropertyAssignmentOrDefinition(Object object, Parameter<Object> parameter) {
+        if (Objects.isNull(object)) return null;
+        String context = stringValue(parameter.getValue());
+        if ("TNodeType".equals(context) ||
+            "TRelationshipType".equals(context) ||
+            "TGroupType".equals(context) ||
+            "TInterfaceType".equals(context)) {
+            return buildMap(object, new Parameter<TPropertyAssignmentOrDefinition>(parameter.getContext())
+                .setClazz(TPropertyDefinition.class)
+                .setBuilderOO(this::buildPropertyDefinition));
+        } else {
+            return buildMap(object, new Parameter<TPropertyAssignmentOrDefinition>(parameter.getContext())
+                .setBuilderOO(this::buildPropertyAssignment));
+        }
+    }
+
+    @Nullable
+    public <T> TPropertyAssignment buildPropertyAssignment(Object object, Parameter<T> parameter) {
+        if (Objects.isNull(object)) return null;
+        return new TPropertyAssignment.Builder()
+            .setValue(object)
+            .build();
+    }
+
+    @Nullable
+    public TImplementation buildImplementation(Object object, Parameter<TImplementation> parameter) {
+        // TImplementation has required fields but is used not in a map context
+        if (Objects.isNull(object)) return null;
+        if (object instanceof String) return new TImplementation(buildQName(stringValue(object)));
+        if (!validate(TImplementation.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return new TImplementation.Builder(buildQName(stringValue(map.get("primary"))))
+            .setDependencies(buildListQName(buildListString(map.get("dependencies"),
+                new Parameter<List<String>>(parameter.getContext()).addContext("dependencies")
+            )))
+            .build();
+    }
+
+    @Nullable
+    public TRelationshipType buildRelationshipType(Object object, Parameter<TRelationshipType> parameter) {
+        if (Objects.isNull(object) || !validate(TRelationshipType.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return buildEntityType(object, new Parameter<TRelationshipType.Builder>(parameter.getContext())
+            .setBuilder(new TRelationshipType.Builder())
+            .setClazz(TRelationshipType.class))
+            .setValidTargetTypes(buildListQName(buildListString(map.get("valid_target_types"),
+                new Parameter<List<String>>(parameter.getContext()).addContext("valid_target_types")
+            )))
+            .setInterfaces(buildMap(map.get("interfaces"),
+                new Parameter<TInterfaceDefinition>(parameter.getContext()).addContext("interfaces")
+                    .setValue("TRelationshipType")
+                    .setBuilderOO(this::buildInterfaceDefinition)
+            ))
+            .build();
+    }
+
+    @Nullable
+    public TInterfaceDefinition buildInterfaceDefinition(Object object, Parameter<TInterfaceDefinition> parameter) {
+        if (Objects.isNull(object) || !validate(TInterfaceType.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        TInterfaceDefinition.Builder output = new TInterfaceDefinition.Builder()
+            .setType(buildQName(stringValue(map.get("type"))))
+            .setInputs(buildPropertyAssignmentOrDefinition(map.get("inputs"),
+                new Parameter<>(parameter.getContext()).addContext("inputs")
+                    .setValue(parameter.getValue())
+            ));
+        Map<String, TOperationDefinition> operations = buildMap(object,
+            new Parameter<TOperationDefinition>(parameter.getContext())
+                .setValue(parameter.getValue()).addContext("(operation)")
+                .setBuilderOO(this::buildOperationDefinition)
+                .setFilter(this::filterInterfaceAssignmentOperation)
+        );
+        output.setOperations(operations);
+        return output.build();
+    }
+
+    @Nullable
+    public TNodeType buildNodeType(Object object, Parameter<TNodeType> parameter) {
+        if (Objects.isNull(object) || !validate(TNodeType.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return buildEntityType(object, new Parameter<TNodeType.Builder>(parameter.getContext())
+            .setBuilder(new TNodeType.Builder())
+            .setClazz(TNodeType.class))
+            .setRequirements(buildList(map, "requirements", this::buildMapRequirementDefinition, parameter))
+            .setCapabilities(buildMap(map, "capabilities", this::buildCapabilityDefinition, parameter))
+            .setInterfaces(buildMap(map.get("interfaces"),
+                new Parameter<TInterfaceDefinition>(parameter.getContext()).addContext("interfaces")
+                    .setValue("TNodeType")
+                    .setBuilderOO(this::buildInterfaceDefinition)
+            ))
+            .setArtifacts(buildMap(map, "artifacts", this::buildArtifactDefinition, parameter))
+            .build();
+    }
+
+    @Nullable
+    public TMapRequirementDefinition buildMapRequirementDefinition(Object object, Parameter<TMapRequirementDefinition> parameter) {
+        TMapRequirementDefinition result = new TMapRequirementDefinition();
+        put(result, parameter.getValue(), buildRequirementDefinition(object, new Parameter<>(parameter.getContext())));
+        return result;
+    }
+
+    @Nullable
+    public TRequirementDefinition buildRequirementDefinition(Object object, Parameter<TRequirementDefinition> parameter) {
+        if (Objects.isNull(object)) return new TRequirementDefinition();
+        if (object instanceof String)
+            return new TRequirementDefinition.Builder(buildQName(stringValue(object))).build();
+        if (!validate(TRequirementDefinition.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return new TRequirementDefinition.Builder(buildQName(stringValue(map.get("capability"))))
+            .setNode(buildQName(stringValue(map.get("node"))))
+            .setRelationship(buildRelationshipDefinition(map.get("relationship"),
+                new Parameter<TRelationshipDefinition>(parameter.getContext()).addContext("relationship")
+            ))
+            .setOccurrences(buildListString(map.get("occurrences"),
+                new Parameter<List<String>>(parameter.getContext()).addContext("occurrences")
+            ))
+            .build();
+    }
+
+    @Nullable
+    public TRelationshipDefinition buildRelationshipDefinition(Object object, Parameter<TRelationshipDefinition> parameter) {
+        if (Objects.isNull(object)) return new TRelationshipDefinition();
+        if (object instanceof String)
+            return new TRelationshipDefinition.Builder(buildQName(stringValue(object))).build();
+        if (!validate(TRelationshipDefinition.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return new TRelationshipDefinition.Builder(buildQName(stringValue(map.get("type"))))
+            .setInterfaces(buildMap(map.get("interfaces"),
+                new Parameter<TInterfaceDefinition>(parameter.getContext()).addContext("interfaces")
+                    .setValue("TRelationshipDefinition")
+                    .setBuilderOO(this::buildInterfaceDefinition)
+            ))
+            .build();
+    }
+
+    @Nullable
+    public TCapabilityDefinition buildCapabilityDefinition(Object object, Parameter<TCapabilityDefinition> parameter) {
+        if (Objects.isNull(object)) return new TCapabilityDefinition();
+        if (object instanceof String)
+            return new TCapabilityDefinition.Builder(buildQName(stringValue(object))).build();
+        if (!validate(TCapabilityDefinition.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return new TCapabilityDefinition.Builder(buildQName(stringValue(map.get("type"))))
+            .setDescription(buildDescription(map.get("description")))
+            .setOccurrences(buildListString(map.get("occurrences"),
+                new Parameter<List<String>>(parameter.getContext()).addContext("occurrences")
+            ))
+            .setValidSourceTypes(buildListQName(buildListString(map.get("valid_source_types"),
+                new Parameter<List<String>>(parameter.getContext()).addContext("valid_source_types")
+            )))
+            .setProperties(buildMap(map.get("properties"),
+                new Parameter<TPropertyDefinition>(parameter.getContext()).addContext("properties")
+                    .setClazz(TPropertyDefinition.class)
+                    .setBuilderOO(this::buildPropertyDefinition)
+            ))
+            .setAttributes(buildMap(map, "attributes", this::buildAttributeDefinition, parameter))
+            .build();
+    }
+
+    @Nullable
+    public TArtifactDefinition buildArtifactDefinition(Object object, Parameter<TArtifactDefinition> parameter) {
+        if (Objects.isNull(object)) return new TArtifactDefinition();
+        if (object instanceof String) {
+            String file = stringValue(object);
+            if (Objects.isNull(file)) return null;
+            // TODO infer artifact type and mime type from file URI
+            String type = file.substring(file.lastIndexOf("."), file.length());
+            return new TArtifactDefinition.Builder(buildQName(type), new ArrayList<>(Collections.singleton(file))).build();
+        }
+        if (!validate(TArtifactDefinition.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+
+        List<String> files;
+        if (map.get("file") instanceof String) {
+            files = new ArrayList<>(Collections.singleton(stringValue(map.get("file"))));
+        } else if (map.get("files") instanceof List) {
+            // TODO capability check
+            files = buildListString(map.get("files"),
+                new Parameter<List<String>>(parameter.getContext()).addContext("files")
+            );
+        } else {
+            files = null;
+            assert false;
+        }
+        return new TArtifactDefinition.Builder(buildQName(stringValue(map.get("type"))), files)
+            .setRepository(stringValue(map.get("repository")))
+            .setDescription(buildDescription(map.get("description")))
+            .setDeployPath(stringValue(map.get("deploy_path")))
+            .setProperties(buildMap(map.get("properties"),
+                new Parameter<TPropertyAssignment>().addContext("properties")
+                    .setBuilderOO(this::buildPropertyAssignment)
+            ))
+            .build();
+    }
+
+    @Nullable
+    public TGroupType buildGroupType(Object object, Parameter<TGroupType> parameter) {
+        if (Objects.isNull(object) || !validate(TGroupType.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return buildEntityType(object, new Parameter<TGroupType.Builder>(parameter.getContext())
+            .setBuilder(new TGroupType.Builder())
+            .setClazz(TGroupType.class))
+            .setMembers(buildListQName(buildListString(map.get("members"),
+                new Parameter<List<String>>(parameter.getContext()).addContext("members")
+            )))
+            .setRequirements(buildList(map, "requirements", this::buildMapRequirementDefinition, parameter))
+            .setCapabilities(buildMap(map, "capabilities", this::buildCapabilityDefinition, parameter))
+            .setInterfaces(buildMap(map.get("interfaces"),
+                new Parameter<TInterfaceDefinition>(parameter.getContext())
+                    .setValue("TGroupType")
+                    .setBuilderOO(this::buildInterfaceDefinition)
+            ))
+            .build();
+    }
+
+    @Nullable
+    public TPolicyType buildPolicyType(Object object, Parameter<TPolicyType> parameter) {
+        if (Objects.isNull(object) || !validate(TPolicyType.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return buildEntityType(object, new Parameter<TPolicyType.Builder>(parameter.getContext())
+            .setBuilder(new TPolicyType.Builder())
+            .setClazz(TPolicyType.class))
+            .setTargets(buildListQName(buildListString(map.get("targets"),
+                new Parameter<List<String>>(parameter.getContext()).addContext("targets")
+            )))
+            .setTriggers(map.get("triggers"))
+            .build();
+    }
+
+    @Nullable
+    public TParameterDefinition buildParameterDefinition(Object object, Parameter<TParameterDefinition> parameter) {
+        if (Objects.isNull(object) || !validate(TParameterDefinition.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return new TParameterDefinition.Builder()
+            .setType(buildQName(stringValue(map.get("type"))))
+            .setDescription(buildDescription(map.get("description")))
+            .setRequired(buildRequired(map.get("required")))
+            .setDefault(map.get("default"))
+            .setStatus(buildStatus(map.get("status")))
+            .setConstraints(buildList(map, "constraints", this::buildConstraintClause, parameter))
+            .setEntrySchema(buildEntrySchema(map.get("entry_schema"),
+                new Parameter<TEntrySchema>(parameter.getContext()).addContext("entry_schema")
+            ))
+            .setValue(map.get("value"))
+            .build();
+    }
+
+    @Nullable
+    public TNodeTemplate buildNodeTemplate(Object object, Parameter<TNodeTemplate> parameter) {
+        if (Objects.isNull(object)) return new TNodeTemplate();
+        if (!validate(TNodeTemplate.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return new TNodeTemplate.Builder(buildQName(stringValue(map.get("type"))))
+            .setDescription(buildDescription(map.get("description")))
+            .setMetadata(buildMetadata(map.get("metadata")))
+            .setDirectives(buildListString(map.get("directives"),
+                new Parameter<List<String>>(parameter.getContext()).addContext("directives")
+            ))
+            .setProperties(buildMap(map, "properties", this::buildPropertyAssignment, parameter))
+            .setAttributes(buildMap(map, "attributes", this::buildAttributeAssignment, parameter))
+            .setRequirements(buildList(map, "requirements", this::buildMapRequirementAssignment, parameter))
+            .setCapabilities(buildMap(map, "capabilities", this::buildCapabilityAssignment, parameter))
+            .setInterfaces(buildMap(map.get("interfaces"),
+                new Parameter<TInterfaceDefinition>(parameter.getContext()).addContext("interfaces")
+                    .setValue("TNodeTemplate")
+                    .setBuilderOO(this::buildInterfaceDefinition)
+            ))
+            .setArtifacts(buildMap(map, "artifacts", this::buildArtifactDefinition, parameter))
+            .setNodeFilter(buildNodeFilterDefinition(map.get("node_filter"),
+                new Parameter<TNodeFilterDefinition>(parameter.getContext()).addContext("node_filter")
+            ))
+            .setCopy(buildQName(stringValue(map.get("copy"))))
+            .build();
+    }
+
+    @Nullable
+    public TAttributeAssignment buildAttributeAssignment(Object object, Parameter<TAttributeAssignment> parameter) {
+        if (Objects.isNull(object)) return null;
+        if (!(object instanceof Map)) {
+            // Attribute assignment with simple value
+            return new TAttributeAssignment.Builder().setValue(object).build();
+        } else if (!((Map) object).containsKey("value")) {
+            // Attribute assignment with <attribute_value_expression>
+            return new TAttributeAssignment.Builder().setValue(object).build();
+        } else if (((Map) object).containsKey("value") && validate(TAttributeAssignment.class, object, parameter)) {
+            // Attribute assignment with extended notation
+            @SuppressWarnings("unchecked")
+            Map<String, Object> map = (Map<String, Object>) object;
+            return new TAttributeAssignment.Builder()
+                .setDescription(buildDescription(map.get("description")))
+                .setValue(map.get("value"))
+                .build();
+        } else {
+            return null;
+        }
+    }
+
+    @Nullable
+    public TMapRequirementAssignment buildMapRequirementAssignment(Object object, Parameter<TMapRequirementAssignment> parameter) {
+        if (Objects.isNull(object)) return null;
+        TMapRequirementAssignment result = new TMapRequirementAssignment();
+        put(result, stringValue(parameter.getValue()), buildRequirementAssignment(object,
+            new Parameter<>(parameter.getContext())
+        ));
+        return result;
+    }
+
+    @Nullable
+    public TRequirementAssignment buildRequirementAssignment(Object object, Parameter<TRequirementAssignment> parameter) {
+        if (Objects.isNull(object)) return null;
+        if (object instanceof String) return new TRequirementAssignment(buildQName(stringValue(object)));
+        if (!validate(TRequirementAssignment.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return new TRequirementAssignment.Builder()
+            .setCapability(buildQName(stringValue(map.get("capability"))))
+            .setNode(buildQName(stringValue(map.get("node"))))
+            .setRelationship(buildRelationshipAssignment(map.get("relationship"),
+                new Parameter<TRelationshipAssignment>(parameter.getContext()).addContext("relationship")
+            ))
+            .setNodeFilter(buildNodeFilterDefinition(map.get("node_filter"),
+                new Parameter<TNodeFilterDefinition>(parameter.getContext()).addContext("node_filter")
+            ))
+            .setOccurrences(buildListString(map.get("occurrences"),
+                new Parameter<List<String>>(parameter.getContext()).addContext("occurrences")
+            ))
+            .build();
+    }
+
+    @Nullable
+    public TRelationshipAssignment buildRelationshipAssignment(Object object, Parameter<TRelationshipAssignment> parameter) {
+        if (Objects.isNull(object)) return null;
+        if (object instanceof String)
+            return new TRelationshipAssignment.Builder(buildQName(stringValue(object))).build();
+        if (!validate(TRelationshipAssignment.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return new TRelationshipAssignment.Builder(buildQName(stringValue(map.get("type"))))
+            .setProperties(buildMap(map, "properties", this::buildPropertyAssignment, parameter))
+            .setInterfaces(buildMap(map, "interfaces", this::buildInterfaceAssignment, parameter))
+            .build();
+    }
+
+    @Nullable
+    public TInterfaceAssignment buildInterfaceAssignment(Object object, Parameter<TInterfaceAssignment> parameter) {
+        if (Objects.isNull(object) || !validate(TInterfaceAssignment.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return new TInterfaceAssignment.Builder()
+            .setType(buildQName(stringValue(map.get("type"))))
+            .setInputs(buildPropertyAssignmentOrDefinition(map.get("inputs"),
+                new Parameter<>(parameter.getContext())
+                    .setValue("TInterfaceAssignment")
+            ))
+            .setOperations(buildMap(object,
+                new Parameter<TOperationDefinition>(parameter.getContext()).addContext("(operations)")
+                    .setBuilderOO(this::buildOperationDefinition)
+                    .setFilter(this::filterInterfaceAssignmentOperation)
+                    .setValue("TInterfaceAssignment")
+            ))
+            .build();
+    }
+
+    private Boolean filterInterfaceAssignmentOperation(Map.Entry<String, Object> entry) {
+        if (Objects.isNull(entry.getKey())) return false;
+        Set<String> keys = Stream.of("type", "inputs").collect(Collectors.toSet());
+        return !keys.contains(entry.getKey());
+    }
+
+    @Nullable
+    public TNodeFilterDefinition buildNodeFilterDefinition(Object object, Parameter<TNodeFilterDefinition> parameter) {
+        if (Objects.isNull(object) || !validate(TNodeFilterDefinition.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return new TNodeFilterDefinition.Builder()
+            .setProperties(buildList(map, "properties", this::buildMapPropertyDefinition, parameter))
+            .setCapabilities(buildList(map, "capabilities", this::buildMapObjectValue, parameter))
+            .build();
+    }
+
+    @Nullable
+    public TMapPropertyFilterDefinition buildMapPropertyDefinition(Object object, Parameter<TMapPropertyFilterDefinition> parameter) {
+        if (Objects.isNull(object)) return null;
+        TMapPropertyFilterDefinition result = new TMapPropertyFilterDefinition();
+        put(result, stringValue(parameter.getValue()), buildPropertyFilterDefinition(object,
+            new Parameter<>(parameter.getContext())));
+        return result;
+    }
+
+    @Nullable
+    public TPropertyFilterDefinition buildPropertyFilterDefinition(Object object, Parameter<TPropertyFilterDefinition> parameter) {
+        if (Objects.isNull(object) || !validate(TPropertyFilterDefinition.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return new TPropertyFilterDefinition.Builder()
+            .setConstraints(buildList(map, "constraints", this::buildConstraintClause, parameter))
+            .build();
+    }
+
+    @Nullable
+    public TMapObject buildMapObjectValue(Object object, Parameter<TMapObject> parameter) {
+        if (Objects.isNull(object)) return null;
+        TMapObject result = new TMapObject();
+        put(result, stringValue(parameter.getValue()), object);
+        return result;
+    }
+
+    @Nullable
+    public TCapabilityAssignment buildCapabilityAssignment(Object object, Parameter<TCapabilityAssignment> parameter) {
+        if (Objects.isNull(object) || !validate(TCapabilityAssignment.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return new TCapabilityAssignment.Builder()
+            .setProperties(buildMap(map, "properties", this::buildPropertyAssignment, parameter))
+            .setAttributes(buildMap(map, "attributes", this::buildAttributeAssignment, parameter))
+            .build();
+    }
+
+    @Nullable
+    public TRelationshipTemplate buildRelationshipTemplate(Object object, Parameter<TRelationshipTemplate> parameter) {
+        if (Objects.isNull(object)) return new TRelationshipTemplate();
+        if (!validate(TRelationshipTemplate.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return new TRelationshipTemplate.Builder(buildQName(stringValue(map.get("type"))))
+            .setDescription(buildDescription(map.get("description")))
+            .setMetadata(buildMetadata(map.get("metadata")))
+            .setProperties(buildMap(map, "properties", this::buildPropertyAssignment, parameter))
+            .setAttributes(buildMap(map, "attributes", this::buildAttributeAssignment, parameter))
+            .setInterfaces(buildMap(map.get("interfaces"),
+                new Parameter<TInterfaceDefinition>(parameter.getContext()).addContext("interfaces")
+                    .setValue("TRelationshipTemplate")
+                    .setBuilderOO(this::buildInterfaceDefinition)
+            ))
+            .setCopy(buildQName(stringValue(map.get("copy"))))
+            .build();
+    }
+
+    @Nullable
+    public TGroupDefinition buildGroupDefinition(Object object, Parameter<TGroupDefinition> parameter) {
+        if (Objects.isNull(object)) return new TGroupDefinition();
+        if (!validate(TGroupDefinition.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return new TGroupDefinition.Builder(buildQName(stringValue(map.get("type"))))
+            .setDescription(buildDescription(map.get("description")))
+            .setMetadata(buildMetadata(map.get("metadata")))
+            .setProperties(buildMap(map, "properties", this::buildPropertyAssignment, parameter))
+            .setMembers(buildListQName(buildListString(map.get("members"),
+                new Parameter<List<String>>(parameter.getContext()).addContext("members")
+            )))
+            .setInterfaces(buildMap(map, "interfaces", this::buildInterfaceDefinition, parameter.setValue("TGroupDefinition")
+            ))
+            .build();
+    }
+
+    @Nullable
+    public TPolicyDefinition buildPolicyDefinition(Object object, Parameter<TPolicyDefinition> parameter) {
+        if (Objects.isNull(object)) return new TPolicyDefinition();
+        if (!validate(TPolicyDefinition.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return new TPolicyDefinition.Builder(buildQName(stringValue(map.get("type"))))
+            .setDescription(buildDescription(map.get("description")))
+            .setMetadata(buildMetadata(map.get("metadata")))
+            .setProperties(buildMap(map, "properties", this::buildPropertyAssignment, parameter))
+            .setTargets(buildListQName(buildListString(map.get("targets"),
+                new Parameter<List<String>>(parameter.getContext()).addContext("targets")
+            )))
+            .build();
+    }
+
+    @Nullable
+    public TSubstitutionMappings buildSubstitutionMappings(Object object, Parameter<Object> parameter) {
+        if (Objects.isNull(object) || !validate(TSubstitutionMappings.class, object, parameter)) return null;
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return new TSubstitutionMappings.Builder()
+            .setNodeType(buildQName(stringValue(map.get("node_type"))))
+            .setCapabilities(buildMap(map, "capabilities", this::buildStringList, parameter))
+            .setRequirements(buildMap(map, "requirements", this::buildStringList, parameter))
+            .build();
+    }
+
+    @Nullable
+    public TListString buildStringList(Object object, Parameter<TListString> parameter) {
+        if (Objects.isNull(object)) return null;
+        @SuppressWarnings("unchecked")
+        List<String> tmp = (List<String>) object;
+        TListString stringList = new TListString();
+        stringList.addAll(tmp);
+        return stringList;
+    }
+
+    @Nullable
+    private String stringValue(@Nullable Object object) {
+        if (Objects.isNull(object)) return null;
+        return String.valueOf(object);
+    }
+
+    private <T> void put(Map<String, T> map, String key, T value) {
+        if (Objects.nonNull(map) && Objects.nonNull(key) && Objects.nonNull(value)) map.put(key, value);
+    }
+
+    private <T> boolean nonNull(Map.Entry<String, T> entry) {
+        return Objects.nonNull(entry) && Objects.nonNull(entry.getKey()) && Objects.nonNull(entry.getValue());
+    }
+
+    private <T> boolean nonNull(Pair<String, T> pair) {
+        return Objects.nonNull(pair) && Objects.nonNull(pair.getOne()) && Objects.nonNull(pair.getTwo());
+    }
+
+    private <T, K> Map<String, T> buildMap(Map<String, Object> map, String key,
+                                           BiFunction<Object, Parameter<T>, T> function, Parameter<K> parameter) {
+        return buildMap(map.get(key),
+            new Parameter<T>(parameter.getContext()).addContext(key)
+                .setBuilderOO(function)
+        );
+    }
+
+    private <T, K> Map<String, T> buildMap(Map<String, Object> map, String key,
+                                           BiFunction<Object, Parameter<T>, T> function,
+                                           Class<?> clazz, Parameter<K> parameter) {
+        return buildMap(map.get(key),
+            new Parameter<T>(parameter.getContext()).addContext(key)
+                .setClazz(clazz)
+                .setBuilderOO(function)
+        );
+    }
+
+    private <T> Map<String, T> buildMap(Object object, Parameter<T> parameter) {
+        if (Objects.isNull(object)) return null;
+        //if (Objects.isNull(parameter.getFilter())) parameter.setFilter(this::nonNull);
+        Map<String, T> output = buildStream(object, parameter)
+            .map(entry -> {
+                if (entry.getValue() == null) {
+                    entry.setValue("null");
+                }
+                return Tuples.pair(entry.getKey(), parameter.getBuilderOO().apply(
+                    entry.getValue(),
+                    new Parameter<T>(parameter.getContext()).addContext(entry.getKey())
+                        .setClazz(parameter.getClazz())
+                        .setValue(parameter.getValue())
+                    )
+                );
+            })
+//            .filter(this::nonNull)
+            .collect(Collectors.toMap(Pair::getOne, Pair::getTwo));
+        return output;
+    }
+
+    private <T> Stream<Map.Entry<String, Object>> buildStream(Object object, Parameter<T> parameter) {
+        @SuppressWarnings("unchecked")
+        Map<String, Object> map = (Map<String, Object>) object;
+        return map.entrySet().stream()
+            .filter(Optional.ofNullable(parameter.getFilter()).orElse(entry -> true));
+    }
+
+    private <T> List<T> buildList(Map<String, Object> map, String key, BiFunction<Object, Parameter<T>, T> function, Parameter<?> parameter) {
+        return buildList(map.get(key),
+            new Parameter<T>(parameter.getContext()).addContext(key)
+                .setBuilderOO(function)
+        );
+    }
+
+    private <T> List<T> buildList(Object object, Parameter<T> parameter) {
+        if (Objects.isNull(object)) return null;
+        @SuppressWarnings("unchecked")
+        List<Map<String, Object>> list = (List<Map<String, Object>>) object;
+        return list.stream()
+            .filter(Objects::nonNull)
+            .flatMap(map -> map.entrySet().stream())
+            .filter(Objects::nonNull)
+            .map(entry -> parameter.getBuilderOO().apply(entry.getValue(),
+                new Parameter<T>(parameter.getContext())
+                    .setValue(entry.getKey())
+            ))
+            .filter(Objects::nonNull)
+            .collect(Collectors.toList());
+    }
+
+    public static class Parameter<T> {
+        private Set<String> context;
+        private String value;
+        private Class<?> clazz;
+        private T builder;
+
+        private Predicate<Map.Entry<String, Object>> filter;
+        private BiFunction<Object, Parameter<T>, T> builderOO;
+
+        public Parameter() {
+            context = new LinkedHashSet<>();
+        }
+
+        public Parameter(Set<String> context) {
+            this.context = new LinkedHashSet<>(context);
+        }
+
+        public Set<String> getContext() {
+            return context;
+        }
+
+        public Class<?> getClazz() {
+            return clazz;
+        }
+
+        public Parameter<T> setClazz(Class<?> clazz) {
+            this.clazz = clazz;
+            return this;
+        }
+
+        public T getBuilder() {
+            return builder;
+        }
+
+        public Parameter<T> setBuilder(T builder) {
+            this.builder = builder;
+            return this;
+        }
+
+        public Predicate<Map.Entry<String, Object>> getFilter() {
+            return filter;
+        }
+
+        public Parameter<T> setFilter(Predicate<Map.Entry<String, Object>> filter) {
+            this.filter = filter;
+            return this;
+        }
+
+        public BiFunction<Object, Parameter<T>, T> getBuilderOO() {
+            return builderOO;
+        }
+
+        public Parameter<T> setBuilderOO(BiFunction<Object, Parameter<T>, T> builderOO) {
+            this.builderOO = builderOO;
+            return this;
+        }
+
+        public String getValue() {
+            return value;
+        }
+
+        public Parameter<T> setValue(String value) {
+            this.value = value;
+            return this;
+        }
+
+        public Parameter<T> copy() {
+            return new Parameter<>(this.context);
+        }
+
+        public Parameter<T> addContext(String value) {
+            context.add(value);
+            return this;
+        }
+
+        @Override
+        public String toString() {
+            return context.stream().collect(Collectors.joining(":"));
+        }
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/reader/yaml/Reader.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/reader/yaml/Reader.java
new file mode 100644
index 000000000..562eed342
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/reader/yaml/Reader.java
@@ -0,0 +1,300 @@
+/********************************************************************************
+ * Copyright (c) 2017-2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.reader.yaml;
+
+import java.io.BufferedReader;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+import org.eclipse.winery.model.tosca.yaml.TImportDefinition;
+import org.eclipse.winery.model.tosca.yaml.TServiceTemplate;
+import org.eclipse.winery.model.tosca.yaml.support.Metadata;
+import org.eclipse.winery.repository.backend.filebased.converter.support.Namespaces;
+import org.eclipse.winery.repository.backend.filebased.converter.support.Utils;
+import org.eclipse.winery.repository.backend.filebased.converter.support.exception.InvalidToscaSyntax;
+import org.eclipse.winery.repository.backend.filebased.converter.support.exception.MultiException;
+import org.eclipse.winery.repository.backend.filebased.converter.support.exception.UndefinedFile;
+import org.eclipse.winery.repository.backend.filebased.converter.support.exception.YAMLParserException;
+import org.eclipse.winery.repository.backend.filebased.converter.support.validator.ObjectValidator;
+import org.eclipse.winery.repository.backend.filebased.converter.support.validator.Validator;
+import org.eclipse.winery.repository.backend.filebased.converter.support.validator.support.ExceptionInterpreter;
+
+import org.eclipse.jdt.annotation.NonNull;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.yaml.snakeyaml.Yaml;
+import org.yaml.snakeyaml.constructor.ConstructorException;
+import org.yaml.snakeyaml.constructor.SafeConstructor;
+import org.yaml.snakeyaml.scanner.ScannerException;
+
+public class Reader {
+    public static final Logger logger = LoggerFactory.getLogger(Builder.class);
+    private Yaml yaml;
+
+    private Map<Path, byte[]> hashBuffer = new HashMap<>();
+    private Map<Path, TServiceTemplate> serviceTemplateBuffer = new HashMap<>();
+    private Map<Path, MultiException> exceptionBuffer = new HashMap<>();
+
+    /**
+     * Creates a new instance of the YAML reader. The reader is not thread-safe!!!! because the underlying Yaml object
+     * is not thread safe!. If you implement a singleton pattern, you get some weird exceptions, e.g., when opening the
+     * topology modeler.
+     */
+    public Reader() {
+        this.yaml = new Yaml(new SafeConstructor());
+    }
+
+    public TServiceTemplate parse(InputStream inputStream) throws MultiException {
+        return this.readServiceTemplate(inputStream, Namespaces.DEFAULT_NS);
+    }
+
+    public TServiceTemplate parse(InputStream inputStream, String namespace) throws MultiException {
+        return this.readServiceTemplate(inputStream, namespace);
+    }
+
+    public TServiceTemplate parse(TImportDefinition definition, Path path, String namespace) throws MultiException {
+        return this.readImportDefinition(definition, path, namespace);
+    }
+
+    public TServiceTemplate parseSkipTest(Path uri, String namespace) throws MultiException {
+        return this.readServiceTemplateSkipTest(uri, namespace);
+    }
+
+    @NonNull
+    public Metadata getMetadata(Path path, Path file) throws MultiException {
+        return readServiceTemplateMetadataSkipTest(path.resolve(file), Namespaces.DEFAULT_NS);
+    }
+
+    @NonNull
+    public String getNamespace(Path path, Path file) throws MultiException {
+        return getMetadata(path, file).getOrDefault("targetNamespace", Namespaces.DEFAULT_NS);
+    }
+
+    private TServiceTemplate readServiceTemplateSkipTest(Path filePath, String namespace) throws MultiException {
+        Object object = readObject(filePath);
+        return buildServiceTemplate(object, namespace);
+    }
+
+    @NonNull
+    private Metadata readServiceTemplateMetadataSkipTest(Path filePath, String namespace) throws MultiException {
+        Object object = readMetadataObject(filePath);
+        return Optional.ofNullable(buildServiceTemplate(object, namespace)).map(TServiceTemplate::getMetadata).orElse(new Metadata());
+    }
+
+    private TServiceTemplate buildServiceTemplate(Object object, String namespace) throws MultiException {
+        Builder builder = new Builder(namespace);
+        return builder.buildServiceTemplate(object);
+    }
+
+    /**
+     * Uses snakeyaml to convert a file into an Object
+     *
+     * @param path name
+     * @return Object (Lists, Maps, Strings, Integers, Dates)
+     * @throws UndefinedFile if the file could not be found.
+     */
+
+    private Object readObject(Path path) throws MultiException {
+        try (InputStream inputStream = new FileInputStream(path.toFile())) {
+            return readObjectFromInputStream(inputStream);
+        } catch (FileNotFoundException e) {
+            throw new MultiException().add(new UndefinedFile(
+                "The file '{}' is missing",
+                path
+            ).setFileContext(path));
+        } catch (IOException e) {
+            logger.error("Could not read from inputstream", e);
+            return null;
+        }
+    }
+
+    private Object readObjectFromInputStream(InputStream inputStream) {
+        return this.yaml.load(inputStream);
+    }
+
+    /**
+     * Uses snakeyaml to convert the part of an file containing metadata into an Object
+     *
+     * @return Object (Lists, Maps, Strings, Integers, Dates)
+     * @throws UndefinedFile if the file could not be found.
+     */
+
+    private Object readMetadataObject(Path path) throws MultiException {
+        try (InputStream inputStream = new FileInputStream(path.toFile())) {
+            BufferedReader buffer = new BufferedReader(new InputStreamReader(inputStream));
+            String metadata = buffer.lines().collect(Collectors.joining("\n"));
+            Matcher matcher = Pattern.compile("\\nmetadata:").matcher(metadata);
+            // No metadata return null
+            if (!matcher.find()) return null;
+
+            // Prevent index out of bound
+            int index = matcher.start() + 1;
+            if (index >= metadata.length()) return null;
+
+            // Get file string starting with "metadata:"
+            metadata = metadata.substring(matcher.start() + 1);
+            matcher = Pattern.compile(("\\n[^ ]")).matcher(metadata);
+            if (matcher.find()) {
+                // Cut of the part of the file after metadata (indicated by newline and a key) 
+                metadata = metadata.substring(0, matcher.start());
+            }
+
+            return this.yaml.load(metadata);
+        } catch (FileNotFoundException e) {
+            throw new MultiException().add(new UndefinedFile(
+                "The file '{}' is missing",
+                path
+            ).setFileContext(path));
+        } catch (IOException e) {
+            logger.error("Could not read from inputstream", e);
+            return null;
+        }
+    }
+
+    /**
+     * Checks if a file has been read before and is changed
+     *
+     * @return false if has been read and did not change else true
+     */
+
+    private boolean fileChanged(Path path) {
+        try {
+            byte[] hash = Utils.getHashValueOfFile(path.toFile());
+            // No file changes
+            if (hashBuffer.containsKey(path) && Arrays.equals(hashBuffer.get(path), hash)) {
+                return false;
+            } else {
+                // File changed or is new
+                hashBuffer.put(path, hash);
+                return true;
+            }
+        } catch (IOException e) {
+            logger.debug("File is not readable", e);
+            return true;
+        }
+    }
+
+    /**
+     * Reads a file and converts it to a ServiceTemplate
+     *
+     * @return ServiceTemplate
+     * @throws MultiException the ServiceTemplate or the file is invalid.
+     */
+
+    private TServiceTemplate readServiceTemplate(InputStream inputStream, String namespace) throws MultiException {
+        Object object = null;
+        logger.debug("Read Service Template: {}", inputStream);
+        try {
+            // pre parse checking
+            try {
+                object = readObjectFromInputStream(inputStream);
+                ObjectValidator objectValidator = new ObjectValidator();
+                objectValidator.validateObject(object);
+            } catch (ConstructorException e) {
+                ExceptionInterpreter interpreter = new ExceptionInterpreter();
+                throw new MultiException().add(interpreter.interpret(e));
+            } catch (ScannerException e) {
+                ExceptionInterpreter interpreter = new ExceptionInterpreter();
+                throw new MultiException().add(interpreter.interpret(e));
+            } catch (InvalidToscaSyntax invalidToscaSyntax) {
+                invalidToscaSyntax.printStackTrace();
+            }
+
+            // parse checking
+            TServiceTemplate serviceTemplate = buildServiceTemplate(object, namespace);
+            return serviceTemplate;
+
+//            // post parse checking
+//            Validator validator = new Validator(path);
+//            validator.validate(result, namespace);
+//
+//            serviceTemplateBuffer.put(filePath, result);
+        } catch (MultiException e) {
+//            exceptionBuffer.put(filePath, e);
+            throw e;
+        }
+    }
+
+    private TServiceTemplate readServiceTemplate(Path path, Path file, String namespace) throws MultiException {
+        Path filePath;
+        if (Objects.isNull(path)) {
+            filePath = file;
+        } else {
+            filePath = path.resolve(file);
+        }
+
+        if (!fileChanged(filePath)) {
+            if (exceptionBuffer.containsKey(filePath)) {
+                throw exceptionBuffer.get(filePath);
+            }
+            if (serviceTemplateBuffer.containsKey(filePath)) {
+                return serviceTemplateBuffer.get(filePath);
+            }
+        }
+        logger.debug("Read Service Template: {}", filePath);
+        try {
+            // pre parse checking
+            try {
+                ObjectValidator objectValidator = new ObjectValidator();
+                objectValidator.validateObject(readObject(filePath));
+            } catch (ConstructorException e) {
+                ExceptionInterpreter interpreter = new ExceptionInterpreter();
+                throw new MultiException().add(interpreter.interpret(e));
+            } catch (ScannerException e) {
+                ExceptionInterpreter interpreter = new ExceptionInterpreter();
+                throw new MultiException().add(interpreter.interpret(e));
+            } catch (YAMLParserException e) {
+                throw new MultiException().add(e);
+            }
+
+            // parse checking
+            TServiceTemplate result = buildServiceTemplate(readObject(filePath), namespace);
+
+            // post parse checking
+            Validator validator = new Validator(path);
+            validator.validate(result, namespace);
+
+            serviceTemplateBuffer.put(filePath, result);
+            return result;
+        } catch (MultiException e) {
+            exceptionBuffer.put(filePath, e);
+            throw e.add(file.toString());
+        }
+    }
+
+    public TServiceTemplate readImportDefinition(TImportDefinition definition, Path path, String namespace) throws MultiException {
+        if (Objects.isNull(definition) || Objects.isNull(definition.getFile())) return null;
+        String importNamespace = definition.getNamespaceUri() == null ? namespace : definition.getNamespaceUri();
+        if (Objects.nonNull(definition.getRepository())) {
+            // TODO Support Repositories
+            return null;
+        } else {
+            return readServiceTemplate(path, Paths.get(definition.getFile()), importNamespace);
+        }
+    }
+}
+
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/DefinitionValidator.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/DefinitionValidator.java
new file mode 100644
index 000000000..cb3d77291
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/DefinitionValidator.java
@@ -0,0 +1,81 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.validator;
+
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+
+import javax.xml.namespace.QName;
+
+import org.eclipse.winery.model.tosca.yaml.TArtifactDefinition;
+import org.eclipse.winery.model.tosca.yaml.TImportDefinition;
+import org.eclipse.winery.model.tosca.yaml.TServiceTemplate;
+import org.eclipse.winery.repository.backend.filebased.converter.support.Namespaces;
+import org.eclipse.winery.repository.backend.filebased.converter.support.exception.MultiException;
+import org.eclipse.winery.repository.backend.filebased.converter.support.exception.UndefinedField;
+import org.eclipse.winery.repository.backend.filebased.converter.support.exception.UndefinedFile;
+import org.eclipse.winery.repository.backend.filebased.converter.support.validator.support.ExceptionVisitor;
+import org.eclipse.winery.repository.backend.filebased.converter.support.validator.support.Parameter;
+import org.eclipse.winery.repository.backend.filebased.converter.support.validator.support.Result;
+
+public class DefinitionValidator extends ExceptionVisitor<Result, Parameter> {
+    public final Path path;
+    private DefinitionsVisitor definitionsVisitor;
+
+    public DefinitionValidator(Path path) {
+        definitionsVisitor = new DefinitionsVisitor(Namespaces.DEFAULT_NS, path);
+        this.path = path;
+    }
+
+    public void validate(TServiceTemplate serviceTemplate) throws MultiException {
+        serviceTemplate.accept(definitionsVisitor, new Parameter());
+        serviceTemplate.accept(this, new Parameter());
+        if (hasExceptions()) {
+            throw getException();
+        }
+    }
+
+    @Override
+    public Result visit(TImportDefinition node, Parameter parameter) {
+        if (!isDefined(node.getRepository(), definitionsVisitor.getRepositoryDefinitions())) {
+            setException(new UndefinedField(
+                    "Repository definition '{}' is undefined",
+                    node.getRepository()
+                ).setContext(parameter.getContext())
+            );
+        }
+        return super.visit(node, parameter);
+    }
+
+    @Override
+    public Result visit(TArtifactDefinition node, Parameter parameter) {
+        node.getFiles().forEach(file -> {
+                if (!Files.exists(path.resolve(file))) {
+                    setException(new UndefinedFile(
+                        "Artifact file '{}' is undefined",
+                        path.resolve(file)
+                    ));
+                }
+            }
+        );
+        return super.visit(node, parameter);
+    }
+
+    private Boolean isDefined(QName name, Map<String, List<String>> map) {
+        return Objects.isNull(name) || map.containsKey(name.getNamespaceURI()) && map.get(name.getNamespaceURI()).contains(name.getLocalPart());
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/DefinitionsVisitor.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/DefinitionsVisitor.java
new file mode 100644
index 000000000..b30a2e48b
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/DefinitionsVisitor.java
@@ -0,0 +1,65 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.validator;
+
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.eclipse.winery.model.tosca.yaml.TNodeTemplate;
+import org.eclipse.winery.model.tosca.yaml.TRepositoryDefinition;
+import org.eclipse.winery.repository.backend.filebased.converter.support.validator.support.Parameter;
+import org.eclipse.winery.repository.backend.filebased.converter.support.validator.support.Result;
+
+public class DefinitionsVisitor extends ImportVisitor {
+    private Map<String, List<String>> nodeTemplates;
+    private Map<String, List<String>> repositoryDefinitions;
+
+    public DefinitionsVisitor(String namespace, Path path) {
+        super(namespace, path);
+        this.nodeTemplates = new LinkedHashMap<>();
+        this.repositoryDefinitions = new LinkedHashMap<>();
+    }
+
+    @Override
+    public Result visit(TNodeTemplate node, Parameter parameter) {
+        setDefinitions(parameter.getKey(), nodeTemplates);
+        return super.visit(node, parameter);
+    }
+
+    @Override
+    public Result visit(TRepositoryDefinition node, Parameter parameter) {
+        setDefinitions(parameter.getKey(), repositoryDefinitions);
+        return super.visit(node, parameter);
+    }
+
+    private void setDefinitions(String name, Map<String, List<String>> map) {
+        if (map.containsKey(namespace)) {
+            map.get(namespace).add(name);
+        } else {
+            map.put(namespace, new ArrayList<>(Collections.singletonList(name)));
+        }
+    }
+
+    public Map<String, List<String>> getNodeTemplates() {
+        return nodeTemplates;
+    }
+
+    public Map<String, List<String>> getRepositoryDefinitions() {
+        return repositoryDefinitions;
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/FieldValidator.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/FieldValidator.java
new file mode 100644
index 000000000..302f1d97e
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/FieldValidator.java
@@ -0,0 +1,88 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.validator;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+import javax.xml.bind.annotation.XmlAttribute;
+import javax.xml.bind.annotation.XmlElement;
+
+import org.eclipse.winery.model.tosca.yaml.TArtifactDefinition;
+import org.eclipse.winery.repository.backend.filebased.converter.support.exception.InvalidToscaSyntax;
+import org.eclipse.winery.repository.backend.filebased.converter.support.reader.yaml.Builder;
+
+public class FieldValidator {
+    private Map<Class, Set<String>> declaredFields;
+
+    public FieldValidator() {
+        this.declaredFields = new LinkedHashMap<>();
+    }
+
+    private void setDeclaredFields(Class base, Class parent) {
+        if (!this.declaredFields.containsKey(base)) {
+            this.declaredFields.put(base, new HashSet<>());
+        }
+
+        if (parent.equals(TArtifactDefinition.class)) {
+            this.declaredFields.get(base).add("file");
+        }
+
+        if (!parent.equals(Object.class)) {
+            this.declaredFields.get(base)
+                .addAll(Arrays.stream(parent.getDeclaredFields()).map(field -> {
+                        XmlAttribute xmlAttribute = field.getAnnotation(XmlAttribute.class);
+                        XmlElement xmlElement = field.getAnnotation(XmlElement.class);
+                        if (Objects.nonNull(xmlAttribute) && !xmlAttribute.name().equals("##default")) {
+                            return xmlAttribute.name();
+                        } else if (Objects.nonNull(xmlElement) && !xmlElement.name().equals("##default")) {
+                            return xmlElement.name();
+                        } else {
+                            return field.getName();
+                        }
+                    }
+                ).collect(Collectors.toList()));
+            setDeclaredFields(base, parent.getSuperclass());
+        }
+    }
+
+    public <T, K> List<Exception> validate(Class<T> t, Map<String, Object> fields, Builder.Parameter<K> parameter) {
+        List<Exception> exceptions = new ArrayList<>();
+
+        if (!fields.isEmpty() && !this.declaredFields.containsKey(t)) {
+            setDeclaredFields(t, t);
+        }
+
+        Set<String> declaredFields = this.declaredFields.get(t);
+        fields.forEach((key, value) -> {
+            if (!declaredFields.contains(key)) {
+                exceptions.add(new InvalidToscaSyntax(
+                        "Class '{}' has no field with name '{}'\n Possible fields are '{}'",
+                        t.getName(),
+                        key,
+                        declaredFields
+                    ).setContext(new ArrayList<>(parameter.copy().addContext(key).getContext()))
+                );
+            }
+        });
+        return exceptions;
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/ImportVisitor.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/ImportVisitor.java
new file mode 100644
index 000000000..ad8613bb9
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/ImportVisitor.java
@@ -0,0 +1,102 @@
+/********************************************************************************
+ * Copyright (c) 2017-2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.validator;
+
+import java.io.InputStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.nio.file.StandardCopyOption;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Objects;
+import java.util.Set;
+
+import org.eclipse.winery.model.tosca.yaml.TImportDefinition;
+import org.eclipse.winery.model.tosca.yaml.TServiceTemplate;
+import org.eclipse.winery.repository.backend.filebased.converter.support.Defaults;
+import org.eclipse.winery.repository.backend.filebased.converter.support.Namespaces;
+import org.eclipse.winery.repository.backend.filebased.converter.support.Utils;
+import org.eclipse.winery.repository.backend.filebased.converter.support.exception.MultiException;
+import org.eclipse.winery.repository.backend.filebased.converter.support.reader.yaml.Reader;
+import org.eclipse.winery.repository.backend.filebased.converter.support.validator.support.ExceptionVisitor;
+import org.eclipse.winery.repository.backend.filebased.converter.support.validator.support.Parameter;
+import org.eclipse.winery.repository.backend.filebased.converter.support.validator.support.Result;
+
+public class ImportVisitor extends ExceptionVisitor<Result, Parameter> {
+    protected final Path path;
+    protected String namespace;
+
+    public ImportVisitor(String namespace, Path path) {
+        this.path = path;
+        this.namespace = namespace;
+    }
+
+    @Override
+    public Result visit(TServiceTemplate node, Parameter parameter) {
+        Reader reader = new Reader();
+        if (!this.namespace.equals(Namespaces.TOSCA_NS)) {
+            Set<String> typeDefinitions = new HashSet<>(Arrays.asList(
+                Defaults.TOSCA_NORMATIVE_TYPES, Defaults.TOSCA_NONNORMATIVE_TYPES));
+            String tmpNamespace = this.namespace;
+            this.namespace = Namespaces.TOSCA_NS;
+            Path tmpDir = Utils.getTmpDir(Paths.get("types"));
+            for (String typeDefinition : typeDefinitions) {
+                try {
+                    Path outFilePath = tmpDir.resolve(typeDefinition);
+                    InputStream inputStream = this.getClass().getResourceAsStream(
+                        // Do not use File.separator here (https://stackoverflow.com/a/41677152/8235252)
+                        "/".concat(typeDefinition)
+                    );
+                    Files.copy(inputStream, outFilePath, StandardCopyOption.REPLACE_EXISTING);
+                    TServiceTemplate serviceTemplate = reader.parseSkipTest(outFilePath, Namespaces.TOSCA_NS);
+                    if (Objects.nonNull(serviceTemplate)) {
+                        serviceTemplate.accept(this, new Parameter());
+                    }
+                } catch (MultiException e) {
+                    setException(e);
+                } catch (Exception e) {
+                    e.printStackTrace();
+                }
+            }
+            this.namespace = tmpNamespace;
+        }
+
+        super.visit(node, parameter);
+        return null;
+    }
+
+    @Override
+    public Result visit(TImportDefinition node, Parameter parameter) {
+        Reader reader = new Reader();
+        String importNamespace = node.getNamespaceUri() == null ? this.namespace : node.getNamespaceUri();
+        try {
+            TServiceTemplate serviceTemplate = reader.parse(node, path, importNamespace);
+            if (serviceTemplate != null) {
+                String tmpNamespace = this.namespace;
+                this.namespace = importNamespace;
+                this.visit(serviceTemplate, new Parameter());
+                this.namespace = tmpNamespace;
+            }
+            super.visit(node, parameter);
+        } catch (MultiException e) {
+            this.setException(e);
+        }
+        return null;
+    }
+
+    public void setNamespace(String namespace) {
+        this.namespace = namespace;
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/ObjectValidator.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/ObjectValidator.java
new file mode 100644
index 000000000..a72a78e38
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/ObjectValidator.java
@@ -0,0 +1,38 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.validator;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Set;
+
+import org.eclipse.winery.repository.backend.filebased.converter.support.exception.InvalidToscaSyntax;
+
+public class ObjectValidator {
+    public void validateObject(Object object) throws InvalidToscaSyntax {
+        if (object instanceof LinkedHashMap) {
+            LinkedHashMap map = (LinkedHashMap) object;
+            Set<Map.Entry> entries = map.entrySet();
+            if (entries.size() == 0 || !entries.iterator().next().getKey().equals("tosca_definitions_version")) {
+                for (Map.Entry entry : entries) {
+                    if (entry.getKey().equals("tosca_definitions_version")) {
+                        throw new InvalidToscaSyntax(
+                            "The field tosca_definitions_version MUST be defined before all other YAML elements"
+                        );
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/TypeValidator.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/TypeValidator.java
new file mode 100644
index 000000000..782f8eb9a
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/TypeValidator.java
@@ -0,0 +1,243 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.validator;
+
+import java.nio.file.Path;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+
+import javax.xml.namespace.QName;
+
+import org.eclipse.winery.model.tosca.yaml.TArtifactType;
+import org.eclipse.winery.model.tosca.yaml.TAttributeDefinition;
+import org.eclipse.winery.model.tosca.yaml.TCapabilityType;
+import org.eclipse.winery.model.tosca.yaml.TDataType;
+import org.eclipse.winery.model.tosca.yaml.TEntityType;
+import org.eclipse.winery.model.tosca.yaml.TEntrySchema;
+import org.eclipse.winery.model.tosca.yaml.TGroupDefinition;
+import org.eclipse.winery.model.tosca.yaml.TGroupType;
+import org.eclipse.winery.model.tosca.yaml.TInterfaceType;
+import org.eclipse.winery.model.tosca.yaml.TNodeTemplate;
+import org.eclipse.winery.model.tosca.yaml.TNodeType;
+import org.eclipse.winery.model.tosca.yaml.TPolicyDefinition;
+import org.eclipse.winery.model.tosca.yaml.TPolicyType;
+import org.eclipse.winery.model.tosca.yaml.TPropertyDefinition;
+import org.eclipse.winery.model.tosca.yaml.TRelationshipTemplate;
+import org.eclipse.winery.model.tosca.yaml.TRelationshipType;
+import org.eclipse.winery.model.tosca.yaml.TServiceTemplate;
+import org.eclipse.winery.repository.backend.filebased.converter.support.Defaults;
+import org.eclipse.winery.repository.backend.filebased.converter.support.Namespaces;
+import org.eclipse.winery.repository.backend.filebased.converter.support.exception.InvalidDefinition;
+import org.eclipse.winery.repository.backend.filebased.converter.support.exception.InvalidTypeExtend;
+import org.eclipse.winery.repository.backend.filebased.converter.support.exception.MultiException;
+import org.eclipse.winery.repository.backend.filebased.converter.support.exception.UndefinedType;
+import org.eclipse.winery.repository.backend.filebased.converter.support.validator.support.ExceptionVisitor;
+import org.eclipse.winery.repository.backend.filebased.converter.support.validator.support.Parameter;
+import org.eclipse.winery.repository.backend.filebased.converter.support.validator.support.Result;
+
+public class TypeValidator extends ExceptionVisitor<Result, Parameter> {
+    private TypeVisitor typeVisitor;
+
+    public TypeValidator(Path path, String namespace) {
+        this.typeVisitor = new TypeVisitor(namespace, path);
+        this.typeVisitor.addDataTypes(Defaults.YAML_TYPES, Namespaces.YAML_NS);
+        this.typeVisitor.addDataTypes(Defaults.TOSCA_TYPES, Namespaces.TOSCA_NS);
+    }
+
+    public void validate(TServiceTemplate serviceTemplate) throws MultiException {
+        serviceTemplate.accept(typeVisitor, new Parameter());
+        if (typeVisitor.hasExceptions()) {
+            this.setException(this.typeVisitor.getException());
+        }
+
+        serviceTemplate.accept(this, new Parameter());
+        if (this.hasExceptions()) {
+            throw this.getException();
+        }
+    }
+
+    /**
+     * Validates that a map of lists contains a list mapped to the namespace uri of a QName and the list contains the
+     * local name of the QName
+     */
+    private void validateTypeIsDefined(QName type, Map<String, List<String>> map, Parameter parameter) {
+        if (!(map.containsKey(type.getNamespaceURI()) && map.get(type.getNamespaceURI()).contains(type.getLocalPart()))) {
+            setException(new UndefinedType(
+                "Type '{}' is undefined\nKnown types: {}",
+                type,
+                map
+            ).setContext(parameter.getContext()));
+        }
+    }
+
+    private void setInvalidDefinition(Parameter parameter) {
+        setException(new InvalidDefinition(
+            "Type '{}:type' is required",
+            parameter.getKey()
+        ).setContext(parameter.getContext()));
+    }
+
+    private void validateEntityType(TEntityType node, Parameter parameter, Map<String, List<String>> types) {
+        if (Objects.nonNull(node.getDerivedFrom())) {
+            validateTypeIsDefined(node.getDerivedFrom(), types, parameter.copy().addContext("derived_from"));
+        }
+    }
+
+    private void validatePropertyOrAttributeDefinition(QName type, TEntrySchema entrySchema, Parameter parameter) {
+        if (Objects.isNull(type)) {
+            setInvalidDefinition(parameter);
+        } else {
+            validateTypeIsDefined(type, typeVisitor.getDataTypes(), parameter.copy().addContext("type"));
+
+            if (type.getLocalPart().equals("list") || type.getLocalPart().equals("map")) {
+                if (Objects.isNull(entrySchema)) {
+                    setException(new InvalidDefinition(
+                        "EntrySchema '{}:entry_schema' is required for '{}:type: {}'",
+                        parameter.getKey(),
+                        parameter.getKey(),
+                        type.getLocalPart()
+                    ).setContext(parameter.getContext()));
+                } else if (Objects.isNull(entrySchema.getType())) {
+                    setInvalidDefinition(parameter.copy().addContext("entry_schema"));
+                } else {
+                    validateTypeIsDefined(
+                        entrySchema.getType(),
+                        typeVisitor.getDataTypes(),
+                        parameter.copy().addContext("entry_schema").addContext("type")
+                    );
+                }
+            }
+        }
+    }
+
+    @Override
+    public Result visit(TArtifactType node, Parameter parameter) {
+        validateEntityType(node, parameter, typeVisitor.getArtifactTypes());
+        return super.visit(node, parameter);
+    }
+
+    @Override
+    public Result visit(TCapabilityType node, Parameter parameter) {
+        validateEntityType(node, parameter, typeVisitor.getCapabilityTypes());
+
+        for (QName source : node.getValidSourceTypes()) {
+            validateTypeIsDefined(source, typeVisitor.getNodeTypes(), parameter.copy().addContext("valid_source_types"));
+        }
+
+        return super.visit(node, parameter);
+    }
+
+    @Override
+    public Result visit(TDataType node, Parameter parameter) {
+        validateEntityType(node, parameter, typeVisitor.getDataTypes());
+
+        // Extend a native DataType should fail
+        if (Objects.nonNull(node.getDerivedFrom()) &&
+            (Defaults.YAML_TYPES.contains(node.getDerivedFrom().getLocalPart()) ||
+                Defaults.TOSCA_TYPES.contains(node.getDerivedFrom().getLocalPart())
+            ) &&
+            !node.getProperties().isEmpty()) {
+            setException(new InvalidTypeExtend(
+                    "The native data type '{}' cannot be extended with properties!",
+                    parameter.getKey()
+                ).setContext(parameter.getContext())
+            );
+        }
+
+        return super.visit(node, parameter);
+    }
+
+    @Override
+    public Result visit(TGroupType node, Parameter parameter) {
+        validateEntityType(node, parameter, typeVisitor.getGroupTypes());
+        return super.visit(node, parameter);
+    }
+
+    @Override
+    public Result visit(TInterfaceType node, Parameter parameter) {
+        validateEntityType(node, parameter, typeVisitor.getInterfaceTypes());
+        return super.visit(node, parameter);
+    }
+
+    @Override
+    public Result visit(TRelationshipType node, Parameter parameter) {
+        validateEntityType(node, parameter, typeVisitor.getRelationshipTypes());
+        return super.visit(node, parameter);
+    }
+
+    @Override
+    public Result visit(TNodeType node, Parameter parameter) {
+        validateEntityType(node, parameter, typeVisitor.getNodeTypes());
+        return super.visit(node, parameter);
+    }
+
+    @Override
+    public Result visit(TPolicyType node, Parameter parameter) {
+        validateEntityType(node, parameter, typeVisitor.getPolicyTypes());
+        return super.visit(node, parameter);
+    }
+
+    @Override
+    public Result visit(TNodeTemplate node, Parameter parameter) {
+        if (Objects.isNull(node.getType())) {
+            setInvalidDefinition(parameter);
+        } else {
+            validateTypeIsDefined(node.getType(), typeVisitor.getNodeTypes(), parameter.copy().addContext("type"));
+        }
+        return super.visit(node, parameter);
+    }
+
+    @Override
+    public Result visit(TRelationshipTemplate node, Parameter parameter) {
+        if (Objects.isNull(node.getType())) {
+            setInvalidDefinition(parameter);
+        } else {
+            validateTypeIsDefined(node.getType(), typeVisitor.getRelationshipTypes(), parameter.copy().addContext("type"));
+        }
+        return super.visit(node, parameter);
+    }
+
+    @Override
+    public Result visit(TGroupDefinition node, Parameter parameter) {
+        if (Objects.isNull(node.getType())) {
+            setInvalidDefinition(parameter);
+        } else {
+            validateTypeIsDefined(node.getType(), typeVisitor.getGroupTypes(), parameter.copy().addContext("type"));
+        }
+        return super.visit(node, parameter);
+    }
+
+    @Override
+    public Result visit(TPolicyDefinition node, Parameter parameter) {
+        if (Objects.isNull(node.getType())) {
+            setInvalidDefinition(parameter);
+        } else {
+            validateTypeIsDefined(node.getType(), typeVisitor.getPolicyTypes(), parameter.copy().addContext("type"));
+        }
+        return super.visit(node, parameter);
+    }
+
+    @Override
+    public Result visit(TPropertyDefinition node, Parameter parameter) {
+        validatePropertyOrAttributeDefinition(node.getType(), node.getEntrySchema(), parameter);
+        return super.visit(node, parameter);
+    }
+
+    @Override
+    public Result visit(TAttributeDefinition node, Parameter parameter) {
+        validatePropertyOrAttributeDefinition(node.getType(), node.getEntrySchema(), parameter);
+        return super.visit(node, parameter);
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/TypeVisitor.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/TypeVisitor.java
new file mode 100644
index 000000000..ee2eeed33
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/TypeVisitor.java
@@ -0,0 +1,245 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.validator;
+
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.eclipse.winery.model.tosca.yaml.TArtifactType;
+import org.eclipse.winery.model.tosca.yaml.TCapabilityType;
+import org.eclipse.winery.model.tosca.yaml.TDataType;
+import org.eclipse.winery.model.tosca.yaml.TGroupType;
+import org.eclipse.winery.model.tosca.yaml.TInterfaceType;
+import org.eclipse.winery.model.tosca.yaml.TNodeType;
+import org.eclipse.winery.model.tosca.yaml.TPolicyType;
+import org.eclipse.winery.model.tosca.yaml.TRelationshipType;
+import org.eclipse.winery.model.tosca.yaml.support.Metadata;
+import org.eclipse.winery.repository.backend.filebased.converter.support.Namespaces;
+import org.eclipse.winery.repository.backend.filebased.converter.support.validator.support.Parameter;
+import org.eclipse.winery.repository.backend.filebased.converter.support.validator.support.Result;
+
+public class TypeVisitor extends ImportVisitor {
+    private Map<String, List<String>> artifactTypes;
+    private Map<String, List<String>> dataTypes;
+    private Map<String, List<String>> capabilityTypes;
+    private Map<String, List<String>> interfaceTypes;
+    private Map<String, List<String>> relationshipTypes;
+    private Map<String, List<String>> nodeTypes;
+    private Map<String, List<String>> groupTypes;
+    private Map<String, List<String>> policyTypes;
+
+    public TypeVisitor(String namespace, Path path) {
+        super(namespace, path);
+        this.artifactTypes = new LinkedHashMap<>();
+        this.dataTypes = new LinkedHashMap<>();
+        this.capabilityTypes = new LinkedHashMap<>();
+        this.interfaceTypes = new LinkedHashMap<>();
+        this.relationshipTypes = new LinkedHashMap<>();
+        this.nodeTypes = new LinkedHashMap<>();
+        this.groupTypes = new LinkedHashMap<>();
+        this.policyTypes = new LinkedHashMap<>();
+    }
+
+    @Override
+    public Result visit(TArtifactType node, Parameter parameter) {
+        this.setArtifactTypes(namespace, parameter.getKey());
+        setNormativeTypes(parameter.getKey(), node.getMetadata(), artifactTypes);
+        super.visit(node, parameter);
+        return null;
+    }
+
+    @Override
+    public Result visit(TDataType node, Parameter parameter) {
+        this.setDataTypes(namespace, parameter.getKey());
+        setNormativeTypes(parameter.getKey(), node.getMetadata(), dataTypes);
+        super.visit(node, parameter);
+        return null;
+    }
+
+    @Override
+    public Result visit(TCapabilityType node, Parameter parameter) {
+        this.setCapabilityTypes(namespace, parameter.getKey());
+        setNormativeTypes(parameter.getKey(), node.getMetadata(), capabilityTypes);
+        super.visit(node, parameter);
+        return null;
+    }
+
+    @Override
+    public Result visit(TInterfaceType node, Parameter parameter) {
+        this.setInterfaceTypes(namespace, parameter.getKey());
+        setNormativeTypes(parameter.getKey(), node.getMetadata(), interfaceTypes);
+        super.visit(node, parameter);
+        return null;
+    }
+
+    @Override
+    public Result visit(TRelationshipType node, Parameter parameter) {
+        this.setRelationshipTypes(namespace, parameter.getKey());
+        setNormativeTypes(parameter.getKey(), node.getMetadata(), relationshipTypes);
+        super.visit(node, parameter);
+        return null;
+    }
+
+    @Override
+    public Result visit(TNodeType node, Parameter parameter) {
+        this.setNodeTypes(namespace, parameter.getKey());
+        setNormativeTypes(parameter.getKey(), node.getMetadata(), nodeTypes);
+        super.visit(node, parameter);
+        return null;
+    }
+
+    @Override
+    public Result visit(TGroupType node, Parameter parameter) {
+        this.setGroupTypes(namespace, parameter.getKey());
+        setNormativeTypes(parameter.getKey(), node.getMetadata(), groupTypes);
+        super.visit(node, parameter);
+        return null;
+    }
+
+    @Override
+    public Result visit(TPolicyType node, Parameter parameter) {
+        this.setPolicyTypes(namespace, parameter.getKey());
+        setNormativeTypes(parameter.getKey(), node.getMetadata(), policyTypes);
+        super.visit(node, parameter);
+        return null;
+    }
+
+    public void setNormativeTypes(String name, Metadata metadata, Map<String, List<String>> map) {
+        if (namespace.equals(Namespaces.TOSCA_NS) && metadata != null) {
+            String shorthandName = metadata.get("shorthand_name");
+            String typeUri = metadata.get("type_uri");
+
+            if (shorthandName != null && !shorthandName.equals(name)) {
+                if (map.containsKey(namespace)) {
+                    map.get(namespace).add(shorthandName);
+                } else {
+                    map.put(namespace, new ArrayList<>(Arrays.asList(shorthandName)));
+                }
+            } else if (typeUri != null && !typeUri.equals(name)) {
+                if (map.containsKey(namespace)) {
+                    map.get(namespace).add(typeUri);
+                } else {
+                    map.put(namespace, new ArrayList<>(Arrays.asList(typeUri)));
+                }
+            }
+        }
+    }
+
+    private void setArtifactTypes(String namespace, String name) {
+        if (artifactTypes.containsKey(namespace)) {
+            artifactTypes.get(namespace).add(name);
+        } else {
+            artifactTypes.put(namespace, new ArrayList<>(Arrays.asList(name)));
+        }
+    }
+
+    private void setDataTypes(String namespace, String name) {
+        if (dataTypes.containsKey(namespace)) {
+            dataTypes.get(namespace).add(name);
+        } else {
+            dataTypes.put(namespace, new ArrayList<>(Collections.singletonList(name)));
+        }
+    }
+
+    private void setCapabilityTypes(String namespace, String name) {
+        if (capabilityTypes.containsKey(namespace)) {
+            capabilityTypes.get(namespace).add(name);
+        } else {
+            capabilityTypes.put(namespace, new ArrayList<>(Arrays.asList(name)));
+        }
+    }
+
+    private void setInterfaceTypes(String namespace, String name) {
+        if (interfaceTypes.containsKey(namespace)) {
+            interfaceTypes.get(namespace).add(name);
+        } else {
+            interfaceTypes.put(namespace, new ArrayList<>(Arrays.asList(name)));
+        }
+    }
+
+    private void setRelationshipTypes(String namespace, String name) {
+        if (relationshipTypes.containsKey(namespace)) {
+            relationshipTypes.get(namespace).add(name);
+        } else {
+            relationshipTypes.put(namespace, new ArrayList<>(Arrays.asList(name)));
+        }
+    }
+
+    private void setNodeTypes(String namespace, String name) {
+        if (nodeTypes.containsKey(namespace)) {
+            nodeTypes.get(namespace).add(name);
+        } else {
+            nodeTypes.put(namespace, new ArrayList<>(Arrays.asList(name)));
+        }
+    }
+
+    private void setGroupTypes(String namespace, String name) {
+        if (groupTypes.containsKey(namespace)) {
+            groupTypes.get(namespace).add(name);
+        } else {
+            groupTypes.put(namespace, new ArrayList<>(Arrays.asList(name)));
+        }
+    }
+
+    private void setPolicyTypes(String namespace, String name) {
+        if (policyTypes.containsKey(namespace)) {
+            policyTypes.get(namespace).add(name);
+        } else {
+            policyTypes.put(namespace, new ArrayList<>(Arrays.asList(name)));
+        }
+    }
+
+    public void addDataTypes(List<String> types, String namespace) {
+        for (String entry : types) {
+            setDataTypes(namespace, entry);
+        }
+    }
+
+    public Map<String, List<String>> getArtifactTypes() {
+        return artifactTypes;
+    }
+
+    public Map<String, List<String>> getDataTypes() {
+        return dataTypes;
+    }
+
+    public Map<String, List<String>> getCapabilityTypes() {
+        return capabilityTypes;
+    }
+
+    public Map<String, List<String>> getInterfaceTypes() {
+        return interfaceTypes;
+    }
+
+    public Map<String, List<String>> getRelationshipTypes() {
+        return relationshipTypes;
+    }
+
+    public Map<String, List<String>> getNodeTypes() {
+        return nodeTypes;
+    }
+
+    public Map<String, List<String>> getGroupTypes() {
+        return groupTypes;
+    }
+
+    public Map<String, List<String>> getPolicyTypes() {
+        return policyTypes;
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/Validator.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/Validator.java
new file mode 100644
index 000000000..4782e368c
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/Validator.java
@@ -0,0 +1,150 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.validator;
+
+import java.nio.file.Path;
+import java.util.Map;
+import java.util.Objects;
+
+import org.eclipse.winery.model.tosca.yaml.TImportDefinition;
+import org.eclipse.winery.model.tosca.yaml.TInterfaceType;
+import org.eclipse.winery.model.tosca.yaml.TOperationDefinition;
+import org.eclipse.winery.model.tosca.yaml.TRepositoryDefinition;
+import org.eclipse.winery.model.tosca.yaml.TServiceTemplate;
+import org.eclipse.winery.model.tosca.yaml.support.Metadata;
+import org.eclipse.winery.model.tosca.yaml.tosca.datatypes.Credential;
+import org.eclipse.winery.repository.backend.filebased.converter.support.Defaults;
+import org.eclipse.winery.repository.backend.filebased.converter.support.exception.InvalidToscaSyntax;
+import org.eclipse.winery.repository.backend.filebased.converter.support.exception.InvalidToscaVersion;
+import org.eclipse.winery.repository.backend.filebased.converter.support.exception.MultiException;
+import org.eclipse.winery.repository.backend.filebased.converter.support.exception.UndefinedFile;
+import org.eclipse.winery.repository.backend.filebased.converter.support.exception.UndefinedRequiredKeyname;
+import org.eclipse.winery.repository.backend.filebased.converter.support.exception.UndefinedToscaVersion;
+import org.eclipse.winery.repository.backend.filebased.converter.support.validator.support.ExceptionVisitor;
+import org.eclipse.winery.repository.backend.filebased.converter.support.validator.support.Parameter;
+import org.eclipse.winery.repository.backend.filebased.converter.support.validator.support.Result;
+
+public class Validator extends ExceptionVisitor<Result, Parameter> {
+    private final Path path;
+
+    public Validator(Path path) {
+        this.path = path;
+    }
+
+    public void validate(TServiceTemplate serviceTemplate, String namespace) throws MultiException {
+        if (Objects.isNull(serviceTemplate)) return;
+
+        TypeValidator typeValidator = new TypeValidator(path, namespace);
+        typeValidator.validate(serviceTemplate);
+
+        DefinitionValidator definitionValidator = new DefinitionValidator(path);
+        definitionValidator.validate(serviceTemplate);
+
+        serviceTemplate.accept(this, new Parameter());
+
+        if (this.hasExceptions()) throw this.getException();
+    }
+
+    @Override
+    public Result visit(TInterfaceType node, Parameter parameter) {
+        if (Objects.nonNull(node.getOperations())) {
+            for (Map.Entry<String, TOperationDefinition> entry : node.getOperations().entrySet()) {
+                if (Objects.nonNull(entry.getValue().getImplementation())) {
+                    setException(new InvalidToscaSyntax(
+                            "The InterfaceType '{}' MUST NOT include any implementations for defined operations",
+                            parameter.getKey()
+                        ).setContext(parameter.getContext())
+                    );
+                }
+            }
+        }
+        return super.visit(node, parameter);
+    }
+
+    @Override
+    public Result visit(TImportDefinition node, Parameter parameter) {
+        if (Objects.isNull(node.getFile()) || node.getFile().isEmpty()) {
+            setException(new UndefinedFile("Field 'file' is undefined")
+                .setContext(parameter.getContext())
+            );
+        }
+        return super.visit(node, parameter);
+    }
+
+    @Override
+    public Result visit(TServiceTemplate node, Parameter parameter) {
+        if (Objects.isNull(node.getToscaDefinitionsVersion())) {
+            setException(new UndefinedToscaVersion(
+                    "The field 'tosca_definition_version' is undefined"
+                ).setContext(parameter.getContext())
+            );
+        }
+
+        if (!node.getToscaDefinitionsVersion().matches(Defaults.TOSCA_DEFINITIONS_VERSION_PATTERN)) {
+            setException(new InvalidToscaVersion(
+                    "The value '{}' is invalid for 'tosca_definition_version' \nValid values match the pattern '{}'",
+                    node.getToscaDefinitionsVersion(),
+                    Defaults.TOSCA_DEFINITIONS_VERSION_PATTERN
+                ).setContext(parameter.getContext())
+            );
+        }
+        return super.visit(node, parameter);
+    }
+
+    @Override
+    public Result visit(TRepositoryDefinition node, Parameter parameter) {
+        if (Objects.isNull(node)) return null;
+
+        if (Objects.isNull(node.getUrl()) || node.getUrl().isEmpty()) {
+            setException(new UndefinedRequiredKeyname("Field 'url' is required")
+                .setContext(parameter.getContext())
+            );
+        }
+
+        if (Objects.nonNull(node.getCredential())) {
+            Credential credential = node.getCredential();
+            if (Objects.isNull(credential.getToken()) || credential.getToken().isEmpty()) {
+                setException(new UndefinedRequiredKeyname("Field 'credential.token' is required")
+                    .setContext(parameter.getContext())
+                );
+            }
+            if (Objects.isNull(credential.getTokenType()) || credential.getTokenType().isEmpty()) {
+                setException(new UndefinedRequiredKeyname("Field 'credential.token_type' is required")
+                    .setContext(parameter.getContext())
+                );
+            }
+        }
+        return super.visit(node, parameter);
+    }
+
+    @Override
+    public Result visit(Metadata node, Parameter parameter) {
+        if (Objects.isNull(node)) return null;
+
+        if (node.containsKey("template_version")) {
+            String templateVersion = node.get("template_version");
+            String templateVersionMatch = "\\d+\\.\\d+(\\.\\d+(\\.\\w+(-\\d+)?)?)?";
+
+            if (!templateVersion.matches(templateVersionMatch)) {
+                setException(new InvalidToscaSyntax(
+                        "Invalid value '{}' for field template_version\nValid version pattern matches '{}'",
+                        templateVersion,
+                        templateVersionMatch
+                    ).setContext(parameter.getContext())
+                );
+            }
+        }
+        return super.visit(node, parameter);
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/support/ExceptionInterpreter.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/support/ExceptionInterpreter.java
new file mode 100644
index 000000000..523cdc466
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/support/ExceptionInterpreter.java
@@ -0,0 +1,61 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.validator.support;
+
+import org.eclipse.winery.repository.backend.filebased.converter.support.exception.InvalidYamlSyntax;
+
+import org.yaml.snakeyaml.constructor.ConstructorException;
+import org.yaml.snakeyaml.error.MarkedYAMLException;
+import org.yaml.snakeyaml.scanner.ScannerException;
+
+public class ExceptionInterpreter {
+    public Exception interpret(ConstructorException e) {
+        String context = "";
+        if (e.getCause() instanceof MarkedYAMLException) {
+            context = ((MarkedYAMLException) e.getCause()).getContext();
+        } else {
+            return new InvalidYamlSyntax(e.toString());
+        }
+        String messagePattern = "The property= '{}' could not be interpreted by the SnakeYAML parser\n{}";
+        String invalidDescription = "Cannot create property=description.*";
+        if (context.matches(invalidDescription)) {
+            return new InvalidYamlSyntax(messagePattern, "description", e);
+        }
+        String invalidType = "Cannot create property=metadata.*";
+        if (context.matches(invalidType)) {
+            return new InvalidYamlSyntax(messagePattern, "metadata", e);
+        }
+
+        return new InvalidYamlSyntax(e.toString());
+    }
+
+    public Exception interpret(ScannerException e) {
+        String scalarScanning = "while scanning a plain scalar";
+        if (e.getContext() != null && e.getContext().matches(scalarScanning)) {
+            String unexpected = "found unexpected ':'";
+            if (e.getProblem().matches(unexpected)) {
+                String msg = "Using \":\" in values in flow context is invalid \n" +
+                    "Put all names (especially URIs) in parentheses. \n\n" +
+                    "(Example INVALID: { get_operation_output: [ SELF, http://www.example.com/interface/lifecycle, " +
+                    "operationName, outputName ] })\n" +
+                    "(Example VALID:   { get_operation_output: [ SELF, \"http://www.example.com/interface/lifecycle\", " +
+                    "operationName, outputName ] })\n\n" +
+                    e.getMessage();
+                return new InvalidYamlSyntax(msg);
+            }
+        }
+
+        return new InvalidYamlSyntax(e.toString());
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/support/ExceptionVisitor.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/support/ExceptionVisitor.java
new file mode 100644
index 000000000..e2d8c0c6d
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/support/ExceptionVisitor.java
@@ -0,0 +1,40 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.validator.support;
+
+import java.util.Objects;
+
+import org.eclipse.winery.model.tosca.yaml.visitor.AbstractParameter;
+import org.eclipse.winery.model.tosca.yaml.visitor.AbstractResult;
+import org.eclipse.winery.model.tosca.yaml.visitor.AbstractVisitor;
+import org.eclipse.winery.repository.backend.filebased.converter.support.exception.MultiException;
+
+public abstract class ExceptionVisitor<R extends AbstractResult<R>, P extends AbstractParameter<P>> extends AbstractVisitor<R, P> {
+    private MultiException exception;
+
+    public MultiException getException() {
+        return exception;
+    }
+
+    public void setException(Exception exception) {
+        if (Objects.isNull(this.exception)) {
+            this.exception = new MultiException();
+        }
+        this.exception.add(exception);
+    }
+
+    public boolean hasExceptions() {
+        return Objects.nonNull(this.exception);
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/support/Parameter.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/support/Parameter.java
new file mode 100644
index 000000000..d006e64e4
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/support/Parameter.java
@@ -0,0 +1,31 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.validator.support;
+
+import org.eclipse.winery.model.tosca.yaml.visitor.AbstractParameter;
+
+public class Parameter extends AbstractParameter<Parameter> {
+
+    @Override
+    public Parameter copy() {
+        Parameter parameter = new Parameter();
+        parameter.getContext().addAll(this.getContext());
+        return parameter;
+    }
+
+    @Override
+    public Parameter self() {
+        return this;
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/support/Result.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/support/Result.java
new file mode 100644
index 000000000..d514ddaed
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/validator/support/Result.java
@@ -0,0 +1,24 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.validator.support;
+
+import org.eclipse.winery.model.tosca.yaml.visitor.AbstractResult;
+
+public class Result extends AbstractResult<Result> {
+
+    @Override
+    public Result add(Result result) {
+        return result;
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/writer/WriterUtils.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/writer/WriterUtils.java
new file mode 100644
index 000000000..5fb936c10
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/writer/WriterUtils.java
@@ -0,0 +1,256 @@
+/********************************************************************************
+ * Copyright (c) 2017-2018 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.writer;
+
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import javax.xml.bind.JAXBException;
+import javax.xml.transform.OutputKeys;
+import javax.xml.transform.Transformer;
+import javax.xml.transform.TransformerException;
+import javax.xml.transform.TransformerFactory;
+import javax.xml.transform.dom.DOMSource;
+import javax.xml.transform.stream.StreamResult;
+
+import org.eclipse.winery.common.RepositoryFileReference;
+import org.eclipse.winery.common.Util;
+import org.eclipse.winery.common.ids.definitions.ArtifactTemplateId;
+import org.eclipse.winery.common.ids.definitions.DefinitionsChildId;
+import org.eclipse.winery.common.ids.definitions.imports.GenericImportId;
+import org.eclipse.winery.common.ids.definitions.imports.XSDImportId;
+import org.eclipse.winery.model.tosca.Definitions;
+import org.eclipse.winery.model.tosca.TArtifactTemplate;
+import org.eclipse.winery.model.tosca.TDefinitions;
+import org.eclipse.winery.model.tosca.TImport;
+import org.eclipse.winery.model.tosca.utils.ModelUtilities;
+import org.eclipse.winery.repository.backend.BackendUtils;
+import org.eclipse.winery.repository.backend.RepositoryFactory;
+import org.eclipse.winery.repository.backend.constants.MediaTypes;
+import org.eclipse.winery.repository.backend.filebased.converter.support.Namespaces;
+import org.eclipse.winery.repository.backend.filebased.converter.support.reader.xml.Reader;
+import org.eclipse.winery.repository.backend.filebased.converter.support.writer.xml.Writer;
+import org.eclipse.winery.repository.datatypes.ids.elements.ArtifactTemplateFilesDirectoryId;
+import org.eclipse.winery.repository.importing.CsarImporter;
+
+import org.apache.tika.mime.MediaType;
+import org.eclipse.jdt.annotation.NonNull;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.w3c.dom.Document;
+
+public class WriterUtils {
+    private static final Logger LOGGER = LoggerFactory.getLogger(WriterUtils.class);
+
+    public static void storeDefinitions(Definitions definitions, boolean overwrite, Path dir) {
+        Path path = null;
+        try {
+            path = Files.createTempDirectory("winery");
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        LOGGER.debug("Store definition: {}", definitions.getId());
+        saveDefinitions(definitions, path, definitions.getTargetNamespace(), definitions.getId());
+        Definitions cleanDefinitions = loadDefinitions(path, definitions.getTargetNamespace(), definitions.getId());
+
+        CsarImporter csarImporter = new CsarImporter();
+        List<Exception> exceptions = new ArrayList<>();
+        cleanDefinitions.getServiceTemplateOrNodeTypeOrNodeTypeImplementation().forEach(entry -> {
+            String namespace = csarImporter.getNamespace(entry, definitions.getTargetNamespace());
+            csarImporter.setNamespace(entry, namespace);
+
+            String id = ModelUtilities.getId(entry);
+
+            Class<? extends DefinitionsChildId> widClazz = Util.getComponentIdClassForTExtensibleElements(entry.getClass());
+            final DefinitionsChildId wid = BackendUtils.getDefinitionsChildId(widClazz, namespace, id, false);
+
+            if (RepositoryFactory.getRepository().exists(wid)) {
+                if (overwrite) {
+                    try {
+                        RepositoryFactory.getRepository().forceDelete(wid);
+                    } catch (IOException e) {
+                        exceptions.add(e);
+                    }
+                } else {
+                    return;
+                }
+            }
+
+            if (entry instanceof TArtifactTemplate) {
+                TArtifactTemplate.ArtifactReferences artifactReferences = ((TArtifactTemplate) entry).getArtifactReferences();
+                Stream.of(artifactReferences)
+                    .filter(Objects::nonNull)
+                    .flatMap(ref -> ref.getArtifactReference().stream())
+                    .filter(Objects::nonNull)
+                    .forEach(ref -> {
+                        String reference = ref.getReference();
+                        URI refURI;
+                        try {
+                            refURI = new URI(reference);
+                        } catch (URISyntaxException e) {
+                            LOGGER.error("Invalid URI {}", reference);
+                            return;
+                        }
+                        if (refURI.isAbsolute()) {
+                            return;
+                        }
+                        Path artifactPath = dir.resolve(reference);
+                        if (!Files.exists(artifactPath)) {
+                            LOGGER.error("File not found {}", artifactPath);
+                            return;
+                        }
+                        ArtifactTemplateFilesDirectoryId aDir = new ArtifactTemplateFilesDirectoryId((ArtifactTemplateId) wid);
+                        RepositoryFileReference aFile = new RepositoryFileReference(aDir, artifactPath.getFileName().toString());
+                        MediaType mediaType = null;
+                        try (InputStream is = Files.newInputStream(artifactPath);
+                             BufferedInputStream bis = new BufferedInputStream(is)) {
+                            mediaType = BackendUtils.getMimeType(bis, artifactPath.getFileName().toString());
+                            RepositoryFactory.getRepository().putContentToFile(aFile, bis, mediaType);
+                        } catch (IOException e) {
+                            LOGGER.error("Could not read artifact template file: {}", artifactPath);
+                            return;
+                        }
+                    });
+            }
+
+            final Definitions part = BackendUtils.createWrapperDefinitions(wid);
+            part.getServiceTemplateOrNodeTypeOrNodeTypeImplementation().add(entry);
+
+            RepositoryFileReference ref = BackendUtils.getRefOfDefinitions(wid);
+            String content = BackendUtils.getXMLAsString(part, true);
+            try {
+                RepositoryFactory.getRepository().putContentToFile(ref, content, MediaTypes.MEDIATYPE_TOSCA_DEFINITIONS);
+            } catch (Exception e) {
+                exceptions.add(e);
+            }
+        });
+    }
+
+    public static void storeTypes(Path path, String name, String namespace, String id) {
+        WriterUtils.storeTypes(getTypeFile(path, namespace, name).getParent(), namespace, id);
+    }
+
+    public static void storeTypes(Path path, String namespace, String id) {
+        LOGGER.debug("Store type: {}", id);
+        try {
+            MediaType mediaType = MediaTypes.MEDIATYPE_XSD;
+
+            TImport.Builder builder = new TImport.Builder(Namespaces.XML_NS);
+            builder.setNamespace(namespace);
+            builder.setLocation(id + ".xsd");
+
+            GenericImportId rid = new XSDImportId(namespace, id, false);
+            TDefinitions definitions = BackendUtils.createWrapperDefinitions(rid);
+            definitions.getImport().add(builder.build());
+            CsarImporter.storeDefinitions(rid, definitions);
+
+            RepositoryFileReference ref = BackendUtils.getRefOfDefinitions(rid);
+
+            List<File> files = Files.list(path).filter(Files::isRegularFile)
+                .map(Path::toFile).collect(Collectors.toList());
+            for (File file : files) {
+                BufferedInputStream stream = new BufferedInputStream(new FileInputStream(file));
+                RepositoryFileReference fileRef = new RepositoryFileReference(ref.getParent(), file.getName());
+                RepositoryFactory.getRepository().putContentToFile(fileRef, stream, mediaType);
+            }
+        } catch (IllegalArgumentException | IOException e) {
+            throw new IllegalStateException(e);
+        }
+    }
+
+    public static void saveDefinitions(Definitions definitions, Path path, String namespace, String name) {
+        saveDefinitions(definitions, getDefinitionsPath(path, namespace, name));
+    }
+
+    public static void saveDefinitions(Definitions definitions, Path filePath) {
+        Writer writer = new Writer();
+        try {
+            writer.writeXML(definitions, filePath);
+        } catch (JAXBException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static Definitions loadDefinitions(Path path, String namespace, String name) {
+        Path filePath = getDefinitionsPath(path, namespace, name);
+        Reader reader = new Reader();
+        try {
+            return reader.parse(new FileInputStream(filePath.toFile()));
+        } catch (JAXBException | FileNotFoundException e) {
+            e.printStackTrace();
+        }
+        return new Definitions();
+    }
+
+    public static void saveType(Document document, Path path, String namespace, String name) {
+        WriterUtils.saveType(document, getTypeFile(path, namespace, name));
+    }
+
+    public static void saveType(Document document, Path filePath) {
+        DOMSource source = new DOMSource(document);
+        try {
+            Files.createDirectories(filePath.getParent());
+            FileWriter writer = new FileWriter(filePath.toFile());
+            StreamResult result = new StreamResult(writer);
+
+            TransformerFactory transformerFactory = TransformerFactory.newInstance();
+            Transformer transformer = transformerFactory.newTransformer();
+            transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "4");
+            transformer.setOutputProperty(OutputKeys.INDENT, "yes");
+            transformer.transform(source, result);
+            writer.flush();
+            writer.close();
+        } catch (TransformerException | IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    /**
+     * @param path      The root path to search from
+     * @param namespace the namespace
+     * @param name      the local name of the file
+     */
+    private static Path getTypeFile(@NonNull Path path, @NonNull String namespace, @NonNull String name) {
+        String urlEncodedName = Util.URLencode(name);
+        return path.resolve(urlEncodedName)
+            .resolve(Util.URLencode(namespace))
+            .resolve("types")
+            .resolve(urlEncodedName.concat(".xsd"));
+    }
+
+    private static Path getDefinitionsPath(Path path, String namespace, @NonNull String name) {
+        return path.resolve(Util.URLencode(namespace))
+            .resolve(name.concat(".tosca"));
+    }
+
+    public static String getDefinitionsLocation(String namespace, @NonNull String name) {
+        return Util.URLencode(namespace) + File.separator
+            + Util.URLencode(name) + ".tosca";
+    }
+}
+    
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/writer/xml/Writer.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/writer/xml/Writer.java
new file mode 100644
index 000000000..b426b92d5
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/writer/xml/Writer.java
@@ -0,0 +1,49 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.writer.xml;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBException;
+import javax.xml.bind.Marshaller;
+
+import org.eclipse.winery.model.tosca.TDefinitions;
+import org.eclipse.winery.repository.backend.filebased.converter.support.writer.xml.support.AnonymousPropertiesList;
+import org.eclipse.winery.repository.backend.filebased.converter.support.writer.xml.support.PropertiesList;
+
+import com.sun.xml.bind.marshaller.NamespacePrefixMapper;
+
+public class Writer {
+    public void writeXML(TDefinitions definitions, Path filePath) throws JAXBException {
+        JAXBContext context = JAXBContext.newInstance(TDefinitions.class, PropertiesList.class, AnonymousPropertiesList.class);
+
+        Marshaller marshaller = context.createMarshaller();
+        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
+        marshaller.setProperty("com.sun.xml.bind.namespacePrefixMapper", new NamespacePrefixMapper() {
+            @Override
+            public String getPreferredPrefix(String s, String s1, boolean b) {
+                return "tosca";
+            }
+        });
+        try {
+            Files.createDirectories(filePath.getParent());
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        marshaller.marshal(definitions, filePath.toFile());
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/writer/xml/support/AnonymousPropertiesList.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/writer/xml/support/AnonymousPropertiesList.java
new file mode 100644
index 000000000..3f47df88c
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/writer/xml/support/AnonymousPropertiesList.java
@@ -0,0 +1,39 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.writer.xml.support;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.xml.bind.JAXBElement;
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlAnyElement;
+import javax.xml.bind.annotation.XmlType;
+
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name = "")
+public class AnonymousPropertiesList {
+    @XmlAnyElement
+    private List<JAXBElement> entries = new ArrayList<>();
+
+    public List<JAXBElement> getEntries() {
+        return entries;
+    }
+
+    public AnonymousPropertiesList setEntries(List<JAXBElement> entries) {
+        this.entries = entries;
+        return this;
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/writer/xml/support/PropertiesList.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/writer/xml/support/PropertiesList.java
new file mode 100644
index 000000000..7deafbfa1
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/writer/xml/support/PropertiesList.java
@@ -0,0 +1,49 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.writer.xml.support;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.xml.bind.JAXBElement;
+import javax.xml.bind.annotation.XmlAnyElement;
+import javax.xml.bind.annotation.XmlAttribute;
+import javax.xml.bind.annotation.XmlRootElement;
+
+@XmlRootElement(name = "Properties")
+public class PropertiesList {
+    private List<JAXBElement> entries = new ArrayList<>();
+
+    private String namespace;
+
+    @XmlAnyElement
+    public List<JAXBElement> getEntries() {
+        return entries;
+    }
+
+    public PropertiesList setEntries(List<JAXBElement> entries) {
+        this.entries = entries;
+        return this;
+    }
+
+    @XmlAttribute(name = "xmlns")
+    public String getNamespace() {
+        return namespace;
+    }
+
+    public PropertiesList setNamespace(String namespace) {
+        this.namespace = namespace;
+        return this;
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/writer/yaml/Writer.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/writer/yaml/Writer.java
new file mode 100644
index 000000000..382767d27
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/writer/yaml/Writer.java
@@ -0,0 +1,613 @@
+/********************************************************************************
+ * Copyright (c) 2017-2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.writer.yaml;
+
+import java.io.ByteArrayInputStream;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.stream.Collectors;
+
+import org.eclipse.winery.model.tosca.yaml.TArtifactDefinition;
+import org.eclipse.winery.model.tosca.yaml.TArtifactType;
+import org.eclipse.winery.model.tosca.yaml.TAttributeAssignment;
+import org.eclipse.winery.model.tosca.yaml.TAttributeDefinition;
+import org.eclipse.winery.model.tosca.yaml.TCapabilityAssignment;
+import org.eclipse.winery.model.tosca.yaml.TCapabilityDefinition;
+import org.eclipse.winery.model.tosca.yaml.TCapabilityType;
+import org.eclipse.winery.model.tosca.yaml.TConstraintClause;
+import org.eclipse.winery.model.tosca.yaml.TDataType;
+import org.eclipse.winery.model.tosca.yaml.TEntityType;
+import org.eclipse.winery.model.tosca.yaml.TEntrySchema;
+import org.eclipse.winery.model.tosca.yaml.TGroupDefinition;
+import org.eclipse.winery.model.tosca.yaml.TGroupType;
+import org.eclipse.winery.model.tosca.yaml.TImplementation;
+import org.eclipse.winery.model.tosca.yaml.TImportDefinition;
+import org.eclipse.winery.model.tosca.yaml.TInterfaceAssignment;
+import org.eclipse.winery.model.tosca.yaml.TInterfaceDefinition;
+import org.eclipse.winery.model.tosca.yaml.TInterfaceType;
+import org.eclipse.winery.model.tosca.yaml.TNodeFilterDefinition;
+import org.eclipse.winery.model.tosca.yaml.TNodeTemplate;
+import org.eclipse.winery.model.tosca.yaml.TNodeType;
+import org.eclipse.winery.model.tosca.yaml.TOperationDefinition;
+import org.eclipse.winery.model.tosca.yaml.TParameterDefinition;
+import org.eclipse.winery.model.tosca.yaml.TPolicyDefinition;
+import org.eclipse.winery.model.tosca.yaml.TPolicyType;
+import org.eclipse.winery.model.tosca.yaml.TPropertyAssignment;
+import org.eclipse.winery.model.tosca.yaml.TPropertyDefinition;
+import org.eclipse.winery.model.tosca.yaml.TPropertyFilterDefinition;
+import org.eclipse.winery.model.tosca.yaml.TRelationshipAssignment;
+import org.eclipse.winery.model.tosca.yaml.TRelationshipDefinition;
+import org.eclipse.winery.model.tosca.yaml.TRelationshipTemplate;
+import org.eclipse.winery.model.tosca.yaml.TRelationshipType;
+import org.eclipse.winery.model.tosca.yaml.TRepositoryDefinition;
+import org.eclipse.winery.model.tosca.yaml.TRequirementAssignment;
+import org.eclipse.winery.model.tosca.yaml.TRequirementDefinition;
+import org.eclipse.winery.model.tosca.yaml.TServiceTemplate;
+import org.eclipse.winery.model.tosca.yaml.TSubstitutionMappings;
+import org.eclipse.winery.model.tosca.yaml.TTopologyTemplateDefinition;
+import org.eclipse.winery.model.tosca.yaml.TVersion;
+import org.eclipse.winery.model.tosca.yaml.support.Metadata;
+import org.eclipse.winery.model.tosca.yaml.support.TListString;
+import org.eclipse.winery.model.tosca.yaml.support.TMapImportDefinition;
+import org.eclipse.winery.model.tosca.yaml.support.TMapObject;
+import org.eclipse.winery.model.tosca.yaml.support.TMapPropertyFilterDefinition;
+import org.eclipse.winery.model.tosca.yaml.support.TMapRequirementAssignment;
+import org.eclipse.winery.model.tosca.yaml.support.TMapRequirementDefinition;
+import org.eclipse.winery.model.tosca.yaml.tosca.datatypes.Credential;
+import org.eclipse.winery.model.tosca.yaml.visitor.AbstractParameter;
+import org.eclipse.winery.model.tosca.yaml.visitor.AbstractVisitor;
+import org.eclipse.winery.model.tosca.yaml.visitor.VisitorNode;
+import org.eclipse.winery.repository.backend.filebased.converter.support.Namespaces;
+import org.eclipse.winery.repository.backend.filebased.converter.support.writer.yaml.support.Printer;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class Writer extends AbstractVisitor<Printer, Writer.Parameter> {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractVisitor.class);
+
+    private final int INDENT_SIZE;
+
+    public Writer() {
+        this.INDENT_SIZE = 2;
+    }
+
+    public Writer(int indentSize) {
+        this.INDENT_SIZE = indentSize;
+    }
+
+    public InputStream writeToInputStream(TServiceTemplate serviceTemplate) {
+        try {
+            String output = this.visit(serviceTemplate, new Parameter(0)).toString();
+            return new ByteArrayInputStream(output.getBytes());
+        } catch (Exception e) {
+            return null;
+        }
+    }
+
+    public void write(TServiceTemplate serviceTemplate, Path fileName) {
+        Objects.requireNonNull(serviceTemplate);
+        try {
+            Files.createDirectories(Objects.requireNonNull(fileName).getParent());
+        } catch (IOException e) {
+            LOGGER.debug("Could not create directory", e);
+            return;
+        }
+        try (FileWriter fileWriter = new FileWriter(fileName.toFile())) {
+            fileWriter.write(this.visit(serviceTemplate, new Parameter(0)).toString());
+        } catch (IOException e) {
+            LOGGER.debug("Could write to file", e);
+        }
+    }
+
+    /**
+     * @deprecated Use {@link Writer#write(TServiceTemplate, Path)}
+     */
+    @Deprecated
+    public void write(TServiceTemplate serviceTemplate, String fileName) {
+        this.write(serviceTemplate, Paths.get(fileName));
+    }
+
+    public Printer visit(TServiceTemplate node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyValue("tosca_definitions_version", node.getToscaDefinitionsVersion())
+            .printNewLine()
+            .print(node.getMetadata().accept(this, parameter))
+            .print(printListMap("imports",
+                node.getImports().stream().map(TMapImportDefinition::getMap).collect(Collectors.toList()),
+                parameter))
+            .printKeyValue("description", node.getDescription())
+            .print(printMapObject("dsl_definitions", node.getDslDefinitions(), parameter))
+            .print(printMap("repositories", node.getRepositories(), parameter))
+            .print(printMap("artifact_types", node.getArtifactTypes(), parameter))
+            .print(printMap("data_types", node.getDataTypes(), parameter))
+            .print(printMap("capability_types", node.getCapabilityTypes(), parameter))
+            .print(printMap("interface_types", node.getInterfaceTypes(), parameter))
+            .print(printMap("relationship_types", node.getRelationshipTypes(), parameter))
+            .print(printMap("node_types", node.getNodeTypes(), parameter))
+            .print(printMap("group_types", node.getGroupTypes(), parameter))
+            .print(printMap("policy_types", node.getPolicyTypes(), parameter))
+            .print(printVisitorNode(node.getTopologyTemplate(), new Parameter(parameter.getIndent()).addContext("topology_template")));
+    }
+
+    public Printer visit(TTopologyTemplateDefinition node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyValue("description", node.getDescription())
+            .print(printMap("inputs", node.getInputs(), parameter))
+            .print(printMap("node_templates", node.getNodeTemplates(), parameter))
+            .print(printMap("relationship_templates", node.getRelationshipTemplates(), parameter))
+            .print(printMap("groups", node.getGroups(), parameter))
+            .print(printMap("policies", node.getPolicies(), parameter))
+            .print(printMap("outputs", node.getOutputs(), parameter))
+            .print(printVisitorNode(node.getSubstitutionMappings(), new Parameter(parameter.getIndent()).addContext("substitution_mappings")));
+    }
+
+    public Printer visit(Metadata node, Parameter parameter) {
+        Printer printer = new Printer(parameter.getIndent());
+        if (!node.isEmpty()) {
+            printer.printKey("metadata")
+                .indent(INDENT_SIZE);
+            node.forEach(printer::printKeyValue);
+            printer.indent(-INDENT_SIZE);
+        }
+        return printer;
+    }
+
+    public Printer visit(TRepositoryDefinition node, Parameter parameter) {
+        Printer printer = new Printer(parameter.getIndent())
+            .printKeyValue("description", node.getDescription())
+            .printKeyValue("url", node.getUrl());
+        if (Objects.nonNull(node.getCredential())) {
+            Credential credential = node.getCredential();
+            printer.printKey("credential")
+                .indent(INDENT_SIZE)
+                .printKeyValue("protocol", credential.getProtocol())
+                .printKeyValue("token_type", credential.getTokenType())
+                .printKeyValue("token", credential.getToken())
+                .printKeyObject("keys", credential.getKeys())
+                .printKeyValue("user", credential.getUser())
+                .indent(-INDENT_SIZE);
+        }
+        return printer;
+    }
+
+    public Printer visit(TImportDefinition node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyValue("file", node.getFile())
+            .printKeyValue("repository", node.getRepository())
+            .printKeyValue("namespace_uri", node.getNamespaceUri(), !node.getNamespaceUri().equals(Namespaces.DEFAULT_NS))
+            .printKeyValue("namespace_prefix", node.getNamespacePrefix());
+    }
+
+    public Printer visit(TArtifactType node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyValue("mime_type", node.getMimeType())
+            .printKeyValue("file_ext", node.getFileExt());
+    }
+
+    public Printer visit(TEntityType node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyValue("description", node.getDescription())
+            .printKeyValue("version", node.getVersion())
+            .printKeyValue("derived_from", node.getDerivedFrom())
+            .print(printMap("properties", node.getProperties(), parameter))
+            .print(printMap("attributes", node.getAttributes(), parameter))
+            .print(node.getMetadata().accept(this, parameter));
+    }
+
+    public Printer visit(TPropertyDefinition node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyValue("type", node.getType())
+            .printKeyValue("description", node.getDescription())
+            .printKeyValue("required", node.getRequired())
+            .printKeyObject("default", node.getDefault())
+            .printKeyValue("status", node.getStatus())
+            .print(printList("constraints", node.getConstraints(), parameter))
+            .print(printVisitorNode(node.getEntrySchema(), parameter));
+    }
+
+    public Printer visit(TConstraintClause node, Parameter parameter) {
+        return new Printer(parameter.getIndent()).printKeyObject("- equal", node.getEqual())
+            .printKeyObject("- greater_than", node.getGreaterThan())
+            .printKeyObject("- greater_or_equal", node.getGreaterOrEqual())
+            .printKeyObject("- less_than", node.getLessThan())
+            .printKeyObject("- less_or_equal", node.getLessOrEqual())
+            .printKeyListObjectInline("- in_range", node.getInRange())
+            .printKeyListObjectInline("- valid_values", node.getValidValues())
+            .printKeyObject("- length", node.getLength())
+            .printKeyObject("- min_length", node.getMinLength())
+            .printKeyObject("- max_length", node.getMaxLength())
+            .printKeyObject("- pattern", node.getPattern());
+    }
+
+    public Printer visit(TEntrySchema node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyValue("type", node.getType())
+            .printKeyValue("description", node.getDescription())
+            .print(printList("constraints", node.getConstraints(), parameter));
+    }
+
+    public Printer visit(TAttributeDefinition node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyValue("description", node.getDescription())
+            .printKeyValue("type", node.getType())
+            .printKeyObject("default", node.getDefault())
+            .printKeyValue("status", node.getStatus())
+            .print(printVisitorNode(node.getEntrySchema(), parameter.addContext("entry_schema")));
+    }
+
+    public Printer visit(TDataType node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .print(printList("constraints", node.getConstraints(), parameter));
+    }
+
+    public Printer visit(TCapabilityType node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyValue("valid_source_types", node.getValidSourceTypes());
+    }
+
+    public Printer visit(TInterfaceType node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .print(node.getOperations().entrySet().stream()
+                .map(entry ->
+                    printVisitorNode(entry.getValue(), new Parameter(parameter.getIndent()).addContext(entry.getKey()))
+                )
+                .reduce(Printer::print)
+            )
+            .print(printMap("inputs", node.getInputs(), parameter));
+    }
+
+    public Printer visit(TOperationDefinition node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyValue("description", node.getDescription())
+            .print(printMap("inputs", node.getInputs(), new Parameter(parameter.getIndent())))
+            .print(printMap("outputs", node.getOutputs(), new Parameter(parameter.getIndent())))
+            .print(printVisitorNode(node.getImplementation(), new Parameter(parameter.getIndent()).addContext("implementation")));
+    }
+
+    public Printer visit(TImplementation node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyValue("primary", node.getPrimary())
+            .printKeyValue("dependencies", node.getDependencies());
+    }
+
+    public Printer visit(TRelationshipType node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyValue("valid_target_types", node.getValidTargetTypes())
+            .print(printMap("interfaces", node.getInterfaces(), parameter));
+    }
+
+    public Printer visit(TInterfaceDefinition node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyValue("type", node.getType())
+            .print(printMap("inputs", node.getInputs(), parameter))
+            .print(node.getOperations().entrySet().stream()
+                .filter(entry -> Objects.nonNull(entry) && Objects.nonNull(entry.getValue()))
+                .map(entry ->
+                    printVisitorNode(entry.getValue(), new Parameter(parameter.getIndent()).addContext(entry.getKey()))
+                )
+                .reduce(Printer::print)
+            );
+    }
+
+    public Printer visit(TNodeType node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .print(printListMap("requirements", node.getRequirements().stream().map(TMapRequirementDefinition::getMap).collect(Collectors.toList()), parameter))
+            .print(printMap("capabilities", node.getCapabilities(), parameter))
+            .print(printMap("interfaces", node.getInterfaces(), parameter))
+            .print(printMap("artifacts", node.getArtifacts(), parameter));
+    }
+
+    public Printer visit(TRequirementDefinition node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyValue("capability", node.getCapability())
+            .printKeyValue("node", node.getNode())
+            .print(printVisitorNode(node.getRelationship(), new Parameter(parameter.getIndent()).addContext("relationship")))
+            .printKeyValue("occurrences", node.getOccurrences())
+            .printKeyValue("description", node.getDescription());
+    }
+
+    public Printer visit(TRelationshipDefinition node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyValue("type", node.getType())
+            .print(printMap("interfaces", node.getInterfaces(), parameter));
+    }
+
+    public Printer visit(TCapabilityDefinition node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyValue("description", node.getDescription())
+            .printKeyValue("occurrences", node.getOccurrences())
+            .printKeyValue("valid_source_types", node.getValidSourceTypes())
+            .printKeyValue("type", node.getType())
+            .print(printMap("properties", node.getProperties(), parameter))
+            .print(printMap("attributes", node.getAttributes(), parameter));
+    }
+
+    public Printer visit(TArtifactDefinition node, Parameter parameter) {
+        Printer output = new Printer(parameter.getIndent())
+            .printKeyValue("type", node.getType())
+            .printKeyValue("repository", node.getRepository())
+            .printKeyValue("description", node.getDescription())
+            .printKeyValue("deploy_path", node.getDeployPath());
+        if (node.getFiles() != null) {
+            if (!node.getFiles().isEmpty()) {
+                output.printKeyValue("file", node.getFile())
+                    .printKeyValue("files", node.getFiles());
+            }
+        }
+        return output;
+    }
+
+    public Printer visit(TGroupType node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyValue("members", node.getMembers())
+            .print(printListMap("requirements", node.getRequirements().stream().map(TMapRequirementDefinition::getMap).collect(Collectors.toList()), parameter))
+            .print(printMap("capabilities", node.getCapabilities(), parameter))
+            .print(printMap("interfaces", node.getInterfaces(), parameter));
+    }
+
+    public Printer visit(TPolicyType node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyValue("targets", node.getTargets())
+            .printKeyObject("triggers", node.getTriggers());
+    }
+
+    public Printer visit(TVersion node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .print(node.getVersion());
+    }
+
+    public Printer visit(TNodeTemplate node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyValue("type", node.getType())
+            .printKeyValue("description", node.getDescription())
+            .print(node.getMetadata().accept(this, parameter))
+            .printKeyValue("directives", node.getDirectives())
+            .print(printMap("properties", node.getProperties(), parameter))
+            .print(printMap("attributes", node.getAttributes(), parameter))
+            .print(printListMap("requirements", node.getRequirements().stream().map(TMapRequirementAssignment::getMap).collect(Collectors.toList()), parameter))
+            .print(printMap("capabilities", node.getCapabilities(), parameter))
+            .print(printMap("interfaces", node.getInterfaces(), parameter))
+            .print(printMap("artifacts", node.getArtifacts(), parameter))
+            .print(printVisitorNode(node.getNodeFilter(), parameter))
+            .printKeyValue("copy", node.getCopy());
+    }
+
+    public Printer visit(TGroupDefinition node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyValue("type", node.getType())
+            .printKeyValue("description", node.getDescription())
+            .print(node.getMetadata().accept(this, parameter))
+            .print(printMap("properties", node.getProperties(), parameter))
+            .printKeyValue("members", node.getMembers())
+            .print(printMap("interfaces", node.getInterfaces(), parameter));
+    }
+
+    public Printer visit(TPolicyDefinition node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyValue("type", node.getType())
+            .printKeyValue("description", node.getDescription())
+            .print(node.getMetadata().accept(this, parameter))
+            .print(printMap("properties", node.getProperties(), parameter))
+            .printKeyValue("targets", node.getTargets());
+    }
+
+    public Printer visit(TPropertyAssignment node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyObject(parameter.getKey(), node.getValue());
+    }
+
+    public Printer visit(TAttributeAssignment node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyValue("description", node.getDescription())
+            .printKeyObject("value", node.getValue());
+    }
+
+    public Printer visit(TInterfaceAssignment node, Parameter parameter) {
+        return new Printer(parameter.getIndent());
+    }
+
+    public Printer visit(TParameterDefinition node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyValue("type", node.getType())
+            .printKeyValue("description", node.getDescription())
+            .printKeyValue("required", node.getRequired())
+            .printKeyObject("default", node.getDefault())
+            .printKeyValue("status", node.getStatus())
+            .print(printList("constraints", node.getConstraints(), parameter))
+            .print(printVisitorNode(node.getEntrySchema(), parameter))
+            .printKeyObject(parameter.getKey(), node.getValue());
+    }
+
+    public Printer visit(TCapabilityAssignment node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .print(printMap("properties", node.getProperties(), parameter))
+            .print(printMap("attributes", node.getAttributes(), parameter));
+    }
+
+    public Printer visit(TNodeFilterDefinition node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .print(printListMap("properties",
+                node.getProperties().stream().map(TMapPropertyFilterDefinition::getMap).collect(Collectors.toList()),
+                parameter)
+            )
+            .print(printListMap("capabilities",
+                node.getCapabilities().stream().map(TMapObject::getMap).collect(Collectors.toList()),
+                parameter)
+            );
+    }
+
+    public Printer visit(TRelationshipTemplate node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyValue("type", node.getType())
+            .printKeyValue("description", node.getDescription())
+            .print(node.getMetadata().accept(this, parameter))
+            .print(printMap("properties", node.getProperties(), parameter))
+            .print(printMap("attributes", node.getAttributes(), parameter))
+            .print(printMap("interfaces", node.getInterfaces(), parameter))
+            .printKeyValue("copy", node.getCopy());
+    }
+
+    public Printer visit(TSubstitutionMappings node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyValue("node_type", node.getNodeType())
+            .print(printMapInlineStringList("capabilities", node.getCapabilities(), parameter));
+    }
+
+    public Printer visit(TRequirementAssignment node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyValue("node", node.getNode())
+            .print(printVisitorNode(node.getRelationship(), new Parameter(parameter.getIndent()).addContext("relationship")))
+            .printKeyValue("capability", node.getCapability())
+            .print(printVisitorNode(node.getNodeFilter(), new Parameter(parameter.getIndent()).addContext("node_filter")))
+            .printKeyValue("occurrences", node.getOccurrences());
+    }
+
+    public Printer visit(TRelationshipAssignment node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .printKeyValue("type", node.getType())
+            .print(printMap("properties", node.getProperties(), parameter))
+            .print(printMap("interfaces", node.getInterfaces(), parameter));
+    }
+
+    public Printer visit(TPropertyFilterDefinition node, Parameter parameter) {
+        return new Printer(parameter.getIndent())
+            .print(printList("constraints", node.getConstraints(), parameter));
+    }
+
+    public Printer printVisitorNode(VisitorNode node, Parameter parameter) {
+        Printer printer = new Printer(parameter.getIndent());
+        if (Objects.nonNull(node)) {
+            if (node instanceof TPropertyAssignment) {
+                printer.print(node.accept(this,
+                    new Parameter(parameter.getIndent()).addContext(parameter.getKey())
+                ));
+            } else {
+                printer.printKey(parameter.getKey())
+                    .print(node.accept(this, new Parameter(parameter.getIndent() + INDENT_SIZE)));
+            }
+        }
+        return printer;
+    }
+
+    private <T> Printer printList(String keyValue, List<T> list, Parameter parameter) {
+        Printer printer = new Printer(parameter.getIndent());
+        if (!list.isEmpty()) {
+            printer.printKey(keyValue)
+                .print(list.stream()
+                    .map(entry -> ((VisitorNode) entry).accept(this, new Parameter(parameter.getIndent() + INDENT_SIZE)))
+                    .reduce(Printer::print)
+                );
+        }
+        return printer;
+    }
+
+    private <T> Printer printMap(String keyValue, Map<String, T> map, Parameter parameter) {
+        Printer printer = new Printer(parameter.getIndent());
+        if (!map.isEmpty()) {
+            printer.printKey(keyValue)
+                .print(map.entrySet().stream()
+                    .filter(entry -> entry.getValue() instanceof VisitorNode)
+                    .map((entry) -> {
+                            Printer p = new Printer(parameter.getIndent() + INDENT_SIZE)
+                                .print(
+                                    printVisitorNode((VisitorNode) entry.getValue(),
+                                        new Parameter(parameter.getIndent() + INDENT_SIZE).addContext(entry.getKey())
+                                    )
+                                );
+                            return p;
+                        }
+                    )
+                    .reduce(Printer::print)
+                );
+        }
+        return printer;
+    }
+
+    private <T> Printer printListMap(String keyValue, List<Map<String, T>> list, Parameter parameter) {
+        Printer printer = new Printer(parameter.getIndent());
+        if (!list.isEmpty()) {
+            printer.printKey(keyValue)
+                .print(list.stream()
+                    .flatMap(map -> map.entrySet().stream())
+                    .map(
+                        (entry) -> new Printer(parameter.getIndent() + INDENT_SIZE)
+                            .printListKey(entry.getKey())
+                            .print(((VisitorNode) entry.getValue())
+                                .accept(this,
+                                    new Parameter(parameter.getIndent() + 3 * INDENT_SIZE).addContext(entry.getKey())
+                                ))
+                    )
+                    .reduce(Printer::print)
+                );
+        }
+        return printer;
+    }
+
+    private Printer printMapInlineStringList(String keyValue, Map<String, TListString> map, Parameter parameter) {
+        Printer printer = new Printer(parameter.getIndent());
+        if (!map.isEmpty()) {
+            printer.printKey(keyValue)
+                .print(map.entrySet().stream()
+                    .map(entry -> new Printer(parameter.getIndent() + 2)
+                        .printKeyValue(entry.getKey(), entry.getValue())
+                    )
+                    .reduce(Printer::print)
+                );
+        }
+        return printer;
+    }
+
+    private Printer printMapObject(String keyValue, Map<String, ? extends Object> map, Parameter parameter) {
+        Printer printer = new Printer(parameter.getIndent());
+        if (!map.isEmpty()) {
+            printer.printCheckNewLine()
+                .printKey(keyValue)
+                .indent(INDENT_SIZE);
+            map.forEach(printer::printKeyObject);
+            printer.indent(-INDENT_SIZE);
+        }
+        return printer;
+    }
+
+    public static class Parameter extends AbstractParameter<Parameter> {
+        private final int indent;
+
+        public Parameter(int indent) {
+            this.indent = indent;
+        }
+
+        public int getIndent() {
+            return this.indent;
+        }
+
+        @Override
+        public Parameter copy() {
+            return new Parameter(this.indent).addContext(this.getContext());
+        }
+
+        @Override
+        public Parameter self() {
+            return this;
+        }
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/writer/yaml/support/Printer.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/writer/yaml/support/Printer.java
new file mode 100644
index 000000000..e596e1247
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/writer/yaml/support/Printer.java
@@ -0,0 +1,331 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.writer.yaml.support;
+
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.stream.Collectors;
+
+import javax.xml.namespace.QName;
+
+import org.eclipse.winery.model.tosca.yaml.TStatusValue;
+import org.eclipse.winery.model.tosca.yaml.TVersion;
+import org.eclipse.winery.model.tosca.yaml.visitor.AbstractResult;
+
+public class Printer extends AbstractResult<Printer> {
+
+    private StringBuilder stringBuilder;
+    private int indent;
+
+    public Printer(int indent) {
+        this(new StringBuilder(), indent);
+    }
+
+    public Printer(StringBuilder stringBuilder, int indent) {
+        this.stringBuilder = stringBuilder;
+        this.indent = 0;
+        this.indent(indent);
+    }
+
+    @Override
+    public Printer add(Printer printer) {
+        this.print(printer);
+        return this;
+    }
+
+    public boolean isEmpty() {
+
+        return stringBuilder.length() == 0 || stringBuilder.length() == indent;
+    }
+
+    /**
+     * Increases or decreases the indent
+     */
+    public Printer indent(int delta) {
+        this.indent += delta;
+        if (delta < 0) {
+            for (int i = -1; i >= delta; i--) {
+                if (stringBuilder.length() + delta < 0 || stringBuilder.charAt(stringBuilder.length() + i) != ' ') {
+                    return this;
+                }
+            }
+            stringBuilder.setLength(stringBuilder.length() + delta);
+        } else {
+            for (int i = 0; i < delta; i++) {
+                print(' ');
+            }
+        }
+        return this;
+    }
+
+    public Printer print(String value) {
+        this.stringBuilder.append(value);
+        return this;
+    }
+
+    public Printer print(char value) {
+        this.stringBuilder.append(value);
+        return this;
+    }
+
+    public Printer print(Printer printer) {
+        if (Objects.isNull(printer) || printer.isEmpty()) return this;
+        if (endsWithNewLine()) {
+            int cut = 0;
+            for (int i = stringBuilder.length() - 1; i >= 0; i--) {
+                if (stringBuilder.charAt(i) != '\n') {
+                    cut--;
+                } else {
+                    break;
+                }
+            }
+            stringBuilder.setLength(stringBuilder.length() + cut);
+        } else if (stringBuilder.length() == indent) {
+            stringBuilder.setLength(0);
+        } else if (stringBuilder.length() > 0) {
+            print('\n');
+        }
+        if (printer.indent > this.indent && printer.endsWithNewLine()) {
+            printer.stringBuilder.setLength(printer.stringBuilder.length() + this.indent - printer.indent);
+        }
+
+        print(printer.toString());
+        return this;
+    }
+
+    public Printer print(Optional<Printer> printer) {
+        printer.ifPresent(this::print);
+        return this;
+    }
+
+    public Printer printKeyValue(String key, String value) {
+        if (Objects.isNull(value) || value.isEmpty()) return this;
+        if (value.contains("\n")) {
+            return print(key)
+                .print(": >")
+                .printNewLine()
+                .indent(2)
+                .print(value.trim().replaceAll("\n", "\n\n" + getIndentString()))
+                .indent(-2)
+                .printCheckNewLine();
+        }
+        return print(key)
+            .print(": ")
+            .print(value)
+            .printNewLine();
+    }
+
+    public Printer printKeyValue(String key, TVersion value) {
+        if (Objects.isNull(value)) return this;
+        return printKeyValue(key, value.getVersion());
+    }
+
+    public Printer printKeyValue(String key, TStatusValue value) {
+        if (Objects.isNull(value)) return this;
+        return printKeyValue(key, value.name());
+    }
+
+    public Printer printKeyValue(String key, Boolean value) {
+        if (Objects.isNull(value)) return this;
+        return print(key)
+            .print(':')
+            .print(' ')
+            .print(value.toString())
+            .printNewLine();
+    }
+
+    public Printer printKeyValue(String key, String value, boolean print) {
+        if (print) {
+            printKeyValue(key, value);
+        }
+        return this;
+    }
+
+    public Printer printKeyValue(String key, List<? extends Object> value) {
+        if (Objects.isNull(value) || value.isEmpty()) return this;
+        return print(key)
+            .print(':')
+            .print(' ')
+            .print('[')
+            .print(' ')
+            .print(value.stream()
+                .map((object) -> {
+                    if (object instanceof QName) {
+                        return qNameToString((QName) object);
+                    } else {
+                        return object.toString();
+                    }
+                })
+                .collect(Collectors.joining(", ")))
+            .print(' ')
+            .print(']')
+            .printNewLine();
+    }
+
+    public Printer printKeyValue(String key, QName value) {
+        if (Objects.isNull(value) || value.getLocalPart().isEmpty()) return this;
+        return printKeyValue(key, qNameToString(value));
+    }
+
+    public Printer printKey(String key) {
+        return print(key)
+            .print(":")
+            .printNewLine();
+    }
+
+    public Printer printListKey(String key) {
+        return print('-')
+            .print(' ')
+            .printKey(key);
+    }
+
+    public Printer printKeyObject(String key, Object object) {
+        if (Objects.isNull(object)) return this;
+        if (object instanceof String) {
+            printKeyValue(key, (String) object);
+        } else if (object instanceof Map) {
+            if (key.isEmpty()) {
+                print("{")
+                    .printNewLine()
+                    .indent(2);
+            } else {
+                printKey(key)
+                    .indent(2);
+            }
+            Map<String, Object> map = (Map<String, Object>) object;
+            for (Map.Entry<String, Object> entry : map.entrySet()) {
+                printKeyObject(entry.getKey(), entry.getValue());
+            }
+            indent(-2);
+            if (key.isEmpty()) {
+                printCheckNewLine()
+                    .print('}');
+            }
+        } else if (object instanceof List && !((List) object).isEmpty()) {
+            printKey(key)
+                .indent(2);
+            for (Object entry : (List<Object>) object) {
+                printListObject(entry);
+            }
+            indent(-2)
+                .printNewLine();
+        } else {
+            printKeyValue(key, object.toString());
+        }
+        return this;
+    }
+
+    public Printer printListObject(Object object) {
+        if (object instanceof String) {
+            String value = (String) object;
+            if (value.contains("\n")) {
+                return print('-')
+                    .print(' ')
+                    .print('>')
+                    .printNewLine()
+                    .indent(2)
+                    .print(value.replaceAll("\n", "\n" + getIndentString()))
+                    .indent(-2)
+                    .printNewLine();
+            }
+            return print('-')
+                .print(' ')
+                .print(value)
+                .printNewLine();
+        } else if (object instanceof Map) {
+            print('-')
+                .print(' ');
+            this.indent += 2;
+            Map<String, Object> map = (Map<String, Object>) object;
+            for (Map.Entry<String, Object> entry : map.entrySet()) {
+                printKeyObject(entry.getKey(), entry.getValue());
+            }
+            indent(-2)
+                .printNewLine();
+        }
+        return this;
+    }
+
+    public Printer printKeyListObjectInline(String key, List<Object> list) {
+        if (Objects.isNull(list) || list.isEmpty()) return this;
+        print(key)
+            .print(':')
+            .print(' ')
+            .print('[')
+            .print(' ')
+            .print(list.stream().map(Object::toString).collect(Collectors.joining(",")))
+            .print(' ')
+            .print(']')
+            .printNewLine();
+        return this;
+    }
+
+    public Printer printNewLine() {
+        if (stringBuilder.length() > 0) {
+            this.print('\n');
+            for (int i = 0; i < indent; i++) {
+                this.print(' ');
+            }
+        }
+        return this;
+    }
+
+    public Printer printCheckNewLine() {
+        if (!endsWithNewLine()) {
+            this.printNewLine();
+        }
+        return this;
+    }
+
+    private Boolean endsWithNewLine() {
+        for (int i = stringBuilder.length() - 1; i >= 0; i--) {
+            if (stringBuilder.charAt(i) != ' ') {
+                return stringBuilder.charAt(i) == '\n';
+            }
+        }
+        return false;
+    }
+
+    private String qNameToString(QName name) {
+        // when processing property types - only use the local part
+        if (!name.getPrefix().isEmpty() && (
+            name.getPrefix().equals("yaml") || name.getPrefix().equals("tosca"))
+            || name.getNamespaceURI().isEmpty()) {
+            return name.getLocalPart();
+        }
+
+        // TODO decide on namespace handling w.r.t. Simple Profile spec
+        // current solution: use dotted notation for namespaces as in RADON particles
+        return name.getNamespaceURI() + "." + name.getLocalPart();
+    }
+
+    private String getIndentString() {
+        StringBuilder stringBuilder = new StringBuilder();
+        for (int i = 0; i < indent; i++) {
+            stringBuilder.append(' ');
+        }
+        return stringBuilder.toString();
+    }
+
+    public String toString() {
+        return stringBuilder.toString();
+    }
+
+    public Printer clear() {
+        stringBuilder.setLength(0);
+        return this;
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/xml/TypeConverter.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/xml/TypeConverter.java
new file mode 100644
index 000000000..2ef70086f
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/xml/TypeConverter.java
@@ -0,0 +1,67 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.xml;
+
+import java.util.Optional;
+
+import javax.xml.namespace.QName;
+
+import org.eclipse.winery.repository.backend.filebased.converter.support.Namespaces;
+
+public class TypeConverter {
+    public static TypeConverter INSTANCE = new TypeConverter();
+
+    public QName convert(QName type) {
+        if (type.getNamespaceURI().equals(Namespaces.XML_NS)) {
+            switch (type.getLocalPart()) {
+                case "string":
+                    return new QName(Namespaces.YAML_NS, "string", "yaml");
+                case "decimal":
+                case "float":
+                    return new QName(Namespaces.YAML_NS, "float", "yaml");
+                case "boolean":
+                    return new QName(Namespaces.YAML_NS, "boolean", "yaml");
+                case "date":
+                    return new QName(Namespaces.YAML_NS, "timestamp", "yaml");
+                default:
+                    return type;
+            }
+        }
+        return type;
+    }
+
+    public QName convert(String type) {
+        switch (Optional.ofNullable(type).orElse("").toLowerCase()) {
+            case "xsd:string":
+            case "xs:string":
+            case "xsd:anyuri":
+            case "xs:anyuri":
+                return convert(new QName(Namespaces.XML_NS, "string", "xsd"));
+            case "xsd:decimal":
+            case "xs:decimal":
+                return convert(new QName(Namespaces.XML_NS, "decimal", "xsd"));
+            case "xsd:boolean":
+            case "xs:boolean":
+                return convert(new QName(Namespaces.XML_NS, "boolean", "xsd"));
+            case "xsd:date":
+            case "xs:date":
+                return convert(new QName(Namespaces.XML_NS, "date", "xsd"));
+            case "xsd:float":
+            case "xs:float":
+                return convert(new QName(Namespaces.XML_NS, "float", "xsd"));
+            default:
+                return new QName(type);
+        }
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/yaml/AssignmentBuilder.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/yaml/AssignmentBuilder.java
new file mode 100644
index 000000000..b67a2b16b
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/yaml/AssignmentBuilder.java
@@ -0,0 +1,100 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.yaml;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+
+import javax.xml.bind.JAXBElement;
+import javax.xml.namespace.QName;
+
+import org.eclipse.winery.model.tosca.yaml.TPropertyAssignment;
+import org.eclipse.winery.repository.backend.filebased.converter.support.Namespaces;
+import org.eclipse.winery.repository.backend.filebased.converter.support.writer.xml.support.AnonymousPropertiesList;
+import org.eclipse.winery.repository.backend.filebased.converter.support.writer.xml.support.PropertiesList;
+
+public class AssignmentBuilder {
+    private TypeConverter typeConverter;
+    private Map<QName, Map<String, QName>> propertyAssignmentBuildPlan;
+
+    public AssignmentBuilder(Map<QName, Map<String, QName>> buildPlan) {
+        this.propertyAssignmentBuildPlan = buildPlan;
+        reset();
+    }
+
+    public void reset() {
+        this.typeConverter = new TypeConverter();
+    }
+
+    public PropertiesList getAssignment(Map<String, TPropertyAssignment> assignmentMap, QName type) {
+        Map<String, Object> assignments = assignmentMap.entrySet().stream()
+            .filter(e -> e.getValue() != null)
+            .collect(Collectors.toMap(
+                Map.Entry::getKey, e -> e.getValue().getValue())
+            );
+
+        List<JAXBElement> elements = convertAssignment(assignments, propertyAssignmentBuildPlan.get(type));
+        return new PropertiesList().setEntries(elements).setNamespace(type.getNamespaceURI());
+    }
+
+    private List<JAXBElement> convertAssignment(Map<String, Object> yamlAssignment, Map<String, QName> buildPlan) {
+        List<JAXBElement> result = new ArrayList<>();
+        for (Map.Entry<String, Object> entry : yamlAssignment.entrySet()) {
+            if (entry.getValue() == null) {
+                continue;
+            }
+
+            QName assignmentType = buildPlan.get(entry.getKey());
+            // Add primitive yaml types as JAXBElements with their java class
+            if (assignmentType.getNamespaceURI().equals(Namespaces.YAML_NS)) {
+                Class assignmentClass = typeConverter.convertToJavaType(assignmentType);
+                // Handle TOSCA YAML functions (example: {get_input: DockerEngineURL})
+                if (assignmentClass == String.class && !(entry.getValue() instanceof String)) {
+                    String value = entry.getValue().toString();
+                    // Filter for function else use Object.toString()
+                    if (entry.getValue() instanceof Map && ((Map) entry.getValue()).size() == 1) {
+                        for (Map.Entry<String, Object> fentry : ((Map<String, Object>) entry.getValue()).entrySet())
+                            value = fentry.getKey() + ": " + fentry.getValue().toString();
+                    }
+
+                    @SuppressWarnings("unchecked")
+                    JAXBElement element = new JAXBElement(new QName(entry.getKey()), assignmentClass, value);
+                    result.add(element);
+                } else {
+                    @SuppressWarnings("unchecked")
+                    JAXBElement element = new JAXBElement(new QName(entry.getKey()), assignmentClass, entry.getValue());
+                    result.add(element);
+                }
+            }
+            // Add complex (data_types) as AnonymousPropertyLists
+            else if (entry.getValue() instanceof Map) {
+                @SuppressWarnings( {"unchecked"})
+                Map<String, Object> tmp = (Map<String, Object>) entry.getValue();
+                List<JAXBElement> elements = convertAssignment(tmp, this.propertyAssignmentBuildPlan.get(assignmentType));
+                AnonymousPropertiesList list = new AnonymousPropertiesList().setEntries(elements);
+                @SuppressWarnings("unchecked")
+                JAXBElement element = new JAXBElement(new QName(entry.getKey()), AnonymousPropertiesList.class, list);
+                result.add(element);
+            } else if (entry.getValue() instanceof List) {
+                // TODO check what types are possible for assignments and how to convert them
+                assert false;
+            } else {
+                assert false;
+            }
+        }
+        return result;
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/yaml/ReferenceVisitor.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/yaml/ReferenceVisitor.java
new file mode 100644
index 000000000..40fbaa4af
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/yaml/ReferenceVisitor.java
@@ -0,0 +1,165 @@
+/********************************************************************************
+ * Copyright (c) 2017-2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.yaml;
+
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
+import javax.xml.namespace.QName;
+
+import org.eclipse.winery.model.tosca.yaml.TArtifactType;
+import org.eclipse.winery.model.tosca.yaml.TEntityType;
+import org.eclipse.winery.model.tosca.yaml.TImportDefinition;
+import org.eclipse.winery.model.tosca.yaml.TServiceTemplate;
+import org.eclipse.winery.model.tosca.yaml.support.TMapImportDefinition;
+import org.eclipse.winery.model.tosca.yaml.visitor.AbstractParameter;
+import org.eclipse.winery.model.tosca.yaml.visitor.AbstractResult;
+import org.eclipse.winery.repository.backend.filebased.converter.support.Namespaces;
+import org.eclipse.winery.repository.backend.filebased.converter.support.exception.MultiException;
+import org.eclipse.winery.repository.backend.filebased.converter.support.reader.yaml.Reader;
+import org.eclipse.winery.repository.backend.filebased.converter.support.validator.support.ExceptionVisitor;
+
+public class ReferenceVisitor extends ExceptionVisitor<ReferenceVisitor.Result, ReferenceVisitor.Parameter> {
+    private final TServiceTemplate serviceTemplate;
+    private final String namespace;
+    private final Reader reader;
+    private final Path path;
+
+    private Map<TImportDefinition, ReferenceVisitor> visitors;
+    private Map<TImportDefinition, TServiceTemplate> serviceTemplates;
+
+    public ReferenceVisitor(TServiceTemplate serviceTemplate, String namespace, Path path) {
+        this.serviceTemplate = serviceTemplate;
+        this.namespace = namespace;
+        this.reader = new Reader();
+        this.path = path;
+        this.visitors = new LinkedHashMap<>();
+        this.serviceTemplates = new LinkedHashMap<>();
+    }
+
+    public Result getTypes(QName reference, String entityClassName) {
+        return visit(serviceTemplate, new Parameter(reference, entityClassName));
+    }
+
+    @Override
+    public Result visit(TImportDefinition node, Parameter parameter) {
+        if (node.getNamespaceUri() == null && !parameter.reference.getNamespaceURI().equals(Namespaces.DEFAULT_NS)) {
+            return null;
+        }
+
+        String namespace = node.getNamespaceUri() == null ? Namespaces.DEFAULT_NS : node.getNamespaceUri();
+        if (!this.visitors.containsKey(node)) {
+            try {
+                this.serviceTemplates.put(node, reader.readImportDefinition(node, path, namespace));
+            } catch (MultiException e) {
+                setException(e);
+            }
+            this.visitors.put(node, new ReferenceVisitor(this.serviceTemplates.get(node), namespace, path));
+        }
+
+        return this.visitors.get(node).visit(this.serviceTemplates.get(node), parameter);
+    }
+
+    @Override
+    public Result visit(TEntityType node, Parameter parameter) {
+        if (node.getDerivedFrom() != null) {
+            return serviceTemplate.accept(this, new Parameter(node.getDerivedFrom(), parameter.entityClass)).copy(node, node.getDerivedFrom());
+        }
+        return new Result(node);
+    }
+
+    @Override
+    public Result visit(TServiceTemplate node, Parameter parameter) {
+        Result result;
+        if (parameter.reference.getNamespaceURI().equals(this.namespace)
+            && "TArtifactType".equals(parameter.entityClass)
+            && node.getArtifactTypes().containsKey(parameter.reference.getLocalPart())) {
+            return node.getArtifactTypes().get(parameter.reference.getLocalPart()).accept(this, parameter.copy());
+        }
+
+        for (TMapImportDefinition map : node.getImports()) {
+            for (Map.Entry<String, TImportDefinition> entry : map.entrySet()) {
+                result = entry.getValue().accept(this, parameter);
+                if (result != null) {
+                    return result;
+                }
+            }
+        }
+
+        return null;
+    }
+
+    @Override
+    public Result visit(TArtifactType node, Parameter parameter) {
+        return null;
+    }
+
+    public static class Result extends AbstractResult<Result> {
+        private List<Object> objects;
+        private List<QName> names;
+
+        public Result(Object object) {
+            this.objects = new ArrayList<>();
+            this.names = new ArrayList<>();
+            if (object != null) {
+                this.objects.add(object);
+            }
+        }
+
+        public List<Object> getObjects() {
+            return objects;
+        }
+
+        public List<QName> getNames() {
+            return names;
+        }
+
+        public Result copy(Object object, QName name) {
+            this.objects.add(object);
+            this.names.add(name);
+            return this;
+        }
+
+        @Override
+        public Result add(Result result) {
+            // No collecting (deep search)
+            return this;
+        }
+    }
+
+    public static class Parameter extends AbstractParameter<Parameter> {
+        private final QName reference;
+        private final String entityClass;
+
+        public Parameter(QName reference, String entityName) {
+            this.reference = reference;
+            this.entityClass = entityName;
+        }
+
+        @Override
+        public Parameter copy() {
+            Parameter parameter = new Parameter(this.reference, this.entityClass);
+            parameter.getContext().addAll(this.getContext());
+            return parameter;
+        }
+
+        @Override
+        public Parameter self() {
+            return this;
+        }
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/yaml/TypeConverter.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/yaml/TypeConverter.java
new file mode 100644
index 000000000..54b3f94ad
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/yaml/TypeConverter.java
@@ -0,0 +1,63 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.yaml;
+
+import javax.xml.namespace.QName;
+
+import org.eclipse.winery.repository.backend.filebased.converter.support.Namespaces;
+
+public class TypeConverter {
+    public static TypeConverter INSTANCE = new TypeConverter();
+
+    public QName convert(QName type) {
+        if (type.getNamespaceURI().equals(Namespaces.YAML_NS)) {
+            switch (type.getLocalPart()) {
+                case "string":
+                    return new QName(Namespaces.XML_NS, "string", "xsd");
+                case "integer":
+                case "float":
+                    return new QName(Namespaces.XML_NS, "decimal", "xsd");
+                case "boolean":
+                    return new QName(Namespaces.XML_NS, "boolean", "xsd");
+                case "timestamp":
+                    return new QName(Namespaces.XML_NS, "date", "xsd");
+                case "null":
+                    return new QName(Namespaces.XML_NS, "string", "xsd");
+                default:
+                    return type;
+            }
+        }
+        return type;
+    }
+
+    public Class convertToJavaType(QName type) {
+        if (type.getNamespaceURI().equals(Namespaces.YAML_NS)) {
+            switch (type.getLocalPart()) {
+                case "integer":
+                    return Integer.class;
+                case "float":
+                    return Float.class;
+                case "boolean":
+                    return Boolean.class;
+                case "timestamp":
+                case "null":
+                case "string":
+                default:
+                    return String.class;
+            }
+        } else {
+            return Object.class;
+        }
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/yaml/extension/TImplementationArtifactDefinition.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/yaml/extension/TImplementationArtifactDefinition.java
new file mode 100644
index 000000000..8a97cf09e
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/converter/support/yaml/extension/TImplementationArtifactDefinition.java
@@ -0,0 +1,78 @@
+/********************************************************************************
+ * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package org.eclipse.winery.repository.backend.filebased.converter.support.yaml.extension;
+
+import java.util.List;
+
+import javax.xml.namespace.QName;
+
+import org.eclipse.winery.model.tosca.yaml.TArtifactDefinition;
+
+public class TImplementationArtifactDefinition extends TArtifactDefinition {
+    private String interfaceName;
+    private String operationName;
+
+    public TImplementationArtifactDefinition() {
+
+    }
+
+    public TImplementationArtifactDefinition(Builder builder) {
+        super(builder);
+        this.interfaceName = builder.interfaceName;
+        this.operationName = builder.operationName;
+    }
+
+    public String getInterfaceName() {
+        return interfaceName;
+    }
+
+    public void setInterfaceName(String interfaceName) {
+        this.interfaceName = interfaceName;
+    }
+
+    public String getOperationName() {
+        return operationName;
+    }
+
+    public void setOperationName(String operationName) {
+        this.operationName = operationName;
+    }
+
+    public static class Builder extends TArtifactDefinition.Builder {
+        private String interfaceName;
+        private String operationName;
+
+        public Builder(QName type, List<String> files) {
+            super(type, files);
+        }
+
+        public Builder(TArtifactDefinition artifactDefinition) {
+            super(artifactDefinition);
+        }
+
+        public Builder setInterfaceName(String interfaceName) {
+            this.interfaceName = interfaceName;
+            return this;
+        }
+
+        public Builder setOperationName(String operationName) {
+            this.operationName = operationName;
+            return this;
+        }
+
+        public TImplementationArtifactDefinition build() {
+            return new TImplementationArtifactDefinition(this);
+        }
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/management/AbstractGitResolver.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/management/AbstractGitResolver.java
index 22cc93ea5..8c8a2d10f 100644
--- a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/management/AbstractGitResolver.java
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/management/AbstractGitResolver.java
@@ -20,6 +20,7 @@
 
 import org.eclipse.winery.common.configuration.FileBasedRepositoryConfiguration;
 import org.eclipse.winery.common.configuration.GitBasedRepositoryConfiguration;
+import org.eclipse.winery.repository.backend.RepositoryFactory;
 import org.eclipse.winery.repository.backend.filebased.GitBasedRepository;
 
 import org.eclipse.jgit.api.errors.GitAPIException;
@@ -58,7 +59,8 @@ public String getUrl() {
 
     @Override
     public GitBasedRepository createRepository(File repositoryLocation) throws IOException, GitAPIException {
-        GitBasedRepositoryConfiguration configuration = new GitBasedRepositoryConfiguration(false, repositoryUrl, repositoryBranch, new FileBasedRepositoryConfiguration(Paths.get(repositoryLocation.toString())));
-        return new GitBasedRepository(configuration);
+        FileBasedRepositoryConfiguration compositeConfiguration = new FileBasedRepositoryConfiguration(Paths.get(repositoryLocation.toString()));
+        GitBasedRepositoryConfiguration configuration = new GitBasedRepositoryConfiguration(false, repositoryUrl, repositoryBranch, compositeConfiguration);
+        return new GitBasedRepository(configuration, RepositoryFactory.createXmlOrYamlRepository(compositeConfiguration));
     }
 }
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/management/GitResolver.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/management/GitResolver.java
index 8f3009bbd..5d9adff10 100644
--- a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/management/GitResolver.java
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/management/GitResolver.java
@@ -46,5 +46,4 @@ public String getRepositoryName() {
             return fullRepositoryName.split("." + getVcsSystem())[0];
         }
     }
-
 }
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/management/IRepositoryResolver.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/management/IRepositoryResolver.java
index 19a5893f0..d6aafd364 100644
--- a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/management/IRepositoryResolver.java
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/management/IRepositoryResolver.java
@@ -34,5 +34,4 @@
     String getRepositoryName();
 
     FilebasedRepository createRepository(File repositoryLocation) throws IOException, GitAPIException;
-
 }
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/model/ConvertedPath.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/model/ConvertedPath.java
new file mode 100644
index 000000000..ef6dd062a
--- /dev/null
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/backend/filebased/model/ConvertedPath.java
@@ -0,0 +1,33 @@
+package org.eclipse.winery.repository.backend.filebased.model;
+
+import java.nio.file.Path;
+
+public class ConvertedPath {
+
+    private Path originalPath;
+    private Path convertedPath;
+
+    public ConvertedPath(Path originalPath, Path convertedPath) {
+        this.originalPath = originalPath;
+        this.convertedPath = convertedPath;
+    }
+
+    public ConvertedPath() {
+    }
+
+    public Path getOriginalPath() {
+        return originalPath;
+    }
+
+    public void setOriginalPath(Path originalPath) {
+        this.originalPath = originalPath;
+    }
+
+    public Path getConvertedPath() {
+        return convertedPath;
+    }
+
+    public void setConvertedPath(Path convertedPath) {
+        this.convertedPath = convertedPath;
+    }
+}
diff --git a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/export/ExportedState.java b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/export/ExportedState.java
index ca0f5d12d..44ba7591c 100644
--- a/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/export/ExportedState.java
+++ b/org.eclipse.winery.repository/src/main/java/org/eclipse/winery/repository/export/ExportedState.java
@@ -13,31 +13,30 @@
  *******************************************************************************/
 package org.eclipse.winery.repository.export;
 
-import org.eclipse.winery.common.ids.definitions.DefinitionsChildId;
-
 import java.util.ArrayDeque;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Queue;
 
+import org.eclipse.winery.common.ids.definitions.DefinitionsChildId;
+
 /**
  * Holds the state of ids regarding the export.
  * <p>
- * Required as we do not know at the entry point (usually a service template),
- * which other components are linked.
+ * Required as we do not know at the entry point (usually a service template), which other components are linked.
  * <p>
- * Users can call flagAsExportRequired more than once for the same id. If an id
- * is already exported, it is not flagged as exported again.
+ * Users can call flagAsExportRequired more than once for the same id. If an id is already exported, it is not flagged
+ * as exported again.
  */
 public class ExportedState {
 
     private final Collection<DefinitionsChildId> exported = new HashSet<>();
     private final Queue<DefinitionsChildId> exportRequired = new ArrayDeque<>();
 
-
     /**
-     * @return the first definition child id to be exported, null if no more
-     * elements are in the queue
+     * Get the first definition child id to be exported, null if no more elements are in the queue.
+     *
+     * @return DefinitionsChildId
      */
     public DefinitionsChildId pop() {
         return this.exportRequired.poll();
diff --git a/org.eclipse.winery.repository/src/test/java/org/eclipse/winery/repository/backend/consistencycheck/ConsistencyCheckerTest.java b/org.eclipse.winery.repository/src/test/java/org/eclipse/winery/repository/backend/consistencycheck/ConsistencyCheckerTest.java
index bc483ee6d..1a7fc484c 100644
--- a/org.eclipse.winery.repository/src/test/java/org/eclipse/winery/repository/backend/consistencycheck/ConsistencyCheckerTest.java
+++ b/org.eclipse.winery.repository/src/test/java/org/eclipse/winery/repository/backend/consistencycheck/ConsistencyCheckerTest.java
@@ -90,7 +90,6 @@ public void openToscaNamespaceIsNotLowerCaseErrorNotRaisedAtQNameHavingCasedLoca
         ConsistencyErrorCollector errorLogger = new ConsistencyErrorCollector();
         consistencyChecker.checkNamespaceUri(id);
         assertEquals(Collections.emptyMap(), errorLogger.getErrorList());
-
     }
 
     public ConsistencyErrorCollector checkRevisionWithoutDocumentation(String revision) throws Exception {
@@ -100,7 +99,7 @@ public ConsistencyErrorCollector checkRevisionWithoutDocumentation(String revisi
             (false, false, verbosity, repository, true);
         final ConsistencyChecker consistencyChecker = new ConsistencyChecker(configuration);
         consistencyChecker.checkCorruption();
-        return  consistencyChecker.getErrorCollector();
+        return consistencyChecker.getErrorCollector();
     }
 
     @ParameterizedTest
@@ -176,18 +175,9 @@ public void noErrors(String revision) throws Exception {
         Map<QName, ElementErrorList> expected = new HashMap<>();
         ElementErrorList elementErrorList;
 
-        elementErrorList = new ElementErrorList("ArtifactType");
-        elementErrorList.addError("java.lang.UnsupportedOperationException");
-        expected.put(new QName("http://winery.opentosca.org/test/ponyuniverse", "WesternEquipment_Pony"), elementErrorList);
-
-        elementErrorList = new ElementErrorList("ArtifactType");
-        elementErrorList.addError("java.lang.UnsupportedOperationException");
-        expected.put(new QName("http://winery.opentosca.org/test/ponyuniverse", "DressageEquipment_Unicorn"), elementErrorList);
-
         elementErrorList = new ElementErrorList("ArtifactTemplate");
         elementErrorList.addError("Namespace URI contains tosca definitions name from other type. E.g., Namespace is ...servicetemplates..., but the type is an artifact template");
         elementErrorList.addError("Properties required, but no properties defined");
-        elementErrorList.addError("java.lang.UnsupportedOperationException");
         expected.put(new QName("http://winery.opentosca.org/test/servicetemplates/ponyuniverse/daspecifier", "DressageEquipment_Unicorn"), elementErrorList);
 
         elementErrorList = new ElementErrorList("ServiceTemplate");
@@ -217,14 +207,12 @@ public void noErrors(String revision) throws Exception {
 
         elementErrorList = new ElementErrorList("ArtifactTemplate");
         elementErrorList.addError("Namespace URI contains tosca definitions name from other type. E.g., Namespace is ...servicetemplates..., but the type is an artifact template");
-        elementErrorList.addError("java.lang.UnsupportedOperationException");
         expected.put(new QName("http://winery.opentosca.org/test/servicetemplates/ponyuniverse/daspecifier", "WesternEquipment_Pony"), elementErrorList);
 
         elementErrorList = new ElementErrorList("ServiceTemplate");
         elementErrorList.addError("propertiesKV of node template shetland_pony is null");
         elementErrorList.addError("propertiesKV of node template ponycompetition is null");
         elementErrorList.addError("propertiesKV of node template ponycompetition_2 is null");
-        elementErrorList.addError("java.lang.UnsupportedOperationException");
         expected.put(new QName("http://winery.opentosca.org/test/servicetemplates/ponyuniverse/daspecifier", "DASpecificationTest"), elementErrorList);
 
         elementErrorList = new ElementErrorList("ServiceTemplate");
@@ -256,7 +244,6 @@ public void noErrors(String revision) throws Exception {
         elementErrorList = new ElementErrorList("ArtifactTemplate");
         elementErrorList.addError("Namespace URI contains tosca definitions name from other type. E.g., Namespace is ...servicetemplates..., but the type is an artifact template");
         elementErrorList.addError("Properties required, but no properties defined");
-        elementErrorList.addError("java.lang.UnsupportedOperationException");
         expected.put(new QName("http://winery.opentosca.org/test/servicetemplates/ponyuniverse/daspecifier", "WesternEquipment_Unicorn"), elementErrorList);
 
         elementErrorList = new ElementErrorList("ServiceTemplate");
@@ -270,10 +257,6 @@ public void noErrors(String revision) throws Exception {
             "Fatal Error: cvc-complex-type.2.4.b: The content of element 'DeploymentArtifacts' is not complete. One of '{\"http://docs.oasis-open.org/tosca/ns/2011/12\":DeploymentArtifact}' is expected.\n");
         expected.put(new QName("http://www.opentosca.org/providers/FieldProvider", "FieldProvider"), elementErrorList);
 
-        elementErrorList = new ElementErrorList("ServiceTemplate");
-        elementErrorList.addError("java.lang.UnsupportedOperationException");
-        expected.put(new QName("http://www.opentosca.org/providers/EquipmentProvider", "EquipmentProvider"), elementErrorList);
-
         elementErrorList = new ElementErrorList("ServiceTemplate");
         elementErrorList.addError("Fatal Error: cvc-datatype-valid.1.2.1: '1' is not a valid value for 'NCName'.\n" +
             "Fatal Error: cvc-attribute.3: The value '1' of attribute 'id' on element 'Requirement' is not valid with respect to its type, 'ID'.\n" +
@@ -289,13 +272,8 @@ public void noErrors(String revision) throws Exception {
 
         elementErrorList = new ElementErrorList("ArtifactTemplate");
         elementErrorList.addError("Namespace URI contains tosca definitions name from other type. E.g., Namespace is ...servicetemplates..., but the type is an artifact template");
-        elementErrorList.addError("java.lang.UnsupportedOperationException");
         expected.put(new QName("http://winery.opentosca.org/test/servicetemplates/ponyuniverse/daspecifier", "DressageEquipment_Pony"), elementErrorList);
 
-        elementErrorList = new ElementErrorList("ArtifactType");
-        elementErrorList.addError("java.lang.UnsupportedOperationException");
-        expected.put(new QName("http://winery.opentosca.org/test/ponyuniverse", "DressageEquipment_Pony"), elementErrorList);
-
         elementErrorList = new ElementErrorList("ServiceTemplate");
         elementErrorList.addError("Fatal Error: cvc-datatype-valid.1.2.1: '1' is not a valid value for 'NCName'.\n" +
             "Fatal Error: cvc-attribute.3: The value '1' of attribute 'id' on element 'Requirement' is not valid with respect to its type, 'ID'.\n" +
@@ -361,10 +339,6 @@ public void noErrors(String revision) throws Exception {
             "Fatal Error: cvc-attribute.3: The value '20' of attribute 'id' on element 'Requirement' is not valid with respect to its type, 'ID'.\n");
         expected.put(new QName("http://www.winery.opentosca.org/test/targetallocation/servicetemplates", "MinExternalConnectionsTest2"), elementErrorList);
 
-        elementErrorList = new ElementErrorList("ArtifactType");
-        elementErrorList.addError("java.lang.UnsupportedOperationException");
-        expected.put(new QName("http://winery.opentosca.org/test/ponyuniverse", "WesternEquipment_Unicorn"), elementErrorList);
-
         elementErrorList = new ElementErrorList("ServiceTemplate");
         elementErrorList.addError("propertiesKV of node template straw is null");
         elementErrorList.addError("propertiesKV of node template stall is null");
@@ -426,9 +400,9 @@ public void noErrors(String revision) throws Exception {
     }
 
     /**
-     * If this method fails, reconfigure IntelliJ and rebuild the complete project <br>
-     * Settings | Build, Execution, Deployment | Compiler | [ ] Add runtime assertions for not-null-annotated methods and parameters.
-     * 
+     * If this method fails, reconfigure IntelliJ and rebuild the complete project <br> Settings | Build, Execution,
+     * Deployment | Compiler | [ ] Add runtime assertions for not-null-annotated methods and parameters.
+     *
      * See https://stackoverflow.com/a/40847858/873282 for more information
      */
     @ParameterizedTest
diff --git a/org.eclipse.winery.repository/src/test/java/org/eclipse/winery/repository/backend/filebased/ConverterTest.java b/org.eclipse.winery.repository/src/test/java/org/eclipse/winery/repository/backend/filebased/ConverterTest.java
new file mode 100644
index 000000000..655f9fb38
--- /dev/null
+++ b/org.eclipse.winery.repository/src/test/java/org/eclipse/winery/repository/backend/filebased/ConverterTest.java
@@ -0,0 +1,47 @@
+package org.eclipse.winery.repository.backend.filebased;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.StringWriter;
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBException;
+import javax.xml.bind.Marshaller;
+
+import org.eclipse.winery.model.tosca.TDefinitions;
+import org.eclipse.winery.repository.TestWithGitBackedRepository;
+import org.eclipse.winery.repository.backend.filebased.converter.X2YConverter;
+
+import com.sun.xml.bind.marshaller.NamespacePrefixMapper;
+import org.apache.commons.io.IOUtils;
+import org.junit.jupiter.api.Test;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+public class ConverterTest extends TestWithGitBackedRepository {
+    
+    
+    @Test
+    public void testConvertX2Y() throws Exception {
+        
+//        ClassLoader classLoader = new ConverterTest().getClass().getClassLoader();
+//        InputStream input = classLoader.getResourceAsStream("converter/test.xml");
+//        X2YConverter converter = new X2YConverter(this.repository);
+//        
+//        
+//        InputStream output = converter.convert(input);
+//        
+//        StringWriter outputStringWriter = new StringWriter();
+//        IOUtils.copy(output, outputStringWriter, "UTF-8");
+//        
+//        InputStream expectedInputStream = classLoader.getResourceAsStream("converter/test.yaml");
+//        StringWriter expectedStringWriter = new StringWriter();
+//        IOUtils.copy(expectedInputStream,expectedStringWriter, "UTF-8");
+//
+//        System.out.println(outputStringWriter.toString());
+        
+    }
+    
+    
+}
diff --git a/org.eclipse.winery.repository/src/test/java/org/eclipse/winery/repository/backend/filebased/YamlBasedRepositoryTest.java b/org.eclipse.winery.repository/src/test/java/org/eclipse/winery/repository/backend/filebased/YamlBasedRepositoryTest.java
new file mode 100644
index 000000000..4cfbe0329
--- /dev/null
+++ b/org.eclipse.winery.repository/src/test/java/org/eclipse/winery/repository/backend/filebased/YamlBasedRepositoryTest.java
@@ -0,0 +1,10 @@
+package org.eclipse.winery.repository.backend.filebased;
+
+import org.eclipse.winery.common.ids.definitions.NodeTypeId;
+import org.eclipse.winery.repository.TestWithGitBackedRepository;
+
+import org.junit.jupiter.api.Test;
+
+public class YamlBasedRepositoryTest extends TestWithGitBackedRepository {
+    
+}
diff --git a/org.eclipse.winery.repository/src/test/resources/converter/test.xml b/org.eclipse.winery.repository/src/test/resources/converter/test.xml
new file mode 100644
index 000000000..9c3216a9e
--- /dev/null
+++ b/org.eclipse.winery.repository/src/test/resources/converter/test.xml
@@ -0,0 +1,43 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<Definitions xmlns="http://docs.oasis-open.org/tosca/ns/2011/12"
+             targetNamespace="http://opentosca.org/add/management/to/instances/nodetypes"
+             xmlns:winery="http://www.opentosca.org/winery/extensions/tosca/2013/02/12"
+             id="winery-defs-for_otntyIgeneral2-MySQL-Database_w1">
+    <NodeType name="MySQL-Database_w1"
+              targetNamespace="http://opentosca.org/add/management/to/instances/nodetypes">
+        <winery:PropertiesDefinition elementname="MySQLDBProperties" namespace="http://opentosca.org/nodetypes">
+            <winery:properties>
+                <winery:key>DBName</winery:key>
+                <winery:type>xsd:string</winery:type>
+            </winery:properties>
+            <winery:properties>
+                <winery:key>DBUser</winery:key>
+                <winery:type>xsd:string</winery:type>
+            </winery:properties>
+            <winery:properties>
+                <winery:key>DBPassword</winery:key>
+                <winery:type>xsd:string</winery:type>
+            </winery:properties>
+        </winery:PropertiesDefinition>
+        <Interfaces>
+            <Interface name="http://www.example.com/interfaces/lifecycle">
+                <Operation name="install">
+                    <InputParameters>
+                        <InputParameter name="DBName" type="xsd:string" required="yes"/>
+                        <InputParameter name="DBUser" type="xsd:string" required="yes"/>
+                        <InputParameter name="DBPassword" type="xsd:string" required="yes"/>
+                        <InputParameter name="DBMSUser" type="xsd:string" required="yes"/>
+                        <InputParameter name="DBMSPassword" type="xsd:string" required="yes"/>
+                    </InputParameters>
+                </Operation>
+                <Operation name="configure">
+                    <InputParameters>
+                        <InputParameter name="DBName" type="xsd:string" required="yes"/>
+                        <InputParameter name="DBUser" type="xsd:string" required="yes"/>
+                        <InputParameter name="DBPassword" type="xsd:string" required="yes"/>
+                    </InputParameters>
+                </Operation>
+            </Interface>
+        </Interfaces>
+    </NodeType>
+</Definitions>
diff --git a/org.eclipse.winery.repository/src/test/resources/converter/test.yaml b/org.eclipse.winery.repository/src/test/resources/converter/test.yaml
new file mode 100644
index 000000000..97f217c0a
--- /dev/null
+++ b/org.eclipse.winery.repository/src/test/resources/converter/test.yaml
@@ -0,0 +1,60 @@
+tosca_definitions_version: tosca_simple_yaml_1_1
+
+    imports:
+    - Apache-2.4-Capability.yml:
+    file: CapabilityType/http%3A%2F%2Fopentosca.org%2Fcapabilitytypes/Apache-2.4-Capability.yml
+    namespace_uri: http://opentosca.org/capabilitytypes
+    namespace_prefix: capabilitytypes1
+    - ScriptArtifact.yml:
+    file: ArtifactType/http%3A%2F%2Fdocs.oasis-open.org%2Ftosca%2Fns%2F2011%2F12%2FToscaBaseTypes/ScriptArtifact.yml
+    namespace_uri: http://docs.oasis-open.org/tosca/ns/2011/12/ToscaBaseTypes
+    namespace_prefix: ToscaBaseTypes
+    node_types:
+    Apache-2.4:
+    description: This Node Type and its scripts rely on apt-get and, thus, on the available components in the repository.
+    metadata:
+    targetNamespace: http://opentosca.org/nodetypes
+    abstract: no
+    final: no
+    capabilities:
+    WebServerCap:
+    occurrences: [ 0, unbounded ]
+    type: capabilitytypes1:Apache-2.4-Capability
+    interfaces:
+    http://www.example.com/interfaces/lifecycle:
+    uninstall:
+    implementation:
+    primary: Apache-2.4-ImplementationArtifact-Uninstall
+    stop:
+    implementation:
+    primary: Apache-2.4-ImplementationArtifact-Stop
+    install:
+    implementation:
+    primary: Apache-2.4-ImplementationArtifact-Install
+    start:
+    implementation:
+    primary: Apache-2.4-ImplementationArtifact-Start
+    configure:
+    implementation:
+    primary: Apache-2.4-ImplementationArtifact-Config
+    artifacts:
+    Apache-2.4-ImplementationArtifact-Config:
+    type: ToscaBaseTypes:ScriptArtifact
+    file: ArtifactTemplate/http%3A%2F%2Fopentosca.org%2Fartifacttemplates/Apache-2.4-ArtifactTemplate-Config/config.sh
+    files: [ ArtifactTemplate/http%3A%2F%2Fopentosca.org%2Fartifacttemplates/Apache-2.4-ArtifactTemplate-Config/config.sh ]
+    Apache-2.4-ImplementationArtifact-Install:
+    type: ToscaBaseTypes:ScriptArtifact
+    file: ArtifactTemplate/http%3A%2F%2Fopentosca.org%2Fartifacttemplates/Apache-2.4-ArtifactTemplate-Install/install.sh
+    files: [ ArtifactTemplate/http%3A%2F%2Fopentosca.org%2Fartifacttemplates/Apache-2.4-ArtifactTemplate-Install/install.sh ]
+    Apache-2.4-ImplementationArtifact-Stop:
+    type: ToscaBaseTypes:ScriptArtifact
+    file: ArtifactTemplate/http%3A%2F%2Fopentosca.org%2Fartifacttemplates/Apache-2.4-ArtifactTemplate-Stop/stop.sh
+    files: [ ArtifactTemplate/http%3A%2F%2Fopentosca.org%2Fartifacttemplates/Apache-2.4-ArtifactTemplate-Stop/stop.sh ]
+    Apache-2.4-ImplementationArtifact-Start:
+    type: ToscaBaseTypes:ScriptArtifact
+    file: ArtifactTemplate/http%3A%2F%2Fopentosca.org%2Fartifacttemplates/Apache-2.4-ArtifactTemplate-Start/start.sh
+    files: [ ArtifactTemplate/http%3A%2F%2Fopentosca.org%2Fartifacttemplates/Apache-2.4-ArtifactTemplate-Start/start.sh ]
+    Apache-2.4-ImplementationArtifact-Uninstall:
+    type: ToscaBaseTypes:ScriptArtifact
+    file: ArtifactTemplate/http%3A%2F%2Fopentosca.org%2Fartifacttemplates/Apache-2.4-ArtifactTemplate-Uninstall/remove.sh
+    files: [ ArtifactTemplate/http%3A%2F%2Fopentosca.org%2Fartifacttemplates/Apache-2.4-ArtifactTemplate-Uninstall/remove.sh ]
diff --git a/org.eclipse.winery.tools.deployablecomponents/src/main/java/org/eclipse/winery/tools/deployablecomponents/DeployableComponents.java b/org.eclipse.winery.tools.deployablecomponents/src/main/java/org/eclipse/winery/tools/deployablecomponents/DeployableComponents.java
index 4d9d94a48..1ee68b536 100644
--- a/org.eclipse.winery.tools.deployablecomponents/src/main/java/org/eclipse/winery/tools/deployablecomponents/DeployableComponents.java
+++ b/org.eclipse.winery.tools.deployablecomponents/src/main/java/org/eclipse/winery/tools/deployablecomponents/DeployableComponents.java
@@ -30,6 +30,8 @@
 
 public class DeployableComponents {
 
+    public static final int MAX_FAILED_CRAWLER_REQUESTS = 10;
+
     private final Crawler crawler;
     private final Fileanalyzer analyzer;
 
@@ -37,7 +39,6 @@
 
     private boolean crawlStatus = false;
     private final int CRAWL_AT_ONCE = 1;
-    public static final int MAX_FAILED_CRAWLER_REQUESTS = 10;
 
     public DeployableComponents(CrawlerType type, String serviceName, String serviceToken, String localCopyPath) {
         crawler = new Crawler(type, serviceName, serviceToken, localCopyPath);
diff --git a/org.eclipse.winery.tools.deployablecomponents/src/main/java/org/eclipse/winery/tools/deployablecomponents/commons/Dockerfile.java b/org.eclipse.winery.tools.deployablecomponents/src/main/java/org/eclipse/winery/tools/deployablecomponents/commons/Dockerfile.java
index 7b220830e..156d74ee7 100644
--- a/org.eclipse.winery.tools.deployablecomponents/src/main/java/org/eclipse/winery/tools/deployablecomponents/commons/Dockerfile.java
+++ b/org.eclipse.winery.tools.deployablecomponents/src/main/java/org/eclipse/winery/tools/deployablecomponents/commons/Dockerfile.java
@@ -26,7 +26,6 @@ public Dockerfile(String path, String content, String repoName) {
         this.repoName = repoName;
     }
 
-
     public String getPath() {
         return path;
     }
diff --git a/org.eclipse.winery.tools.deployablecomponents/src/main/java/org/eclipse/winery/tools/deployablecomponents/crawler/Crawler.java b/org.eclipse.winery.tools.deployablecomponents/src/main/java/org/eclipse/winery/tools/deployablecomponents/crawler/Crawler.java
index 24fe9c4ea..0ad156a49 100644
--- a/org.eclipse.winery.tools.deployablecomponents/src/main/java/org/eclipse/winery/tools/deployablecomponents/crawler/Crawler.java
+++ b/org.eclipse.winery.tools.deployablecomponents/src/main/java/org/eclipse/winery/tools/deployablecomponents/crawler/Crawler.java
@@ -14,10 +14,6 @@
 
 package org.eclipse.winery.tools.deployablecomponents.crawler;
 
-import org.eclipse.winery.tools.deployablecomponents.commons.Dockerfile;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import java.io.BufferedWriter;
 import java.io.FileWriter;
 import java.io.IOException;
@@ -25,17 +21,20 @@
 import java.util.List;
 import java.util.concurrent.ConcurrentLinkedDeque;
 
+import org.eclipse.winery.tools.deployablecomponents.commons.Dockerfile;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 public class Crawler {
 
-    private ICrawlerImplementation crawlerInstance;
+    public final static Logger LOGGER = LoggerFactory.getLogger(Crawler.class);
 
+    private ICrawlerImplementation crawlerInstance;
     // contains dockerfile, which are crawled but not yet retrieved
     private final Deque<Dockerfile> crawledDockerfiles = new ConcurrentLinkedDeque<>();
-    
     private final String localCopyPath;
 
-    public final static Logger LOGGER = LoggerFactory.getLogger(Crawler.class);
-
     public Crawler(CrawlerType type, String serviceName, String serviceToken, String localCopyPath) {
         switch (type) {
             case GITHUB:
@@ -58,9 +57,8 @@ public Dockerfile nextDockerfile() {
     }
 
     /**
-     * crawls at least the given number of dockerfiles
-     * one crawling-step (e.g. a repository) is always finished before the number is checked
-     * returns the actual crawled number of dockerfiles
+     * crawls at least the given number of dockerfiles one crawling-step (e.g. a repository) is always finished before
+     * the number is checked returns the actual crawled number of dockerfiles
      *
      * @param number how many dockerfiles should be crawled
      * @return actual number of crawled dockerfiles
diff --git a/org.eclipse.winery.tools.deployablecomponents/src/main/java/org/eclipse/winery/tools/deployablecomponents/crawler/GithubCrawler.java b/org.eclipse.winery.tools.deployablecomponents/src/main/java/org/eclipse/winery/tools/deployablecomponents/crawler/GithubCrawler.java
index 1a4929466..247744309 100644
--- a/org.eclipse.winery.tools.deployablecomponents/src/main/java/org/eclipse/winery/tools/deployablecomponents/crawler/GithubCrawler.java
+++ b/org.eclipse.winery.tools.deployablecomponents/src/main/java/org/eclipse/winery/tools/deployablecomponents/crawler/GithubCrawler.java
@@ -14,13 +14,6 @@
 
 package org.eclipse.winery.tools.deployablecomponents.crawler;
 
-import com.fasterxml.jackson.databind.JsonNode;
-import com.fasterxml.jackson.databind.ObjectMapper;
-import org.eclipse.winery.tools.deployablecomponents.DeployableComponents;
-import org.eclipse.winery.tools.deployablecomponents.commons.Dockerfile;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
@@ -33,8 +26,18 @@
 import java.util.Base64;
 import java.util.List;
 
+import org.eclipse.winery.tools.deployablecomponents.DeployableComponents;
+import org.eclipse.winery.tools.deployablecomponents.commons.Dockerfile;
+
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 public class GithubCrawler implements ICrawlerImplementation {
 
+    public final static Logger LOGGER = LoggerFactory.getLogger(GithubCrawler.class);
+
     private int lastId = 0;
     private URL baseUrl;
     private String authEncoded;
@@ -45,8 +48,6 @@
     private int rateLimitRemainingSearch = 30;
     private Instant rateLimitResetSearch;
 
-    public final static Logger LOGGER = LoggerFactory.getLogger(GithubCrawler.class);
-
     GithubCrawler(String githubName, String oauthToken) {
         try {
             baseUrl = new URL("https://api.github.com/");
@@ -100,7 +101,7 @@ private String HttpGet(URL url, boolean isInRateLimit, boolean isSearch) throws
         StringBuilder responseBuilder;
         HttpURLConnection connection;
         int fails = 0;
-        
+
         // as long as rate limit is not exceeded this do-while is done only once
         do {
             if (fails >= DeployableComponents.MAX_FAILED_CRAWLER_REQUESTS) {
diff --git a/org.eclipse.winery.yaml.converter/pom.xml b/org.eclipse.winery.yaml.converter/pom.xml
index a60716306..9ce01d78d 100644
--- a/org.eclipse.winery.yaml.converter/pom.xml
+++ b/org.eclipse.winery.yaml.converter/pom.xml
@@ -56,6 +56,11 @@
             <artifactId>org.eclipse.winery.common</artifactId>
             <version>2.0.0-SNAPSHOT</version>
         </dependency>
+        <dependency>
+            <groupId>org.eclipse.winery</groupId>
+            <artifactId>org.eclipse.winery.repository</artifactId>
+            <version>2.0.0-SNAPSHOT</version>
+        </dependency>
         <dependency>
             <groupId>org.xmlunit</groupId>
             <artifactId>xmlunit-core</artifactId>
diff --git a/org.eclipse.winery.yaml.converter/src/main/java/org/eclipse/winery/yaml/converter/xml/X2YConverter.java b/org.eclipse.winery.yaml.converter/src/main/java/org/eclipse/winery/yaml/converter/xml/X2YConverter.java
index 46d577d2a..613789a6d 100644
--- a/org.eclipse.winery.yaml.converter/src/main/java/org/eclipse/winery/yaml/converter/xml/X2YConverter.java
+++ b/org.eclipse.winery.yaml.converter/src/main/java/org/eclipse/winery/yaml/converter/xml/X2YConverter.java
@@ -376,7 +376,9 @@ public TTopologyTemplateDefinition convert(TTopologyTemplate node, TBoundaryDefi
         if (Objects.isNull(node)) return new LinkedHashMap<>();
         return Collections.singletonMap(
             node.getName(),
+            // convert the regular stuff
             convert(node, new TCapabilityType.Builder(), org.eclipse.winery.model.tosca.TCapabilityType.class)
+                .addValidSourceTypes(node.getValidNodeTypes())
                 .build()
         );
     }
diff --git a/org.eclipse.winery.yaml.converter/src/main/java/org/eclipse/winery/yaml/converter/yaml/Y2XConverter.java b/org.eclipse.winery.yaml.converter/src/main/java/org/eclipse/winery/yaml/converter/yaml/Y2XConverter.java
index 3b16f740e..ddd52649a 100644
--- a/org.eclipse.winery.yaml.converter/src/main/java/org/eclipse/winery/yaml/converter/yaml/Y2XConverter.java
+++ b/org.eclipse.winery.yaml.converter/src/main/java/org/eclipse/winery/yaml/converter/yaml/Y2XConverter.java
@@ -1,5 +1,5 @@
 /********************************************************************************
- * Copyright (c) 2017 Contributors to the Eclipse Foundation
+ * Copyright (c) 2017-2019 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -14,22 +14,65 @@
 
 package org.eclipse.winery.yaml.converter.yaml;
 
-import org.eclipse.jdt.annotation.NonNull;
-import org.eclipse.jdt.annotation.Nullable;
+import java.io.File;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import javax.xml.namespace.QName;
+
 import org.eclipse.winery.common.Util;
-import org.eclipse.winery.model.tosca.*;
+import org.eclipse.winery.model.tosca.Definitions;
+import org.eclipse.winery.model.tosca.TAppliesTo;
+import org.eclipse.winery.model.tosca.TArtifactReference;
+import org.eclipse.winery.model.tosca.TArtifactTemplate;
 import org.eclipse.winery.model.tosca.TArtifactType;
+import org.eclipse.winery.model.tosca.TBoundaryDefinitions;
 import org.eclipse.winery.model.tosca.TCapabilityDefinition;
 import org.eclipse.winery.model.tosca.TCapabilityType;
+import org.eclipse.winery.model.tosca.TDeploymentArtifact;
+import org.eclipse.winery.model.tosca.TDeploymentArtifacts;
+import org.eclipse.winery.model.tosca.TEntityTemplate;
 import org.eclipse.winery.model.tosca.TEntityType;
+import org.eclipse.winery.model.tosca.TImplementationArtifacts;
+import org.eclipse.winery.model.tosca.TImport;
+import org.eclipse.winery.model.tosca.TInterface;
 import org.eclipse.winery.model.tosca.TNodeTemplate;
 import org.eclipse.winery.model.tosca.TNodeType;
+import org.eclipse.winery.model.tosca.TNodeTypeImplementation;
+import org.eclipse.winery.model.tosca.TOperation;
+import org.eclipse.winery.model.tosca.TParameter;
+import org.eclipse.winery.model.tosca.TPolicy;
+import org.eclipse.winery.model.tosca.TPolicyTemplate;
 import org.eclipse.winery.model.tosca.TPolicyType;
 import org.eclipse.winery.model.tosca.TRelationshipTemplate;
 import org.eclipse.winery.model.tosca.TRelationshipType;
+import org.eclipse.winery.model.tosca.TRequirement;
 import org.eclipse.winery.model.tosca.TRequirementDefinition;
+import org.eclipse.winery.model.tosca.TRequirementType;
 import org.eclipse.winery.model.tosca.TServiceTemplate;
-import org.eclipse.winery.model.tosca.yaml.*;
+import org.eclipse.winery.model.tosca.TTag;
+import org.eclipse.winery.model.tosca.TTags;
+import org.eclipse.winery.model.tosca.TTopologyTemplate;
+import org.eclipse.winery.model.tosca.yaml.TArtifactDefinition;
+import org.eclipse.winery.model.tosca.yaml.TAttributeDefinition;
+import org.eclipse.winery.model.tosca.yaml.TImplementation;
+import org.eclipse.winery.model.tosca.yaml.TImportDefinition;
+import org.eclipse.winery.model.tosca.yaml.TInterfaceDefinition;
+import org.eclipse.winery.model.tosca.yaml.TInterfaceType;
+import org.eclipse.winery.model.tosca.yaml.TOperationDefinition;
+import org.eclipse.winery.model.tosca.yaml.TPolicyDefinition;
+import org.eclipse.winery.model.tosca.yaml.TPropertyAssignment;
+import org.eclipse.winery.model.tosca.yaml.TPropertyAssignmentOrDefinition;
+import org.eclipse.winery.model.tosca.yaml.TPropertyDefinition;
+import org.eclipse.winery.model.tosca.yaml.TRequirementAssignment;
+import org.eclipse.winery.model.tosca.yaml.TTopologyTemplateDefinition;
 import org.eclipse.winery.model.tosca.yaml.support.Metadata;
 import org.eclipse.winery.model.tosca.yaml.support.TMapRequirementAssignment;
 import org.eclipse.winery.repository.backend.IRepository;
@@ -44,16 +87,14 @@
 import org.eclipse.winery.yaml.converter.yaml.support.extension.TImplementationArtifactDefinition;
 import org.eclipse.winery.yaml.converter.yaml.visitors.ReferenceVisitor;
 import org.eclipse.winery.yaml.converter.yaml.visitors.SchemaVisitor;
+
+import org.eclipse.jdt.annotation.NonNull;
+import org.eclipse.jdt.annotation.Nullable;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import javax.xml.namespace.QName;
-import java.io.File;
-import java.nio.file.Path;
-import java.util.*;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
-
+// todo this class is not uptodate! please use the correct one!
+@Deprecated
 public class Y2XConverter {
     public final static Logger LOGGER = LoggerFactory.getLogger(Y2XConverter.class);
     private final IRepository repository;
@@ -349,7 +390,7 @@ public String convertOperationName(@NonNull TArtifactDefinition node) {
                         map.containsKey(values.get(1)) &&
                         map.get(values.get(1)).getOperations().containsKey(values.get(2)) &&
                         !map.get(values.get(1)).getOperations().get(values.get(2)).getOutputs().containsKey(values.get(3))
-                        ) {
+                    ) {
                         TPropertyDefinition.Builder pBuilder = new TPropertyDefinition.Builder(attr.getType());
                         map.get(values.get(1)).getOperations().get(values.get(2)).getOutputs().put(values.get(3), pBuilder.build());
                     }
@@ -477,7 +518,7 @@ private TNodeTemplate convert(org.eclipse.winery.model.tosca.yaml.TNodeTemplate
                     && Objects.nonNull(entry.getValue().getNode())
                     && Objects.isNull(entry.getValue().getRelationship())
                     && Objects.isNull(entry.getValue().getCapability())
-                    ) {
+                ) {
                     int num = 0;
                     String name = entry.getKey();
                     while (this.relationshipSTMap.containsKey(name)) {
@@ -517,7 +558,7 @@ private TRequirementDefinition convert(org.eclipse.winery.model.tosca.yaml.TRequ
         return new TRequirementDefinition.Builder(id,
             convertRequirementDefinition(
                 node,
-                getRequirementTypeName(node.getCapability(), id)
+                getRequirementTypeName(node.getCapability().toString(), id)
             ))
             .setLowerBound(node.getLowerBound())
             .setUpperBound(node.getUpperBound())
@@ -542,9 +583,9 @@ private QName convertRequirementDefinition(org.eclipse.winery.model.tosca.yaml.T
         return new QName(namespace, result.getName());
     }
 
-    private String getRequirementTypeName(QName capability, String id) {
+    private String getRequirementTypeName(String capability, String id) {
         if (Objects.isNull(capability)) return id.concat("Type");
-        return "Req".concat(capability.getLocalPart());
+        return "Req".concat(capability);
     }
 
     /**
@@ -565,7 +606,7 @@ private TRequirement convert(TRequirementAssignment node, String id) {
 
         return new TRequirement.Builder(id, new QName(
             Optional.ofNullable(node.getCapability()).map(QName::getNamespaceURI).orElse(this.namespace),
-            getRequirementTypeName(node.getCapability(), id)
+            getRequirementTypeName(node.getCapability().toString(), id)
         ))
             .build();
     }
@@ -579,15 +620,7 @@ private TRequirement convert(TRequirementAssignment node, String id) {
     private TCapabilityType convert(org.eclipse.winery.model.tosca.yaml.TCapabilityType node, String id) {
         if (Objects.isNull(node)) return null;
         return convert(node, new TCapabilityType.Builder(id))
-            .addTags(convertValidSourceTypes(node.getValidSourceTypes()))
-            .build();
-    }
-
-    private TTag convertValidSourceTypes(@NonNull List<QName> node) {
-        if (node.isEmpty()) return null;
-        return new TTag.Builder()
-            .setName("valid_source_types")
-            .setValue("[" + node.stream().map(QName::toString).collect(Collectors.joining(",")) + "]")
+            .setValidSourceTypes(node.getValidSourceTypes())
             .build();
     }
 
diff --git a/org.eclipse.winery.yaml.converter/src/test/java/org/eclipse/winery/yaml/converter/yaml/ShowcasesTest.java b/org.eclipse.winery.yaml.converter/src/test/java/org/eclipse/winery/yaml/converter/yaml/ShowcasesTest.java
index 379fd3e78..26d579e62 100644
--- a/org.eclipse.winery.yaml.converter/src/test/java/org/eclipse/winery/yaml/converter/yaml/ShowcasesTest.java
+++ b/org.eclipse.winery.yaml.converter/src/test/java/org/eclipse/winery/yaml/converter/yaml/ShowcasesTest.java
@@ -63,7 +63,6 @@ public MultiException convert(String path, String namespace, Stream<String> file
         return exception;
     }
 
-    @Ignore
     @Test
     public void nodeTypesTest() throws Exception {
         String path = "nodetypes";
@@ -74,7 +73,6 @@ public void nodeTypesTest() throws Exception {
         Assert.assertTrue(convert(path, namespace, files).isEmpty());
     }
 
-    @Ignore
     @Test
     public void serviceTemplateTest() throws Exception {
         String path = "servicetemplates";
