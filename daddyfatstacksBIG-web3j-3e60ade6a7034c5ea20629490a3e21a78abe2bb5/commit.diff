diff --git a/.travis.yml b/.travis.yml
index 8ed9974e2..e9022e276 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -28,13 +28,6 @@ jobs:
   - stage: github release
     if: branch =~ /release/
     script: "./scripts/github-release.sh"
-  - stage: release dependants
-    if: branch =~ /release/
-    script:
-    - "./scripts/release-dependant.sh web3j-quorum"
-    - "./scripts/release-dependant.sh web3j-cli"
-    - "./scripts/release-dependant.sh web3j-gradle-plugin"
-    - "./scripts/release-dependant.sh web3j-aion"
 after_success:
 - bash <(curl -s https://codecov.io/bash)
 before_install:
diff --git a/README.rst b/README.rst
index a62cedada..a3bdc7fa1 100644
--- a/README.rst
+++ b/README.rst
@@ -23,7 +23,7 @@ web3j: Web3 Java Ethereum Ðapp API
 web3j is a lightweight, highly modular, reactive, type safe Java and Android library for working with
 Smart Contracts and integrating with clients (nodes) on the Ethereum network:
 
-.. image:: https://raw.githubusercontent.com/web3j/web3j/master/docs/img/web3j_network.png
+.. image:: https://github.com/web3j/web3j-docs/blob/master/docs/img/web3j_network.png
 
 This allows you to work with the `Ethereum <https://www.ethereum.org/>`_ blockchain, without the
 additional overhead of having to write your own integration code for the platform.
diff --git a/abi/src/main/java/org/web3j/abi/datatypes/AbiTypes.java b/abi/src/main/java/org/web3j/abi/datatypes/AbiTypes.java
index e6dc6fb35..db2e0655e 100644
--- a/abi/src/main/java/org/web3j/abi/datatypes/AbiTypes.java
+++ b/abi/src/main/java/org/web3j/abi/datatypes/AbiTypes.java
@@ -187,9 +187,9 @@ private AbiTypes() {}
             case "int32":
                 return primitives ? Int.class : Int32.class;
             case "uint40":
-                return primitives ? Long.class : Int40.class;
-            case "int40":
                 return primitives ? Long.class : Uint40.class;
+            case "int40":
+                return primitives ? Long.class : Int40.class;
             case "uint48":
                 return primitives ? Long.class : Uint48.class;
             case "int48":
diff --git a/abi/src/test/java/org/web3j/abi/TypeDecoderTest.java b/abi/src/test/java/org/web3j/abi/TypeDecoderTest.java
index da7b87fd9..745ca987f 100644
--- a/abi/src/test/java/org/web3j/abi/TypeDecoderTest.java
+++ b/abi/src/test/java/org/web3j/abi/TypeDecoderTest.java
@@ -29,12 +29,72 @@
 import org.web3j.abi.datatypes.generated.Bytes1;
 import org.web3j.abi.datatypes.generated.Bytes4;
 import org.web3j.abi.datatypes.generated.Bytes6;
+import org.web3j.abi.datatypes.generated.Int104;
+import org.web3j.abi.datatypes.generated.Int112;
+import org.web3j.abi.datatypes.generated.Int120;
+import org.web3j.abi.datatypes.generated.Int128;
+import org.web3j.abi.datatypes.generated.Int136;
+import org.web3j.abi.datatypes.generated.Int144;
+import org.web3j.abi.datatypes.generated.Int152;
+import org.web3j.abi.datatypes.generated.Int16;
+import org.web3j.abi.datatypes.generated.Int160;
+import org.web3j.abi.datatypes.generated.Int168;
+import org.web3j.abi.datatypes.generated.Int176;
+import org.web3j.abi.datatypes.generated.Int184;
+import org.web3j.abi.datatypes.generated.Int192;
+import org.web3j.abi.datatypes.generated.Int200;
+import org.web3j.abi.datatypes.generated.Int208;
+import org.web3j.abi.datatypes.generated.Int216;
+import org.web3j.abi.datatypes.generated.Int224;
+import org.web3j.abi.datatypes.generated.Int232;
+import org.web3j.abi.datatypes.generated.Int24;
+import org.web3j.abi.datatypes.generated.Int240;
+import org.web3j.abi.datatypes.generated.Int248;
 import org.web3j.abi.datatypes.generated.Int256;
+import org.web3j.abi.datatypes.generated.Int32;
+import org.web3j.abi.datatypes.generated.Int40;
+import org.web3j.abi.datatypes.generated.Int48;
+import org.web3j.abi.datatypes.generated.Int56;
 import org.web3j.abi.datatypes.generated.Int64;
+import org.web3j.abi.datatypes.generated.Int72;
+import org.web3j.abi.datatypes.generated.Int8;
+import org.web3j.abi.datatypes.generated.Int80;
+import org.web3j.abi.datatypes.generated.Int88;
+import org.web3j.abi.datatypes.generated.Int96;
 import org.web3j.abi.datatypes.generated.StaticArray2;
 import org.web3j.abi.datatypes.generated.StaticArray3;
+import org.web3j.abi.datatypes.generated.Uint104;
+import org.web3j.abi.datatypes.generated.Uint112;
+import org.web3j.abi.datatypes.generated.Uint120;
+import org.web3j.abi.datatypes.generated.Uint128;
+import org.web3j.abi.datatypes.generated.Uint136;
+import org.web3j.abi.datatypes.generated.Uint144;
+import org.web3j.abi.datatypes.generated.Uint152;
+import org.web3j.abi.datatypes.generated.Uint16;
+import org.web3j.abi.datatypes.generated.Uint160;
+import org.web3j.abi.datatypes.generated.Uint168;
+import org.web3j.abi.datatypes.generated.Uint176;
+import org.web3j.abi.datatypes.generated.Uint184;
+import org.web3j.abi.datatypes.generated.Uint192;
+import org.web3j.abi.datatypes.generated.Uint200;
+import org.web3j.abi.datatypes.generated.Uint208;
+import org.web3j.abi.datatypes.generated.Uint216;
+import org.web3j.abi.datatypes.generated.Uint224;
+import org.web3j.abi.datatypes.generated.Uint232;
+import org.web3j.abi.datatypes.generated.Uint24;
+import org.web3j.abi.datatypes.generated.Uint240;
+import org.web3j.abi.datatypes.generated.Uint248;
 import org.web3j.abi.datatypes.generated.Uint256;
+import org.web3j.abi.datatypes.generated.Uint32;
+import org.web3j.abi.datatypes.generated.Uint40;
+import org.web3j.abi.datatypes.generated.Uint48;
+import org.web3j.abi.datatypes.generated.Uint56;
 import org.web3j.abi.datatypes.generated.Uint64;
+import org.web3j.abi.datatypes.generated.Uint72;
+import org.web3j.abi.datatypes.generated.Uint8;
+import org.web3j.abi.datatypes.generated.Uint80;
+import org.web3j.abi.datatypes.generated.Uint88;
+import org.web3j.abi.datatypes.generated.Uint96;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertThrows;
@@ -87,6 +147,79 @@ public void testBoolDecodeGivenOffset() {
 
     @Test
     public void testUintDecode() throws Exception {
+        assertEquals(TypeDecoder.instantiateType("uint", 123), (new Uint(BigInteger.valueOf(123))));
+        assertEquals(
+                TypeDecoder.instantiateType("uint", 1.0e20), (new Uint(BigInteger.TEN.pow(20))));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint8.class),
+                new Uint8(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "00000000000000000000000000000000000000000000000000000000000000ff",
+                        Uint8.class),
+                new Uint8(BigInteger.valueOf(255)));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint16.class),
+                new Uint16(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "000000000000000000000000000000000000000000000000000000000000ffff",
+                        Uint16.class),
+                new Uint16(BigInteger.valueOf(65535)));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint24.class),
+                new Uint24(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000ffffff",
+                        Uint24.class),
+                new Uint24(BigInteger.valueOf(16777215)));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint32.class),
+                new Uint32(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "00000000000000000000000000000000000000000000000000000000ffffffff",
+                        Uint32.class),
+                new Uint32(BigInteger.valueOf(4294967295L)));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint40.class),
+                new Uint40(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "000000000000000000000000000000000000000000000000000000ffffffffff",
+                        Uint40.class),
+                new Uint40(BigInteger.valueOf(1099511627775L)));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint48.class),
+                new Uint48(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000ffffffffffff",
+                        Uint48.class),
+                new Uint48(BigInteger.valueOf(281474976710655L)));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint56.class),
+                new Uint56(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "00000000000000000000000000000000000000000000000000ffffffffffffff",
+                        Uint56.class),
+                new Uint56(BigInteger.valueOf(72057594037927935L)));
         assertEquals(
                 TypeDecoder.decodeNumeric(
                         "0000000000000000000000000000000000000000000000000000000000000000",
@@ -104,6 +237,268 @@ public void testUintDecode() throws Exception {
                         "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
                         Uint64.class),
                 (new Uint64(new BigInteger("0ffffffffffffffff", 16))));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint72.class),
+                new Uint72(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000ffffffffffffffffff",
+                        Uint72.class),
+                new Uint72(new BigInteger("4722366482869645213695")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint80.class),
+                new Uint80(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "00000000000000000000000000000000000000000000ffffffffffffffffffff",
+                        Uint80.class),
+                new Uint80(new BigInteger("1208925819614629174706175")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint88.class),
+                new Uint88(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "000000000000000000000000000000000000000000ffffffffffffffffffffff",
+                        Uint88.class),
+                new Uint88(new BigInteger("309485009821345068724781055")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint96.class),
+                new Uint96(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000ffffffffffffffffffffffff",
+                        Uint96.class),
+                new Uint96(new BigInteger("79228162514264337593543950335")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint104.class),
+                new Uint104(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "00000000000000000000000000000000000000ffffffffffffffffffffffffff",
+                        Uint104.class),
+                new Uint104(new BigInteger("20282409603651670423947251286015")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint112.class),
+                new Uint112(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "000000000000000000000000000000000000ffffffffffffffffffffffffffff",
+                        Uint112.class),
+                new Uint112(new BigInteger("5192296858534827628530496329220095")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint120.class),
+                new Uint120(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000ffffffffffffffffffffffffffffff",
+                        Uint120.class),
+                new Uint120(new BigInteger("1329227995784915872903807060280344575")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint128.class),
+                new Uint128(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "00000000000000000000000000000000ffffffffffffffffffffffffffffffff",
+                        Uint128.class),
+                new Uint128(new BigInteger("340282366920938463463374607431768211455")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint136.class),
+                new Uint136(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "000000000000000000000000000000ffffffffffffffffffffffffffffffffff",
+                        Uint136.class),
+                new Uint136(new BigInteger("87112285931760246646623899502532662132735")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint144.class),
+                new Uint144(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000ffffffffffffffffffffffffffffffffffff",
+                        Uint144.class),
+                new Uint144(new BigInteger("22300745198530623141535718272648361505980415")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint152.class),
+                new Uint152(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "00000000000000000000000000ffffffffffffffffffffffffffffffffffffff",
+                        Uint152.class),
+                new Uint152(new BigInteger("5708990770823839524233143877797980545530986495")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint160.class),
+                new Uint160(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "000000000000000000000000ffffffffffffffffffffffffffffffffffffffff",
+                        Uint160.class),
+                new Uint160(new BigInteger("1461501637330902918203684832716283019655932542975")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint168.class),
+                new Uint168(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000ffffffffffffffffffffffffffffffffffffffffff",
+                        Uint168.class),
+                new Uint168(new BigInteger("374144419156711147060143317175368453031918731001855")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint176.class),
+                new Uint176(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "00000000000000000000ffffffffffffffffffffffffffffffffffffffffffff",
+                        Uint176.class),
+                new Uint176(
+                        new BigInteger("95780971304118053647396689196894323976171195136475135")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint184.class),
+                new Uint184(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "000000000000000000ffffffffffffffffffffffffffffffffffffffffffffff",
+                        Uint184.class),
+                new Uint184(
+                        new BigInteger(
+                                "24519928653854221733733552434404946937899825954937634815")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint192.class),
+                new Uint192(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffff",
+                        Uint192.class),
+                new Uint192(
+                        new BigInteger(
+                                "6277101735386680763835789423207666416102355444464034512895")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint200.class),
+                new Uint200(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "00000000000000ffffffffffffffffffffffffffffffffffffffffffffffffff",
+                        Uint200.class),
+                new Uint200(
+                        new BigInteger(
+                                "1606938044258990275541962092341162602522202993782792835301375")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint208.class),
+                new Uint208(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffff",
+                        Uint208.class),
+                new Uint208(
+                        new BigInteger(
+                                "411376139330301510538742295639337626245683966408394965837152255")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint216.class),
+                new Uint216(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffff",
+                        Uint216.class),
+                new Uint216(
+                        new BigInteger(
+                                "105312291668557186697918027683670432318895095400549111254310977535")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint224.class),
+                new Uint224(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
+                        Uint224.class),
+                new Uint224(
+                        new BigInteger(
+                                "26959946667150639794667015087019630673637144422540572481103610249215")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint232.class),
+                new Uint232(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
+                        Uint232.class),
+                new Uint232(
+                        new BigInteger(
+                                "6901746346790563787434755862277025452451108972170386555162524223799295")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint240.class),
+                new Uint240(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
+                        Uint240.class),
+                new Uint240(
+                        new BigInteger(
+                                "1766847064778384329583297500742918515827483896875618958121606201292619775")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint248.class),
+                new Uint248(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
+                        Uint248.class),
+                new Uint248(
+                        new BigInteger(
+                                "452312848583266388373324160190187140051835877600158453279131187530910662655")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Uint256.class),
+                new Uint256(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
+                        Uint256.class),
+                new Uint256(
+                        new BigInteger(
+                                "115792089237316195423570985008687907853269984665640564039457584007913129639935")));
+
         assertEquals(TypeDecoder.instantiateType("uint", 123), (new Uint(BigInteger.valueOf(123))));
         assertEquals(
                 TypeDecoder.instantiateType("uint", 1.0e20), (new Uint(BigInteger.TEN.pow(20))));
@@ -111,6 +506,77 @@ public void testUintDecode() throws Exception {
 
     @Test
     public void testIntDecode() throws Exception {
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int8.class),
+                new Int8(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "000000000000000000000000000000000000000000000000000000000000007f",
+                        Int8.class),
+                new Int8(BigInteger.valueOf(127)));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int16.class),
+                new Int16(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000007FFF",
+                        Int16.class),
+                new Int16(BigInteger.valueOf(32767)));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int24.class),
+                new Int24(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "00000000000000000000000000000000000000000000000000000000007fffff",
+                        Int24.class),
+                new Int24(BigInteger.valueOf(8388607)));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int32.class),
+                new Int32(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "000000000000000000000000000000000000000000000000000000007fffffff",
+                        Int32.class),
+                new Int32(BigInteger.valueOf(2147483647)));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int40.class),
+                new Int40(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000007FFFFFFFFF",
+                        Int40.class),
+                new Int40(BigInteger.valueOf(549755813887L)));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int48.class),
+                new Int48(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "00000000000000000000000000000000000000000000000000007FFFFFFFFFFF",
+                        Int48.class),
+                new Int48(BigInteger.valueOf(140737488355327L)));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int56.class),
+                new Int56(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "000000000000000000000000000000000000000000000000007FFFFFFFFFFFFF",
+                        Int56.class),
+                new Int56(BigInteger.valueOf(36028797018963967L)));
+
         assertEquals(
                 TypeDecoder.decodeNumeric(
                         "0000000000000000000000000000000000000000000000000000000000000000",
@@ -134,6 +600,255 @@ public void testIntDecode() throws Exception {
                         "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
                         Int64.class),
                 (new Int64(BigInteger.valueOf(-1))));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int72.class),
+                new Int72(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "00000000000000000000000000000000000000000000007fffffffffffffffff",
+                        Int72.class),
+                new Int72(new BigInteger("2361183241434822606847")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int80.class),
+                new Int80(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "000000000000000000000000000000000000000000007fffffffffffffffffff",
+                        Int80.class),
+                new Int80(new BigInteger("604462909807314587353087")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int88.class),
+                new Int88(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000007fffffffffffffffffffff",
+                        Int88.class),
+                new Int88(new BigInteger("154742504910672534362390527")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int96.class),
+                new Int96(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "00000000000000000000000000000000000000007fffffffffffffffffffffff",
+                        Int96.class),
+                new Int96(new BigInteger("39614081257132168796771975167")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int104.class),
+                new Int104(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "000000000000000000000000000000000000007fffffffffffffffffffffffff",
+                        Int104.class),
+                new Int104(new BigInteger("10141204801825835211973625643007")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int112.class),
+                new Int112(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000007fffffffffffffffffffffffffff",
+                        Int112.class),
+                new Int112(new BigInteger("2596148429267413814265248164610047")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int120.class),
+                new Int120(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "00000000000000000000000000000000007fffffffffffffffffffffffffffff",
+                        Int120.class),
+                new Int120(new BigInteger("664613997892457936451903530140172287")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int128.class),
+                new Int128(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "000000000000000000000000000000007fffffffffffffffffffffffffffffff",
+                        Int128.class),
+                new Int128(new BigInteger("170141183460469231731687303715884105727")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int136.class),
+                new Int136(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000007fffffffffffffffffffffffffffffffff",
+                        Int136.class),
+                new Int136(new BigInteger("43556142965880123323311949751266331066367")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int144.class),
+                new Int144(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "00000000000000000000000000007fffffffffffffffffffffffffffffffffff",
+                        Int144.class),
+                new Int144(new BigInteger("11150372599265311570767859136324180752990207")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int152.class),
+                new Int152(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "000000000000000000000000007fffffffffffffffffffffffffffffffffffff",
+                        Int152.class),
+                new Int152(new BigInteger("2854495385411919762116571938898990272765493247")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int160.class),
+                new Int160(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000007fffffffffffffffffffffffffffffffffffffff",
+                        Int160.class),
+                new Int160(new BigInteger("730750818665451459101842416358141509827966271487")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int168.class),
+                new Int168(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "00000000000000000000007fffffffffffffffffffffffffffffffffffffffff",
+                        Int168.class),
+                new Int168(new BigInteger("187072209578355573530071658587684226515959365500927")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int176.class),
+                new Int176(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "000000000000000000007fffffffffffffffffffffffffffffffffffffffffff",
+                        Int176.class),
+                new Int176(
+                        new BigInteger("47890485652059026823698344598447161988085597568237567")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int184.class),
+                new Int184(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000007fffffffffffffffffffffffffffffffffffffffffffff",
+                        Int184.class),
+                new Int184(
+                        new BigInteger(
+                                "12259964326927110866866776217202473468949912977468817407")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int192.class),
+                new Int192(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "00000000000000007fffffffffffffffffffffffffffffffffffffffffffffff",
+                        Int192.class),
+                new Int192(
+                        new BigInteger(
+                                "3138550867693340381917894711603833208051177722232017256447")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int200.class),
+                new Int200(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "000000000000007fffffffffffffffffffffffffffffffffffffffffffffffff",
+                        Int200.class),
+                new Int200(
+                        new BigInteger(
+                                "803469022129495137770981046170581301261101496891396417650687")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int208.class),
+                new Int208(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000007fffffffffffffffffffffffffffffffffffffffffffffffffff",
+                        Int208.class),
+                new Int208(
+                        new BigInteger(
+                                "205688069665150755269371147819668813122841983204197482918576127")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int216.class),
+                new Int216(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "00000000007fffffffffffffffffffffffffffffffffffffffffffffffffffff",
+                        Int216.class),
+                new Int216(
+                        new BigInteger(
+                                "52656145834278593348959013841835216159447547700274555627155488767")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int224.class),
+                new Int224(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffff",
+                        Int224.class),
+                new Int224(
+                        new BigInteger(
+                                "13479973333575319897333507543509815336818572211270286240551805124607")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int232.class),
+                new Int232(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
+                        Int232.class),
+                new Int232(
+                        new BigInteger(
+                                "3450873173395281893717377931138512726225554486085193277581262111899647")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int240.class),
+                new Int240(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "00007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
+                        Int240.class),
+                new Int240(
+                        new BigInteger(
+                                "883423532389192164791648750371459257913741948437809479060803100646309887")));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "0000000000000000000000000000000000000000000000000000000000000000",
+                        Int248.class),
+                new Int248(BigInteger.ZERO));
+        assertEquals(
+                TypeDecoder.decodeNumeric(
+                        "007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
+                        Int248.class),
+                new Int248(
+                        new BigInteger(
+                                "226156424291633194186662080095093570025917938800079226639565593765455331327")));
 
         assertEquals(
                 TypeDecoder.decodeNumeric(
diff --git a/abi/src/test/java/org/web3j/abi/TypeEncoderTest.java b/abi/src/test/java/org/web3j/abi/TypeEncoderTest.java
index 6eaf3ab79..20b32f341 100644
--- a/abi/src/test/java/org/web3j/abi/TypeEncoderTest.java
+++ b/abi/src/test/java/org/web3j/abi/TypeEncoderTest.java
@@ -29,9 +29,69 @@
 import org.web3j.abi.datatypes.generated.Bytes1;
 import org.web3j.abi.datatypes.generated.Bytes4;
 import org.web3j.abi.datatypes.generated.Bytes6;
+import org.web3j.abi.datatypes.generated.Int104;
+import org.web3j.abi.datatypes.generated.Int112;
+import org.web3j.abi.datatypes.generated.Int120;
+import org.web3j.abi.datatypes.generated.Int128;
+import org.web3j.abi.datatypes.generated.Int136;
+import org.web3j.abi.datatypes.generated.Int144;
+import org.web3j.abi.datatypes.generated.Int152;
+import org.web3j.abi.datatypes.generated.Int16;
+import org.web3j.abi.datatypes.generated.Int160;
+import org.web3j.abi.datatypes.generated.Int168;
+import org.web3j.abi.datatypes.generated.Int176;
+import org.web3j.abi.datatypes.generated.Int184;
+import org.web3j.abi.datatypes.generated.Int192;
+import org.web3j.abi.datatypes.generated.Int200;
+import org.web3j.abi.datatypes.generated.Int208;
+import org.web3j.abi.datatypes.generated.Int216;
+import org.web3j.abi.datatypes.generated.Int224;
+import org.web3j.abi.datatypes.generated.Int232;
+import org.web3j.abi.datatypes.generated.Int24;
+import org.web3j.abi.datatypes.generated.Int240;
+import org.web3j.abi.datatypes.generated.Int248;
+import org.web3j.abi.datatypes.generated.Int32;
+import org.web3j.abi.datatypes.generated.Int40;
+import org.web3j.abi.datatypes.generated.Int48;
+import org.web3j.abi.datatypes.generated.Int56;
 import org.web3j.abi.datatypes.generated.Int64;
+import org.web3j.abi.datatypes.generated.Int72;
+import org.web3j.abi.datatypes.generated.Int8;
+import org.web3j.abi.datatypes.generated.Int80;
+import org.web3j.abi.datatypes.generated.Int88;
+import org.web3j.abi.datatypes.generated.Int96;
 import org.web3j.abi.datatypes.generated.StaticArray2;
+import org.web3j.abi.datatypes.generated.Uint104;
+import org.web3j.abi.datatypes.generated.Uint112;
+import org.web3j.abi.datatypes.generated.Uint120;
+import org.web3j.abi.datatypes.generated.Uint128;
+import org.web3j.abi.datatypes.generated.Uint136;
+import org.web3j.abi.datatypes.generated.Uint144;
+import org.web3j.abi.datatypes.generated.Uint152;
+import org.web3j.abi.datatypes.generated.Uint16;
+import org.web3j.abi.datatypes.generated.Uint160;
+import org.web3j.abi.datatypes.generated.Uint168;
+import org.web3j.abi.datatypes.generated.Uint176;
+import org.web3j.abi.datatypes.generated.Uint184;
+import org.web3j.abi.datatypes.generated.Uint192;
+import org.web3j.abi.datatypes.generated.Uint200;
+import org.web3j.abi.datatypes.generated.Uint208;
+import org.web3j.abi.datatypes.generated.Uint216;
+import org.web3j.abi.datatypes.generated.Uint224;
+import org.web3j.abi.datatypes.generated.Uint232;
+import org.web3j.abi.datatypes.generated.Uint24;
+import org.web3j.abi.datatypes.generated.Uint240;
+import org.web3j.abi.datatypes.generated.Uint248;
+import org.web3j.abi.datatypes.generated.Uint32;
+import org.web3j.abi.datatypes.generated.Uint40;
+import org.web3j.abi.datatypes.generated.Uint48;
+import org.web3j.abi.datatypes.generated.Uint56;
 import org.web3j.abi.datatypes.generated.Uint64;
+import org.web3j.abi.datatypes.generated.Uint72;
+import org.web3j.abi.datatypes.generated.Uint8;
+import org.web3j.abi.datatypes.generated.Uint80;
+import org.web3j.abi.datatypes.generated.Uint88;
+import org.web3j.abi.datatypes.generated.Uint96;
 import org.web3j.abi.datatypes.primitive.Byte;
 import org.web3j.abi.datatypes.primitive.Char;
 import org.web3j.abi.datatypes.primitive.Long;
@@ -56,9 +116,72 @@ public void testBoolEncode() {
 
     @Test
     public void testUintEncode() {
-        Uint zero = new Uint64(BigInteger.ZERO);
+        Uint zero8 = new Uint8(BigInteger.ZERO);
         assertEquals(
-                TypeEncoder.encodeNumeric(zero),
+                TypeEncoder.encodeNumeric(zero8),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max8 = new Uint8(255);
+        assertEquals(
+                TypeEncoder.encodeNumeric(max8),
+                "00000000000000000000000000000000000000000000000000000000000000ff");
+
+        Uint zero16 = new Uint16(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero16),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max16 = new Uint16(65535);
+        assertEquals(
+                TypeEncoder.encodeNumeric(max16),
+                "000000000000000000000000000000000000000000000000000000000000ffff");
+
+        Uint zero24 = new Uint24(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero24),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max24 = new Uint24(16777215);
+        assertEquals(
+                TypeEncoder.encodeNumeric(max24),
+                "0000000000000000000000000000000000000000000000000000000000ffffff");
+
+        Uint zero32 = new Uint32(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero32),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max32 = new Uint32(BigInteger.valueOf(4294967295L));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max32),
+                "00000000000000000000000000000000000000000000000000000000ffffffff");
+
+        Uint zero40 = new Uint40(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero40),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max40 = new Uint40(BigInteger.valueOf(1099511627775L));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max40),
+                "000000000000000000000000000000000000000000000000000000ffffffffff");
+
+        Uint zero48 = new Uint48(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero48),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max48 = new Uint48(BigInteger.valueOf(281474976710655L));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max48),
+                "0000000000000000000000000000000000000000000000000000ffffffffffff");
+
+        Uint zero56 = new Uint56(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero56),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max56 = new Uint56(BigInteger.valueOf(72057594037927935L));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max56),
+                "00000000000000000000000000000000000000000000000000ffffffffffffff");
+
+        Uint zero64 = new Uint64(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero64),
                 ("0000000000000000000000000000000000000000000000000000000000000000"));
 
         Uint maxLong = new Uint64(BigInteger.valueOf(java.lang.Long.MAX_VALUE));
@@ -66,13 +189,13 @@ public void testUintEncode() {
                 TypeEncoder.encodeNumeric(maxLong),
                 ("0000000000000000000000000000000000000000000000007fffffffffffffff"));
 
-        Uint maxValue =
+        Uint maxValue64 =
                 new Uint(
                         new BigInteger(
                                 "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
                                 16));
         assertEquals(
-                TypeEncoder.encodeNumeric(maxValue),
+                TypeEncoder.encodeNumeric(maxValue64),
                 ("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
 
         Uint largeValue =
@@ -83,6 +206,243 @@ public void testUintEncode() {
         assertEquals(
                 TypeEncoder.encodeNumeric(largeValue),
                 ("fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe"));
+
+        Uint zero72 = new Uint72(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero72),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max72 = new Uint72(new BigInteger("4722366482869645213695"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max72),
+                "0000000000000000000000000000000000000000000000ffffffffffffffffff");
+
+        Uint zero80 = new Uint80(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero80),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max80 = new Uint80(new BigInteger("1208925819614629174706175"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max80),
+                "00000000000000000000000000000000000000000000ffffffffffffffffffff");
+
+        Uint zero88 = new Uint88(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero88),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max88 = new Uint88(new BigInteger("309485009821345068724781055"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max88),
+                "000000000000000000000000000000000000000000ffffffffffffffffffffff");
+
+        Uint zero96 = new Uint96(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero96),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max96 = new Uint96(new BigInteger("79228162514264337593543950335"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max96),
+                "0000000000000000000000000000000000000000ffffffffffffffffffffffff");
+
+        Uint zero104 = new Uint104(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero104),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max104 = new Uint104(new BigInteger("20282409603651670423947251286015"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max104),
+                "00000000000000000000000000000000000000ffffffffffffffffffffffffff");
+
+        Uint zero112 = new Uint112(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero112),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max112 = new Uint112(new BigInteger("5192296858534827628530496329220095"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max112),
+                "000000000000000000000000000000000000ffffffffffffffffffffffffffff");
+
+        Uint zero120 = new Uint120(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero120),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max120 = new Uint120(new BigInteger("1329227995784915872903807060280344575"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max120),
+                "0000000000000000000000000000000000ffffffffffffffffffffffffffffff");
+
+        Uint zero128 = new Uint128(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero128),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max128 = new Uint128(new BigInteger("340282366920938463463374607431768211455"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max128),
+                "00000000000000000000000000000000ffffffffffffffffffffffffffffffff");
+
+        Uint zero136 = new Uint136(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero136),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max136 = new Uint136(new BigInteger("87112285931760246646623899502532662132735"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max136),
+                "000000000000000000000000000000ffffffffffffffffffffffffffffffffff");
+
+        Uint zero144 = new Uint144(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero144),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max144 = new Uint144(new BigInteger("22300745198530623141535718272648361505980415"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max144),
+                "0000000000000000000000000000ffffffffffffffffffffffffffffffffffff");
+
+        Uint zero152 = new Uint152(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero152),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max152 = new Uint152(new BigInteger("5708990770823839524233143877797980545530986495"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max152),
+                "00000000000000000000000000ffffffffffffffffffffffffffffffffffffff");
+
+        Uint zero160 = new Uint160(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero160),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max160 =
+                new Uint160(new BigInteger("1461501637330902918203684832716283019655932542975"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max160),
+                "000000000000000000000000ffffffffffffffffffffffffffffffffffffffff");
+
+        Uint zero168 = new Uint168(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero168),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max168 =
+                new Uint168(new BigInteger("374144419156711147060143317175368453031918731001855"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max168),
+                "0000000000000000000000ffffffffffffffffffffffffffffffffffffffffff");
+
+        Uint zero176 = new Uint176(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero176),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max176 =
+                new Uint176(
+                        new BigInteger("95780971304118053647396689196894323976171195136475135"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max176),
+                "00000000000000000000ffffffffffffffffffffffffffffffffffffffffffff");
+
+        Uint zero184 = new Uint184(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero184),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max184 =
+                new Uint184(
+                        new BigInteger("24519928653854221733733552434404946937899825954937634815"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max184),
+                "000000000000000000ffffffffffffffffffffffffffffffffffffffffffffff");
+
+        Uint zero192 = new Uint192(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero192),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max192 =
+                new Uint192(
+                        new BigInteger(
+                                "6277101735386680763835789423207666416102355444464034512895"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max192),
+                "0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffff");
+
+        Uint zero200 = new Uint200(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero200),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max200 =
+                new Uint200(
+                        new BigInteger(
+                                "1606938044258990275541962092341162602522202993782792835301375"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max200),
+                "00000000000000ffffffffffffffffffffffffffffffffffffffffffffffffff");
+
+        Uint zero208 = new Uint208(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero208),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max208 =
+                new Uint208(
+                        new BigInteger(
+                                "411376139330301510538742295639337626245683966408394965837152255"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max208),
+                "000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffff");
+
+        Uint zero216 = new Uint216(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero216),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max216 =
+                new Uint216(
+                        new BigInteger(
+                                "105312291668557186697918027683670432318895095400549111254310977535"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max216),
+                "0000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffff");
+
+        Uint zero224 = new Uint224(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero224),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max224 =
+                new Uint224(
+                        new BigInteger(
+                                "26959946667150639794667015087019630673637144422540572481103610249215"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max224),
+                "00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
+
+        Uint zero232 = new Uint232(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero232),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max232 =
+                new Uint232(
+                        new BigInteger(
+                                "6901746346790563787434755862277025452451108972170386555162524223799295"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max232),
+                "000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
+
+        Uint zero240 = new Uint232(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero240),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max240 =
+                new Uint240(
+                        new BigInteger(
+                                "1766847064778384329583297500742918515827483896875618958121606201292619775"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max240),
+                "0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
+
+        Uint zero248 = new Uint248(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero248),
+                "0000000000000000000000000000000000000000000000000000000000000000");
+        Uint max248 =
+                new Uint248(
+                        new BigInteger(
+                                "452312848583266388373324160190187140051835877600158453279131187530910662655"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max248),
+                "00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
     }
 
     @Test
@@ -104,21 +464,547 @@ public void testTooLargeUintEncode() {
 
     @Test
     public void testIntEncode() {
-        Int zero = new Int64(BigInteger.ZERO);
+        Int zero8 = new Int8(BigInteger.ZERO);
         assertEquals(
-                TypeEncoder.encodeNumeric(zero),
+                TypeEncoder.encodeNumeric(zero8),
                 ("0000000000000000000000000000000000000000000000000000000000000000"));
 
-        Int maxLong = new Int64(BigInteger.valueOf(java.lang.Long.MAX_VALUE));
+        Int max8 = new Int8(BigInteger.valueOf(127));
         assertEquals(
-                TypeEncoder.encodeNumeric(maxLong),
+                TypeEncoder.encodeNumeric(max8),
+                ("000000000000000000000000000000000000000000000000000000000000007f"));
+
+        Int min8 = new Int8(BigInteger.valueOf(-128));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min8),
+                ("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80"));
+
+        Int zero16 = new Int16(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero16),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max16 = new Int16(BigInteger.valueOf(32767));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max16),
+                ("0000000000000000000000000000000000000000000000000000000000007fff"));
+
+        Int min16 = new Int16(BigInteger.valueOf(-32768));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min16),
+                ("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8000"));
+
+        Int zero24 = new Int24(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero24),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max24 = new Int24(BigInteger.valueOf(8388607));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max24),
+                ("00000000000000000000000000000000000000000000000000000000007fffff"));
+
+        Int min24 = new Int24(BigInteger.valueOf(-8388608));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min24),
+                ("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff800000"));
+
+        Int zero32 = new Int32(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero32),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max32 = new Int32(BigInteger.valueOf(2147483647));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max32),
+                ("000000000000000000000000000000000000000000000000000000007fffffff"));
+
+        Int min32 = new Int32(BigInteger.valueOf(-2147483648));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min32),
+                ("ffffffffffffffffffffffffffffffffffffffffffffffffffffffff80000000"));
+
+        Int zero40 = new Int40(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero40),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max40 = new Int40(BigInteger.valueOf(549755813887L));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max40),
+                ("0000000000000000000000000000000000000000000000000000007fffffffff"));
+
+        Int min40 = new Int40(BigInteger.valueOf(-549755813888L));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min40),
+                ("ffffffffffffffffffffffffffffffffffffffffffffffffffffff8000000000"));
+
+        Int zero48 = new Int48(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero48),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max48 = new Int48(BigInteger.valueOf(140737488355327L));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max48),
+                ("00000000000000000000000000000000000000000000000000007fffffffffff"));
+
+        Int min48 = new Int48(BigInteger.valueOf(-140737488355328L));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min48),
+                ("ffffffffffffffffffffffffffffffffffffffffffffffffffff800000000000"));
+
+        Int zero56 = new Int48(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero56),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max56 = new Int56(BigInteger.valueOf(36028797018963967L));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max56),
+                ("000000000000000000000000000000000000000000000000007fffffffffffff"));
+
+        Int min56 = new Int56(BigInteger.valueOf(-36028797018963968L));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min56),
+                ("ffffffffffffffffffffffffffffffffffffffffffffffffff80000000000000"));
+
+        Int zero64 = new Int64(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero64),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max64 = new Int64(BigInteger.valueOf(java.lang.Long.MAX_VALUE));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max64),
                 ("0000000000000000000000000000000000000000000000007fffffffffffffff"));
 
-        Int minLong = new Int64(BigInteger.valueOf(java.lang.Long.MIN_VALUE));
+        Int min64 = new Int64(BigInteger.valueOf(java.lang.Long.MIN_VALUE));
         assertEquals(
-                TypeEncoder.encodeNumeric(minLong),
+                TypeEncoder.encodeNumeric(min64),
                 ("ffffffffffffffffffffffffffffffffffffffffffffffff8000000000000000"));
 
+        Int zero72 = new Int72(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero72),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max72 = new Int72(new BigInteger("2361183241434822606847"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max72),
+                ("00000000000000000000000000000000000000000000007fffffffffffffffff"));
+
+        Int min72 = new Int72(new BigInteger("-2361183241434822606848"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min72),
+                ("ffffffffffffffffffffffffffffffffffffffffffffff800000000000000000"));
+
+        Int zero80 = new Int80(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero80),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max80 = new Int80(new BigInteger("604462909807314587353087"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max80),
+                ("000000000000000000000000000000000000000000007fffffffffffffffffff"));
+
+        Int min80 = new Int80(new BigInteger("-604462909807314587353088"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min80),
+                ("ffffffffffffffffffffffffffffffffffffffffffff80000000000000000000"));
+
+        Int zero88 = new Int88(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero88),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max88 = new Int88(new BigInteger("154742504910672534362390527"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max88),
+                ("0000000000000000000000000000000000000000007fffffffffffffffffffff"));
+
+        Int min88 = new Int88(new BigInteger("-154742504910672534362390528"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min88),
+                ("ffffffffffffffffffffffffffffffffffffffffff8000000000000000000000"));
+
+        Int zero96 = new Int96(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero96),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max96 = new Int96(new BigInteger("39614081257132168796771975167"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max96),
+                ("00000000000000000000000000000000000000007fffffffffffffffffffffff"));
+
+        Int min96 = new Int96(new BigInteger("-39614081257132168796771975168"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min96),
+                ("ffffffffffffffffffffffffffffffffffffffff800000000000000000000000"));
+
+        Int zero104 = new Int104(BigInteger.ZERO);
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero104),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max104 = new Int104(new BigInteger("10141204801825835211973625643007"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max104),
+                ("000000000000000000000000000000000000007fffffffffffffffffffffffff"));
+
+        Int min104 = new Int104(new BigInteger("-10141204801825835211973625643008"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min104),
+                ("ffffffffffffffffffffffffffffffffffffff80000000000000000000000000"));
+
+        Int zero112 = new Int112(BigInteger.ZERO);
+
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero112),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max112 = new Int112(new BigInteger("2596148429267413814265248164610047"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max112),
+                ("0000000000000000000000000000000000007fffffffffffffffffffffffffff"));
+
+        Int min112 = new Int112(new BigInteger("-2596148429267413814265248164610048"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min112),
+                ("ffffffffffffffffffffffffffffffffffff8000000000000000000000000000"));
+
+        Int zero120 = new Int120(BigInteger.ZERO);
+
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero120),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max120 = new Int120(new BigInteger("664613997892457936451903530140172287"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max120),
+                ("00000000000000000000000000000000007fffffffffffffffffffffffffffff"));
+
+        Int min120 = new Int120(new BigInteger("-664613997892457936451903530140172288"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min120),
+                ("ffffffffffffffffffffffffffffffffff800000000000000000000000000000"));
+
+        Int zero128 = new Int128(BigInteger.ZERO);
+
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero128),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max128 = new Int128(new BigInteger("170141183460469231731687303715884105727"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max128),
+                ("000000000000000000000000000000007fffffffffffffffffffffffffffffff"));
+
+        Int min128 = new Int128(new BigInteger("-170141183460469231731687303715884105728"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min128),
+                ("ffffffffffffffffffffffffffffffff80000000000000000000000000000000"));
+
+        Int zero136 = new Int136(BigInteger.ZERO);
+
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero136),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max136 = new Int136(new BigInteger("43556142965880123323311949751266331066367"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max136),
+                ("0000000000000000000000000000007fffffffffffffffffffffffffffffffff"));
+
+        Int min136 = new Int136(new BigInteger("-43556142965880123323311949751266331066368"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min136),
+                ("ffffffffffffffffffffffffffffff8000000000000000000000000000000000"));
+
+        Int zero144 = new Int144(BigInteger.ZERO);
+
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero144),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max144 = new Int144(new BigInteger("11150372599265311570767859136324180752990207"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max144),
+                ("00000000000000000000000000007fffffffffffffffffffffffffffffffffff"));
+
+        Int min144 = new Int144(new BigInteger("-11150372599265311570767859136324180752990208"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min144),
+                ("ffffffffffffffffffffffffffff800000000000000000000000000000000000"));
+
+        Int zero152 = new Int152(BigInteger.ZERO);
+
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero152),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max152 = new Int152(new BigInteger("2854495385411919762116571938898990272765493247"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max152),
+                ("000000000000000000000000007fffffffffffffffffffffffffffffffffffff"));
+
+        Int min152 = new Int152(new BigInteger("-2854495385411919762116571938898990272765493248"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min152),
+                ("ffffffffffffffffffffffffff80000000000000000000000000000000000000"));
+
+        Int zero160 = new Int160(BigInteger.ZERO);
+
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero160),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max160 = new Int160(new BigInteger("730750818665451459101842416358141509827966271487"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max160),
+                ("0000000000000000000000007fffffffffffffffffffffffffffffffffffffff"));
+
+        Int min160 =
+                new Int160(new BigInteger("-730750818665451459101842416358141509827966271488"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min160),
+                ("ffffffffffffffffffffffff8000000000000000000000000000000000000000"));
+
+        Int zero168 = new Int168(BigInteger.ZERO);
+
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero168),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max168 =
+                new Int168(new BigInteger("187072209578355573530071658587684226515959365500927"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max168),
+                ("00000000000000000000007fffffffffffffffffffffffffffffffffffffffff"));
+
+        Int min168 =
+                new Int168(new BigInteger("-187072209578355573530071658587684226515959365500928"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min168),
+                ("ffffffffffffffffffffff800000000000000000000000000000000000000000"));
+
+        Int zero176 = new Int176(BigInteger.ZERO);
+
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero176),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max176 =
+                new Int176(new BigInteger("47890485652059026823698344598447161988085597568237567"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max176),
+                ("000000000000000000007fffffffffffffffffffffffffffffffffffffffffff"));
+
+        Int min176 =
+                new Int176(
+                        new BigInteger("-47890485652059026823698344598447161988085597568237568"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min176),
+                ("ffffffffffffffffffff80000000000000000000000000000000000000000000"));
+
+        Int zero184 = new Int184(BigInteger.ZERO);
+
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero184),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max184 =
+                new Int184(
+                        new BigInteger("12259964326927110866866776217202473468949912977468817407"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max184),
+                ("0000000000000000007fffffffffffffffffffffffffffffffffffffffffffff"));
+
+        Int min184 =
+                new Int184(
+                        new BigInteger(
+                                "-12259964326927110866866776217202473468949912977468817408"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min184),
+                ("ffffffffffffffffff8000000000000000000000000000000000000000000000"));
+
+        Int zero192 = new Int192(BigInteger.ZERO);
+
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero192),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max192 =
+                new Int192(
+                        new BigInteger(
+                                "3138550867693340381917894711603833208051177722232017256447"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max192),
+                ("00000000000000007fffffffffffffffffffffffffffffffffffffffffffffff"));
+
+        Int min192 =
+                new Int192(
+                        new BigInteger(
+                                "-3138550867693340381917894711603833208051177722232017256448"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min192),
+                ("ffffffffffffffff800000000000000000000000000000000000000000000000"));
+
+        Int zero200 = new Int200(BigInteger.ZERO);
+
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero200),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max200 =
+                new Int200(
+                        new BigInteger(
+                                "803469022129495137770981046170581301261101496891396417650687"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max200),
+                ("000000000000007fffffffffffffffffffffffffffffffffffffffffffffffff"));
+
+        Int min200 =
+                new Int200(
+                        new BigInteger(
+                                "-803469022129495137770981046170581301261101496891396417650688"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min200),
+                ("ffffffffffffff80000000000000000000000000000000000000000000000000"));
+
+        Int zero208 = new Int208(BigInteger.ZERO);
+
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero208),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max208 =
+                new Int208(
+                        new BigInteger(
+                                "205688069665150755269371147819668813122841983204197482918576127"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max208),
+                ("0000000000007fffffffffffffffffffffffffffffffffffffffffffffffffff"));
+
+        Int min208 =
+                new Int208(
+                        new BigInteger(
+                                "-205688069665150755269371147819668813122841983204197482918576128"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min208),
+                ("ffffffffffff8000000000000000000000000000000000000000000000000000"));
+
+        Int zero216 = new Int216(BigInteger.ZERO);
+
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero216),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max216 =
+                new Int216(
+                        new BigInteger(
+                                "52656145834278593348959013841835216159447547700274555627155488767"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max216),
+                ("00000000007fffffffffffffffffffffffffffffffffffffffffffffffffffff"));
+
+        Int min216 =
+                new Int216(
+                        new BigInteger(
+                                "-52656145834278593348959013841835216159447547700274555627155488768"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min216),
+                ("ffffffffff800000000000000000000000000000000000000000000000000000"));
+
+        Int zero224 = new Int224(BigInteger.ZERO);
+
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero224),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max224 =
+                new Int224(
+                        new BigInteger(
+                                "13479973333575319897333507543509815336818572211270286240551805124607"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max224),
+                ("000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
+
+        Int min224 =
+                new Int224(
+                        new BigInteger(
+                                "-13479973333575319897333507543509815336818572211270286240551805124608"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min224),
+                ("ffffffff80000000000000000000000000000000000000000000000000000000"));
+
+        Int zero232 = new Int232(BigInteger.ZERO);
+
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero232),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max232 =
+                new Int232(
+                        new BigInteger(
+                                "3450873173395281893717377931138512726225554486085193277581262111899647"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max232),
+                ("0000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
+
+        Int min232 =
+                new Int232(
+                        new BigInteger(
+                                "-3450873173395281893717377931138512726225554486085193277581262111899648"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min232),
+                ("ffffff8000000000000000000000000000000000000000000000000000000000"));
+
+        Int zero240 = new Int240(BigInteger.ZERO);
+
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero240),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max240 =
+                new Int240(
+                        new BigInteger(
+                                "883423532389192164791648750371459257913741948437809479060803100646309887"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max240),
+                ("00007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
+
+        Int min240 =
+                new Int240(
+                        new BigInteger(
+                                "-883423532389192164791648750371459257913741948437809479060803100646309888"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min240),
+                ("ffff800000000000000000000000000000000000000000000000000000000000"));
+
+        Int zero248 = new Int248(BigInteger.ZERO);
+
+        assertEquals(
+                TypeEncoder.encodeNumeric(zero248),
+                ("0000000000000000000000000000000000000000000000000000000000000000"));
+
+        Int max248 =
+                new Int248(
+                        new BigInteger(
+                                "226156424291633194186662080095093570025917938800079226639565593765455331327"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(max248),
+                ("007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
+
+        Int min248 =
+                new Int248(
+                        new BigInteger(
+                                "-226156424291633194186662080095093570025917938800079226639565593765455331328"));
+        assertEquals(
+                TypeEncoder.encodeNumeric(min248),
+                ("ff80000000000000000000000000000000000000000000000000000000000000"));
         Int minusOne = new Int(BigInteger.valueOf(-1));
         assertEquals(
                 TypeEncoder.encodeNumeric(minusOne),
@@ -249,10 +1135,11 @@ public void testAddress() {
 
     @Test
     public void testInvalidAddress() {
-        Address address =
-                new Address("0xa04462684b510796c186d19abfa6929742f79394583d6efb1243bbb473f21d9f");
-        assertEquals(address.getTypeAsString(), ("address"));
-        assertThrows(UnsupportedOperationException.class, () -> TypeEncoder.encodeAddress(address));
+        assertThrows(
+                UnsupportedOperationException.class,
+                () ->
+                        new Address(
+                                "0xa04462684b510796c186d19abfa6929742f79394583d6efb1243bbb473f21d9f"));
     }
 
     @Test
diff --git a/besu/src/main/java/org/web3j/tx/PrivateTransactionManager.java b/besu/src/main/java/org/web3j/tx/PrivateTransactionManager.java
index 0b30016a1..8d63d3a67 100644
--- a/besu/src/main/java/org/web3j/tx/PrivateTransactionManager.java
+++ b/besu/src/main/java/org/web3j/tx/PrivateTransactionManager.java
@@ -29,6 +29,7 @@
 import org.web3j.protocol.eea.crypto.PrivateTransactionEncoder;
 import org.web3j.protocol.eea.crypto.RawPrivateTransaction;
 import org.web3j.protocol.exceptions.TransactionException;
+import org.web3j.tx.exceptions.ContractCallException;
 import org.web3j.tx.gas.BesuPrivacyGasProvider;
 import org.web3j.tx.response.PollingPrivateTransactionReceiptProcessor;
 import org.web3j.tx.response.PrivateTransactionReceiptProcessor;
@@ -36,6 +37,7 @@
 import org.web3j.utils.Numeric;
 
 import static org.web3j.utils.Restriction.RESTRICTED;
+import static org.web3j.utils.RevertReasonExtractor.extractRevertReason;
 
 public abstract class PrivateTransactionManager extends TransactionManager {
     private static final Logger log = LoggerFactory.getLogger(PrivateTransactionManager.class);
@@ -178,6 +180,11 @@ public String sendCall(
                             data,
                             BigInteger.ZERO);
             final TransactionReceipt ptr = processResponse(est);
+
+            if (!ptr.isStatusOK()) {
+                throw new ContractCallException(
+                        String.format(REVERT_ERR_STR, extractRevertReason(ptr, data, besu, false)));
+            }
             return ((PrivateTransactionReceipt) ptr).getOutput();
         } catch (TransactionException e) {
             log.error("Failed to execute call", e);
diff --git a/build.gradle b/build.gradle
index f0ce92066..1408d76e2 100644
--- a/build.gradle
+++ b/build.gradle
@@ -14,7 +14,7 @@ ext {
     jacksonVersion = '2.8.5'
     javapoetVersion = '1.7.0'
     jnr_unixsocketVersion = '0.21'
-    okhttpVersion = '3.8.1'
+    okhttpVersion = '4.3.1'
     rxjavaVersion = '2.2.2'
     slf4jVersion = '1.7.25'
     javaWebSocketVersion = '1.3.8'
@@ -26,7 +26,7 @@ ext {
     junitBenchmarkVersion = '0.7.2'
     logbackVersion = '1.2.3'
     mockitoJunitVersion = "3.1.0"
-
+    junitPlatformLauncherVersion = "1.5.2"
 }
 
 
@@ -64,6 +64,7 @@ allprojects {
 
     tasks.withType(Test) {
         reports.html.destination = file("${reporting.baseDir}/${name}")
+        useJUnitPlatform()
     }
 
     dependencies {
diff --git a/codegen/build.gradle b/codegen/build.gradle
index 9c8044148..cff7364c0 100644
--- a/codegen/build.gradle
+++ b/codegen/build.gradle
@@ -5,7 +5,7 @@ dependencies {
             "com.squareup:javapoet:$javapoetVersion",
             "info.picocli:picocli:$picocliVersion"
     testCompile project(path: ':core', configuration: 'testArtifacts')
-    implementation("org.junit.platform:junit-platform-launcher:1.6.0-SNAPSHOT")
+    implementation("org.junit.platform:junit-platform-launcher:$junitPlatformLauncherVersion")
     implementation("org.junit.jupiter:junit-jupiter-engine:$junitVersion")
     implementation("org.junit.vintage:junit-vintage-engine:$junitVersion")
 }
diff --git a/codegen/src/main/java/org/web3j/codegen/SolidityFunctionWrapper.java b/codegen/src/main/java/org/web3j/codegen/SolidityFunctionWrapper.java
index bd842c0c7..bfe86fdbb 100644
--- a/codegen/src/main/java/org/web3j/codegen/SolidityFunctionWrapper.java
+++ b/codegen/src/main/java/org/web3j/codegen/SolidityFunctionWrapper.java
@@ -298,7 +298,7 @@ private String getWeb3jVersion() {
 
     private FieldSpec createBinaryDefinition(String binary) {
         return FieldSpec.builder(String.class, BINARY)
-                .addModifiers(Modifier.PRIVATE, Modifier.FINAL, Modifier.STATIC)
+                .addModifiers(Modifier.PUBLIC, Modifier.FINAL, Modifier.STATIC)
                 .initializer("$S", binary)
                 .build();
     }
diff --git a/codegen/src/main/java/org/web3j/codegen/unit/gen/CompilerClassLoader.java b/codegen/src/main/java/org/web3j/codegen/unit/gen/CompilerClassLoader.java
index 4b2d42a10..200f33ab1 100644
--- a/codegen/src/main/java/org/web3j/codegen/unit/gen/CompilerClassLoader.java
+++ b/codegen/src/main/java/org/web3j/codegen/unit/gen/CompilerClassLoader.java
@@ -15,7 +15,6 @@
 import java.io.File;
 import java.io.IOException;
 import java.net.URL;
-import java.net.URLClassLoader;
 import java.nio.file.Files;
 import java.nio.file.Paths;
 import java.util.Arrays;
@@ -55,7 +54,7 @@
 
     private Optional<File> compileClass(final String name) {
 
-        final String path = name.replaceAll("\\.", File.separator);
+        final String path = name.replace(".", File.separator);
         final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
 
         File sourceFile = null;
@@ -93,8 +92,7 @@
     }
 
     private String buildClassPath() {
-        final URL[] systemUrls = ((URLClassLoader) getClass().getClassLoader()).getURLs();
-        return buildClassPath(urls) + ':' + buildClassPath(systemUrls);
+        return buildClassPath(urls) + ':' + System.getProperty("java.class.path");
     }
 
     private String buildClassPath(final URL... urls) {
diff --git a/codegen/src/main/java/org/web3j/codegen/unit/gen/UnitClassGenerator.java b/codegen/src/main/java/org/web3j/codegen/unit/gen/UnitClassGenerator.java
index bfccaf18c..cd168115b 100644
--- a/codegen/src/main/java/org/web3j/codegen/unit/gen/UnitClassGenerator.java
+++ b/codegen/src/main/java/org/web3j/codegen/unit/gen/UnitClassGenerator.java
@@ -24,6 +24,8 @@
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeSpec;
 
+import org.web3j.commons.JavaVersion;
+
 import static org.web3j.codegen.unit.gen.utills.NameUtils.toCamelCase;
 
 /**
@@ -42,12 +44,17 @@ public UnitClassGenerator(final Class theContract, final String packageName, Str
     }
 
     public void writeClass() throws IOException {
-        ClassName EVM_ANNOTATION = ClassName.get("org.web3j", "EVMTest");
 
+        ClassName EVM_ANNOTATION = ClassName.get("org.web3j", "EVMTest");
+        AnnotationSpec.Builder annotationSpec = AnnotationSpec.builder(EVM_ANNOTATION);
+        if (JavaVersion.getJavaVersionAsDouble() < 11) {
+            ClassName GethContainer = ClassName.get("org.web3j", "NodeType");
+            annotationSpec.addMember("value", "type = $T.GETH", GethContainer);
+        }
         TypeSpec testClass =
                 TypeSpec.classBuilder(theContract.getSimpleName() + "Test")
                         .addMethods(generateMethodSpecsForEachTest())
-                        .addAnnotation(AnnotationSpec.builder(EVM_ANNOTATION).build())
+                        .addAnnotation((annotationSpec).build())
                         .addField(
                                 theContract,
                                 toCamelCase(theContract),
diff --git a/codegen/src/test/java/org/web3j/codegen/ContractJsonParseTest.java b/codegen/src/test/java/org/web3j/codegen/ContractJsonParseTest.java
index 6cbd9ef48..17469c253 100644
--- a/codegen/src/test/java/org/web3j/codegen/ContractJsonParseTest.java
+++ b/codegen/src/test/java/org/web3j/codegen/ContractJsonParseTest.java
@@ -61,23 +61,23 @@ public void setUp() throws Exception {
     public void testParseMetaCoin() throws Exception {
         Contract mc = parseContractJson(contractBaseDir, "MetaCoin", "MetaCoin");
 
-        assertEquals("Unexpected contract name", "MetaCoin", mc.getContractName());
+        assertEquals("MetaCoin", mc.getContractName(), "Unexpected contract name");
     }
 
     @Test
     public void testParseConvertLib() throws Exception {
         Contract mc = parseContractJson(contractBaseDir, "MetaCoin", "ConvertLib");
 
-        assertEquals("Unexpected contract name", "ConvertLib", mc.getContractName());
+        assertEquals("ConvertLib", mc.getContractName(), "Unexpected contract name");
         assertEquals(1, mc.abi.size());
         AbiDefinition abi = mc.abi.get(0);
-        assertEquals("Unexpected function name", "convert", abi.getName());
+        assertEquals("convert", abi.getName(), "Unexpected function name");
         assertTrue(abi.isConstant(), "Expected function to be 'constant");
         assertFalse(abi.isPayable(), "Expected function to not be 'payable'");
-        assertEquals("Expected abi to represent a function", "function", abi.getType());
+        assertEquals("function", abi.getType(), "Expected abi to represent a function");
         assertEquals(
-                "Expected the 'pure' for the state mutability setting",
                 "pure",
-                abi.getStateMutability());
+                abi.getStateMutability(),
+                "Expected the 'pure' for the state mutability setting");
     }
 }
diff --git a/codegen/src/test/java/org/web3j/codegen/SolidityFunctionWrapperGeneratorTest.java b/codegen/src/test/java/org/web3j/codegen/SolidityFunctionWrapperGeneratorTest.java
index ae8207aaf..101ca5a97 100644
--- a/codegen/src/test/java/org/web3j/codegen/SolidityFunctionWrapperGeneratorTest.java
+++ b/codegen/src/test/java/org/web3j/codegen/SolidityFunctionWrapperGeneratorTest.java
@@ -26,6 +26,7 @@
 import javax.tools.StandardJavaFileManager;
 import javax.tools.ToolProvider;
 
+import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
 import org.web3j.TempFileProvider;
@@ -46,6 +47,7 @@
     private String solidityBaseDir;
 
     @Override
+    @BeforeEach
     public void setUp() throws Exception {
         super.setUp();
 
diff --git a/codegen/src/test/java/org/web3j/codegen/SolidityFunctionWrapperTest.java b/codegen/src/test/java/org/web3j/codegen/SolidityFunctionWrapperTest.java
index 1da539658..9887d807d 100644
--- a/codegen/src/test/java/org/web3j/codegen/SolidityFunctionWrapperTest.java
+++ b/codegen/src/test/java/org/web3j/codegen/SolidityFunctionWrapperTest.java
@@ -23,6 +23,7 @@
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
+import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
 import org.web3j.TempFileProvider;
@@ -58,6 +59,7 @@
     private GenerationReporter generationReporter;
 
     @Override
+    @BeforeEach
     public void setUp() throws Exception {
         super.setUp();
         generationReporter = mock(GenerationReporter.class);
diff --git a/codegen/src/test/java/org/web3j/codegen/unit/gen/MethodParserTest.java b/codegen/src/test/java/org/web3j/codegen/unit/gen/MethodParserTest.java
index 6da93e786..ee0bf4747 100644
--- a/codegen/src/test/java/org/web3j/codegen/unit/gen/MethodParserTest.java
+++ b/codegen/src/test/java/org/web3j/codegen/unit/gen/MethodParserTest.java
@@ -29,11 +29,11 @@ public void testThatDeployMethodWasGenerated() {
         MethodSpec deployMethodSpec =
                 new MethodParser(deployMethod.get(), greeterContractClass).getMethodSpec();
         assertEquals(
-                deployMethodSpec.toString(),
                 "@org.junit.jupiter.api.BeforeAll\n"
                         + "static void deploy(org.web3j.protocol.Web3j web3j, org.web3j.tx.TransactionManager transactionManager, org.web3j.tx.gas.ContractGasProvider contractGasProvider) throws java.lang.Exception {\n"
-                        + "  greeter = org.com.test.contract.Greeter.deploy(web3j,transactionManager,contractGasProvider,\"REPLACE_ME\" ).send();\n"
-                        + "}\n");
+                        + "  greeter = org.com.test.contract.Greeter.deploy(web3j, transactionManager, contractGasProvider, \"REPLACE_ME\").send();\n"
+                        + "}\n",
+                deployMethodSpec.toString());
     }
 
     @Test
@@ -44,8 +44,8 @@ public void testThatNewGreetingMethodWasGenerated() {
         MethodSpec deployMethodSpec =
                 new MethodParser(deployMethod.get(), greeterContractClass).getMethodSpec();
         assertEquals(
-                deployMethodSpec.code.toString(),
-                "org.web3j.protocol.core.methods.response.TransactionReceipt transactionReceiptVar = greeter.newGreeting(\"REPLACE_ME\" ).send();\n"
-                        + "org.junit.jupiter.api.Assertions.assertTrue(transactionReceiptVar.isStatusOK());\n");
+                "org.web3j.protocol.core.methods.response.TransactionReceipt transactionReceiptVar = greeter.newGreeting(\"REPLACE_ME\").send();\n"
+                        + "org.junit.jupiter.api.Assertions.assertTrue(transactionReceiptVar.isStatusOK());\n",
+                deployMethodSpec.code.toString());
     }
 }
diff --git a/codegen/src/test/java/org/web3j/codegen/unit/gen/ParserUtilsTest.java b/codegen/src/test/java/org/web3j/codegen/unit/gen/ParserUtilsTest.java
index 8b40f64c7..9f24717b7 100644
--- a/codegen/src/test/java/org/web3j/codegen/unit/gen/ParserUtilsTest.java
+++ b/codegen/src/test/java/org/web3j/codegen/unit/gen/ParserUtilsTest.java
@@ -33,7 +33,7 @@ public void testGenerateJavaPoetStringTypesWhenReturnTypeIsContract() {
                         .collect(Collectors.toList())
                         .get(0);
         assertEquals(
-                "$L = $T.deploy($L,$L,$L,$S ).send()",
+                "$L = $T.deploy($L, $L, $L, $S).send()",
                 ParserUtils.generateJavaPoetStringTypes(deploy, greeterContractClass));
     }
 
@@ -46,7 +46,7 @@ public void testGenerateJavaPoetStringTypesWhenReturnTypeIsNotContract() {
                         .collect(Collectors.toList())
                         .get(0);
         assertEquals(
-                "$T $L = $L.newGreeting($S ).send()",
+                "$T $L = $L.newGreeting($S).send()",
                 ParserUtils.generateJavaPoetStringTypes(newGreeting, greeterContractClass));
     }
 
diff --git a/core/src/main/java/org/web3j/protocol/core/Ethereum.java b/core/src/main/java/org/web3j/protocol/core/Ethereum.java
index 81d1e0b46..e3625b916 100644
--- a/core/src/main/java/org/web3j/protocol/core/Ethereum.java
+++ b/core/src/main/java/org/web3j/protocol/core/Ethereum.java
@@ -64,7 +64,8 @@
 import org.web3j.protocol.core.methods.response.ShhVersion;
 import org.web3j.protocol.core.methods.response.Web3ClientVersion;
 import org.web3j.protocol.core.methods.response.Web3Sha3;
-import org.web3j.protocol.core.methods.response.management.AdminNodeInfo;
+import org.web3j.protocol.core.methods.response.admin.AdminNodeInfo;
+import org.web3j.protocol.core.methods.response.admin.AdminPeers;
 
 /** Core Ethereum JSON-RPC API. */
 public interface Ethereum {
@@ -80,6 +81,8 @@
 
     Request<?, AdminNodeInfo> adminNodeInfo();
 
+    Request<?, AdminPeers> adminPeers();
+
     Request<?, EthProtocolVersion> ethProtocolVersion();
 
     Request<?, EthChainId> ethChainId();
diff --git a/core/src/main/java/org/web3j/protocol/core/JsonRpc2_0Web3j.java b/core/src/main/java/org/web3j/protocol/core/JsonRpc2_0Web3j.java
index b25796ccf..3d8fa3ea3 100644
--- a/core/src/main/java/org/web3j/protocol/core/JsonRpc2_0Web3j.java
+++ b/core/src/main/java/org/web3j/protocol/core/JsonRpc2_0Web3j.java
@@ -79,7 +79,8 @@
 import org.web3j.protocol.core.methods.response.ShhVersion;
 import org.web3j.protocol.core.methods.response.Web3ClientVersion;
 import org.web3j.protocol.core.methods.response.Web3Sha3;
-import org.web3j.protocol.core.methods.response.management.AdminNodeInfo;
+import org.web3j.protocol.core.methods.response.admin.AdminNodeInfo;
+import org.web3j.protocol.core.methods.response.admin.AdminPeers;
 import org.web3j.protocol.rx.JsonRpc2_0Rx;
 import org.web3j.protocol.websocket.events.LogNotification;
 import org.web3j.protocol.websocket.events.NewHeadsNotification;
@@ -148,6 +149,12 @@ public JsonRpc2_0Web3j(
                 "admin_nodeInfo", Collections.emptyList(), web3jService, AdminNodeInfo.class);
     }
 
+    @Override
+    public Request<?, AdminPeers> adminPeers() {
+        return new Request<>(
+                "admin_peers", Collections.emptyList(), web3jService, AdminPeers.class);
+    }
+
     @Override
     public Request<?, EthProtocolVersion> ethProtocolVersion() {
         return new Request<>(
diff --git a/core/src/main/java/org/web3j/protocol/core/filters/BlocksFilter.java b/core/src/main/java/org/web3j/protocol/core/filters/BlocksFilter.java
new file mode 100644
index 000000000..a0c3fa3a3
--- /dev/null
+++ b/core/src/main/java/org/web3j/protocol/core/filters/BlocksFilter.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2019 Web3 Labs Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.web3j.protocol.core.filters;
+
+import java.io.IOException;
+import java.math.BigInteger;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Optional;
+
+import org.web3j.protocol.Web3j;
+import org.web3j.protocol.core.Request;
+import org.web3j.protocol.core.methods.response.EthFilter;
+import org.web3j.protocol.core.methods.response.EthLog;
+import org.web3j.protocol.core.methods.response.EthLog.LogResult;
+
+/** Handler hashes for working with block filter requests */
+public class BlocksFilter extends Filter<List<String>> {
+
+    public BlocksFilter(Web3j web3j, Callback<List<String>> callback) {
+        super(web3j, callback);
+    }
+
+    @Override
+    EthFilter sendRequest() throws IOException {
+        return web3j.ethNewBlockFilter().send();
+    }
+
+    @Override
+    void process(List<LogResult> logResults) {
+        List<String> blockHashes = new ArrayList<>(logResults.size());
+
+        for (EthLog.LogResult logResult : logResults) {
+            if (!(logResult instanceof EthLog.Hash)) {
+                throw new FilterException(
+                        "Unexpected result type: " + logResult.get() + ", required Hash");
+            }
+
+            blockHashes.add(((EthLog.Hash) logResult).get());
+        }
+
+        callback.onEvent(blockHashes);
+    }
+
+    /**
+     * Since the block filter does not support historic filters, the filterId is ignored and an
+     * empty optional is returned.
+     *
+     * @param filterId Id of the filter for which the historic log should be retrieved
+     * @return Optional.empty()
+     */
+    @Override
+    protected Optional<Request<?, EthLog>> getFilterLogs(BigInteger filterId) {
+        return Optional.empty();
+    }
+}
diff --git a/core/src/main/java/org/web3j/protocol/core/filters/LogsFilter.java b/core/src/main/java/org/web3j/protocol/core/filters/LogsFilter.java
new file mode 100644
index 000000000..1755c548d
--- /dev/null
+++ b/core/src/main/java/org/web3j/protocol/core/filters/LogsFilter.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2019 Web3 Labs Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.web3j.protocol.core.filters;
+
+import java.io.IOException;
+import java.math.BigInteger;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Optional;
+
+import org.web3j.protocol.Web3j;
+import org.web3j.protocol.core.Request;
+import org.web3j.protocol.core.methods.response.EthFilter;
+import org.web3j.protocol.core.methods.response.EthLog;
+import org.web3j.protocol.core.methods.response.EthLog.LogResult;
+import org.web3j.protocol.core.methods.response.Log;
+
+/** Logs filter handler. */
+public class LogsFilter extends Filter<List<Log>> {
+
+    private final org.web3j.protocol.core.methods.request.EthFilter ethFilter;
+
+    public LogsFilter(
+            Web3j web3j,
+            Callback<List<Log>> callback,
+            org.web3j.protocol.core.methods.request.EthFilter ethFilter) {
+        super(web3j, callback);
+        this.ethFilter = ethFilter;
+    }
+
+    @Override
+    EthFilter sendRequest() throws IOException {
+        return web3j.ethNewFilter(ethFilter).send();
+    }
+
+    @Override
+    void process(List<LogResult> logResults) {
+        List<Log> logs = new ArrayList<>(logResults.size());
+
+        for (EthLog.LogResult logResult : logResults) {
+            if (!(logResult instanceof EthLog.LogObject)) {
+                throw new FilterException(
+                        "Unexpected result type: " + logResult.get() + " required LogObject");
+            }
+
+            logs.add(((EthLog.LogObject) logResult).get());
+        }
+
+        callback.onEvent(logs);
+    }
+
+    @Override
+    protected Optional<Request<?, EthLog>> getFilterLogs(BigInteger filterId) {
+        return Optional.of(web3j.ethGetFilterLogs(filterId));
+    }
+}
diff --git a/core/src/main/java/org/web3j/protocol/core/filters/PendingTransactionsFilter.java b/core/src/main/java/org/web3j/protocol/core/filters/PendingTransactionsFilter.java
new file mode 100644
index 000000000..8775ad950
--- /dev/null
+++ b/core/src/main/java/org/web3j/protocol/core/filters/PendingTransactionsFilter.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2019 Web3 Labs Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.web3j.protocol.core.filters;
+
+import java.io.IOException;
+import java.math.BigInteger;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Optional;
+
+import org.web3j.protocol.Web3j;
+import org.web3j.protocol.core.Request;
+import org.web3j.protocol.core.methods.response.EthFilter;
+import org.web3j.protocol.core.methods.response.EthLog;
+
+/** Handler hashes for working with transaction filter requests. */
+public class PendingTransactionsFilter extends Filter<List<String>> {
+
+    public PendingTransactionsFilter(Web3j web3j, Callback<List<String>> callback) {
+        super(web3j, callback);
+    }
+
+    @Override
+    EthFilter sendRequest() throws IOException {
+        return web3j.ethNewPendingTransactionFilter().send();
+    }
+
+    @Override
+    void process(List<EthLog.LogResult> logResults) {
+        List<String> logs = new ArrayList<>(logResults.size());
+
+        for (EthLog.LogResult logResult : logResults) {
+            if (!(logResult instanceof EthLog.Hash)) {
+                throw new FilterException(
+                        "Unexpected result type: " + logResult.get() + ", required Hash");
+            }
+
+            logs.add(((EthLog.Hash) logResult).get());
+        }
+
+        callback.onEvent(logs);
+    }
+
+    /**
+     * Since the pending transaction filter does not support historic filters, the filterId is
+     * ignored and an empty optional is returned
+     *
+     * @param filterId Id of the filter for which the historic log should be retrieved
+     * @return Optional.empty()
+     */
+    @Override
+    protected Optional<Request<?, EthLog>> getFilterLogs(BigInteger filterId) {
+        return Optional.empty();
+    }
+}
diff --git a/core/src/main/java/org/web3j/protocol/core/methods/response/TransactionReceipt.java b/core/src/main/java/org/web3j/protocol/core/methods/response/TransactionReceipt.java
index 21717837f..97978d131 100644
--- a/core/src/main/java/org/web3j/protocol/core/methods/response/TransactionReceipt.java
+++ b/core/src/main/java/org/web3j/protocol/core/methods/response/TransactionReceipt.java
@@ -34,6 +34,7 @@
     private String to;
     private List<Log> logs;
     private String logsBloom;
+    private String revertReason;
 
     public TransactionReceipt() {}
 
@@ -50,7 +51,8 @@ public TransactionReceipt(
             String from,
             String to,
             List<Log> logs,
-            String logsBloom) {
+            String logsBloom,
+            String revertReason) {
         this.transactionHash = transactionHash;
         this.transactionIndex = transactionIndex;
         this.blockHash = blockHash;
@@ -64,6 +66,7 @@ public TransactionReceipt(
         this.to = to;
         this.logs = logs;
         this.logsBloom = logsBloom;
+        this.revertReason = revertReason;
     }
 
     public String getTransactionHash() {
@@ -194,6 +197,14 @@ public void setLogsBloom(String logsBloom) {
         this.logsBloom = logsBloom;
     }
 
+    public String getRevertReason() {
+        return revertReason;
+    }
+
+    public void setRevertReason(String revertReason) {
+        this.revertReason = revertReason;
+    }
+
     @Override
     public boolean equals(Object o) {
         if (this == o) {
@@ -255,9 +266,14 @@ public boolean equals(Object o) {
         if (getLogs() != null ? !getLogs().equals(that.getLogs()) : that.getLogs() != null) {
             return false;
         }
-        return getLogsBloom() != null
-                ? getLogsBloom().equals(that.getLogsBloom())
-                : that.getLogsBloom() == null;
+        if (getLogsBloom() != null
+                ? !getLogsBloom().equals(that.getLogsBloom())
+                : that.getLogsBloom() != null) {
+            return false;
+        }
+        return getRevertReason() != null
+                ? getRevertReason().equals(that.getRevertReason())
+                : that.getRevertReason() == null;
     }
 
     @Override
@@ -275,6 +291,7 @@ public int hashCode() {
         result = 31 * result + (getTo() != null ? getTo().hashCode() : 0);
         result = 31 * result + (getLogs() != null ? getLogs().hashCode() : 0);
         result = 31 * result + (getLogsBloom() != null ? getLogsBloom().hashCode() : 0);
+        result = 31 * result + (getRevertReason() != null ? getRevertReason().hashCode() : 0);
         return result;
     }
 
@@ -319,6 +336,9 @@ public String toString() {
                 + ", logsBloom='"
                 + logsBloom
                 + '\''
+                + ", revertReason='"
+                + revertReason
+                + '\''
                 + '}';
     }
 }
diff --git a/core/src/main/java/org/web3j/protocol/core/methods/response/management/AdminNodeInfo.java b/core/src/main/java/org/web3j/protocol/core/methods/response/admin/AdminNodeInfo.java
similarity index 51%
rename from core/src/main/java/org/web3j/protocol/core/methods/response/management/AdminNodeInfo.java
rename to core/src/main/java/org/web3j/protocol/core/methods/response/admin/AdminNodeInfo.java
index dfa83b1b5..bf8de6c1a 100644
--- a/core/src/main/java/org/web3j/protocol/core/methods/response/management/AdminNodeInfo.java
+++ b/core/src/main/java/org/web3j/protocol/core/methods/response/admin/AdminNodeInfo.java
@@ -10,48 +10,81 @@
  * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
  * specific language governing permissions and limitations under the License.
  */
-package org.web3j.protocol.core.methods.response.management;
+package org.web3j.protocol.core.methods.response.admin;
 
 import java.io.IOException;
 
 import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
 import com.fasterxml.jackson.core.JsonParser;
-import com.fasterxml.jackson.core.TreeNode;
+import com.fasterxml.jackson.core.JsonToken;
 import com.fasterxml.jackson.databind.DeserializationContext;
 import com.fasterxml.jackson.databind.JsonDeserializer;
+import com.fasterxml.jackson.databind.ObjectReader;
 import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
 
+import org.web3j.protocol.ObjectMapperFactory;
 import org.web3j.protocol.core.Response;
 
-/** net_peerCount. */
-public class AdminNodeInfo extends Response<AdminNodeInfo.Result> {
+/** admin_nodeInfo. */
+public class AdminNodeInfo extends Response<AdminNodeInfo.NodeInfo> {
     @JsonIgnoreProperties(ignoreUnknown = true)
     @Override
     @JsonDeserialize(using = AdminNodeInfo.ResponseDeserialiser.class)
-    public void setResult(AdminNodeInfo.Result result) {
+    public void setResult(NodeInfo result) {
         super.setResult(result);
     }
 
-    public static class Result {
-        public String getName() {
-            return name;
-        }
-
+    public static class NodeInfo {
+        private String enode;
+        private String id;
+        private String ip;
+        private String listenAddr;
         private String name;
 
-        Result(String name) {
+        public NodeInfo() {}
+
+        public NodeInfo(String enode, String id, String ip, String listenAddr, String name) {
+            this.enode = enode;
+            this.id = id;
+            this.ip = ip;
+            this.listenAddr = listenAddr;
             this.name = name;
         }
+
+        public String getEnode() {
+            return enode;
+        }
+
+        public String getId() {
+            return id;
+        }
+
+        public String getIp() {
+            return ip;
+        }
+
+        public String getListenAddr() {
+            return listenAddr;
+        }
+
+        public String getName() {
+            return name;
+        }
     }
 
-    public static class ResponseDeserialiser extends JsonDeserializer<AdminNodeInfo.Result> {
+    public static class ResponseDeserialiser extends JsonDeserializer<NodeInfo> {
+
+        private ObjectReader objectReader = ObjectMapperFactory.getObjectReader();
 
         @Override
-        public AdminNodeInfo.Result deserialize(
+        public NodeInfo deserialize(
                 JsonParser jsonParser, DeserializationContext deserializationContext)
                 throws IOException {
-            TreeNode treeNode = jsonParser.readValueAsTree();
-            return new Result(treeNode.at("/name").toString().replaceAll("^\"|\"$", ""));
+            if (jsonParser.getCurrentToken() != JsonToken.VALUE_NULL) {
+                return objectReader.readValue(jsonParser, NodeInfo.class);
+            } else {
+                return null; // null is wrapped by Optional in above getter
+            }
         }
     }
 }
diff --git a/core/src/main/java/org/web3j/protocol/core/methods/response/admin/AdminPeers.java b/core/src/main/java/org/web3j/protocol/core/methods/response/admin/AdminPeers.java
new file mode 100644
index 000000000..ae70ba3e7
--- /dev/null
+++ b/core/src/main/java/org/web3j/protocol/core/methods/response/admin/AdminPeers.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright 2019 Web3 Labs Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.web3j.protocol.core.methods.response.admin;
+
+import java.io.IOException;
+import java.util.List;
+
+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.JsonToken;
+import com.fasterxml.jackson.core.type.TypeReference;
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.JsonDeserializer;
+import com.fasterxml.jackson.databind.ObjectReader;
+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
+
+import org.web3j.protocol.ObjectMapperFactory;
+import org.web3j.protocol.core.Response;
+
+/** admin_peers. */
+public class AdminPeers extends Response<List<AdminPeers.Peer>> {
+    @JsonIgnoreProperties(ignoreUnknown = true)
+    @Override
+    @JsonDeserialize(using = AdminPeers.ResponseDeserialiser.class)
+    public void setResult(List<Peer> result) {
+        super.setResult(result);
+    }
+
+    public static class Peer {
+        public Peer() {}
+
+        public Peer(String id, String name, PeerNetwork network) {
+            this.id = id;
+            this.name = name;
+            this.network = network;
+        }
+
+        public String getId() {
+            return id;
+        }
+
+        public String getName() {
+            return name;
+        }
+
+        private String id;
+        private String name;
+        private PeerNetwork network;
+
+        public PeerNetwork getNetwork() {
+            return network;
+        }
+    }
+
+    public static class PeerNetwork {
+
+        public PeerNetwork() {}
+
+        private String localAddress;
+        private String remoteAddress;
+
+        public PeerNetwork(String localAddress, String remoteAddress) {
+            this.localAddress = localAddress;
+            this.remoteAddress = remoteAddress;
+        }
+
+        public String getLocalAddress() {
+            return localAddress;
+        }
+
+        public String getRemoteAddress() {
+            return remoteAddress;
+        }
+    }
+
+    public static class ResponseDeserialiser extends JsonDeserializer<List<Peer>> {
+
+        private ObjectReader objectReader = ObjectMapperFactory.getObjectReader();
+
+        @Override
+        public List<Peer> deserialize(
+                JsonParser jsonParser, DeserializationContext deserializationContext)
+                throws IOException {
+            if (jsonParser.getCurrentToken() != JsonToken.VALUE_NULL) {
+                return objectReader.readValue(jsonParser, new TypeReference<List<Peer>>() {});
+            } else {
+                return null; // null is wrapped by Optional in above getter
+            }
+        }
+    }
+}
diff --git a/core/src/main/java/org/web3j/protocol/exceptions/TransactionException.java b/core/src/main/java/org/web3j/protocol/exceptions/TransactionException.java
index 8faa50d4a..ac9021edf 100644
--- a/core/src/main/java/org/web3j/protocol/exceptions/TransactionException.java
+++ b/core/src/main/java/org/web3j/protocol/exceptions/TransactionException.java
@@ -14,6 +14,8 @@
 
 import java.util.Optional;
 
+import org.web3j.protocol.core.methods.response.TransactionReceipt;
+
 /**
  * Transaction timeout exception indicates that we have breached some threshold waiting for a
  * transaction to execute.
@@ -21,6 +23,7 @@
 public class TransactionException extends Exception {
 
     private Optional<String> transactionHash = Optional.empty();
+    private Optional<TransactionReceipt> transactionReceipt = Optional.empty();
 
     public TransactionException(String message) {
         super(message);
@@ -31,6 +34,11 @@ public TransactionException(String message, String transactionHash) {
         this.transactionHash = Optional.ofNullable(transactionHash);
     }
 
+    public TransactionException(String message, TransactionReceipt transactionReceipt) {
+        super(message);
+        this.transactionReceipt = Optional.ofNullable(transactionReceipt);
+    }
+
     public TransactionException(Throwable cause) {
         super(cause);
     }
@@ -43,4 +51,13 @@ public TransactionException(Throwable cause) {
     public Optional<String> getTransactionHash() {
         return transactionHash;
     }
+
+    /**
+     * Obtain the transaction receipt.
+     *
+     * @return optional transaction receipt.
+     */
+    public Optional<TransactionReceipt> getTransactionReceipt() {
+        return transactionReceipt;
+    }
 }
diff --git a/core/src/main/java/org/web3j/protocol/http/HttpService.java b/core/src/main/java/org/web3j/protocol/http/HttpService.java
index 7caa107b8..bab13e4fc 100644
--- a/core/src/main/java/org/web3j/protocol/http/HttpService.java
+++ b/core/src/main/java/org/web3j/protocol/http/HttpService.java
@@ -151,7 +151,7 @@ private static void configureLogging(OkHttpClient.Builder builder) {
     @Override
     protected InputStream performIO(String request) throws IOException {
 
-        RequestBody requestBody = RequestBody.create(JSON_MEDIA_TYPE, request);
+        RequestBody requestBody = RequestBody.create(request, JSON_MEDIA_TYPE);
         Headers headers = buildHeaders();
 
         okhttp3.Request httpRequest =
diff --git a/core/src/main/java/org/web3j/tx/ClientTransactionManager.java b/core/src/main/java/org/web3j/tx/ClientTransactionManager.java
index 33a8fa640..684108964 100644
--- a/core/src/main/java/org/web3j/tx/ClientTransactionManager.java
+++ b/core/src/main/java/org/web3j/tx/ClientTransactionManager.java
@@ -18,6 +18,7 @@
 import org.web3j.protocol.Web3j;
 import org.web3j.protocol.core.DefaultBlockParameter;
 import org.web3j.protocol.core.methods.request.Transaction;
+import org.web3j.protocol.core.methods.response.EthCall;
 import org.web3j.protocol.core.methods.response.EthGetCode;
 import org.web3j.protocol.core.methods.response.EthSendTransaction;
 import org.web3j.tx.response.TransactionReceiptProcessor;
@@ -69,11 +70,14 @@ public EthSendTransaction sendTransaction(
     @Override
     public String sendCall(String to, String data, DefaultBlockParameter defaultBlockParameter)
             throws IOException {
-        return web3j.ethCall(
-                        Transaction.createEthCallTransaction(getFromAddress(), to, data),
-                        defaultBlockParameter)
-                .send()
-                .getValue();
+        EthCall ethCall =
+                web3j.ethCall(
+                                Transaction.createEthCallTransaction(getFromAddress(), to, data),
+                                defaultBlockParameter)
+                        .send();
+
+        assertCallNotReverted(ethCall);
+        return ethCall.getValue();
     }
 
     @Override
diff --git a/core/src/main/java/org/web3j/tx/Contract.java b/core/src/main/java/org/web3j/tx/Contract.java
index 2cda137e7..6235f3c1e 100644
--- a/core/src/main/java/org/web3j/tx/Contract.java
+++ b/core/src/main/java/org/web3j/tx/Contract.java
@@ -48,6 +48,8 @@
 import org.web3j.tx.gas.StaticGasProvider;
 import org.web3j.utils.Numeric;
 
+import static org.web3j.utils.RevertReasonExtractor.extractRevertReason;
+
 /**
  * Solidity contract type abstraction for interacting with smart contracts via native Java types.
  */
@@ -370,12 +372,16 @@ TransactionReceipt executeTransaction(
         if (!receipt.isStatusOK()) {
             throw new TransactionException(
                     String.format(
-                            "Transaction has failed with status: %s. "
-                                    + "Gas used: %s. (not-enough gas?)",
+                            "Transaction %s has failed with status: %s. "
+                                    + "Gas used: %s. "
+                                    + "Revert reason: '%s'.",
+                            receipt.getTransactionHash(),
                             receipt.getStatus(),
                             receipt.getGasUsedRaw() != null
                                     ? receipt.getGasUsed().toString()
-                                    : "unknown"));
+                                    : "unknown",
+                            extractRevertReason(receipt, data, web3j, true)),
+                    receipt);
         }
         return receipt;
     }
diff --git a/core/src/main/java/org/web3j/tx/RawTransactionManager.java b/core/src/main/java/org/web3j/tx/RawTransactionManager.java
index 67b56c4db..689cbe5aa 100644
--- a/core/src/main/java/org/web3j/tx/RawTransactionManager.java
+++ b/core/src/main/java/org/web3j/tx/RawTransactionManager.java
@@ -23,6 +23,7 @@
 import org.web3j.protocol.core.DefaultBlockParameter;
 import org.web3j.protocol.core.DefaultBlockParameterName;
 import org.web3j.protocol.core.methods.request.Transaction;
+import org.web3j.protocol.core.methods.response.EthCall;
 import org.web3j.protocol.core.methods.response.EthGetCode;
 import org.web3j.protocol.core.methods.response.EthGetTransactionCount;
 import org.web3j.protocol.core.methods.response.EthSendTransaction;
@@ -127,11 +128,14 @@ public EthSendTransaction sendTransaction(
     @Override
     public String sendCall(String to, String data, DefaultBlockParameter defaultBlockParameter)
             throws IOException {
-        return web3j.ethCall(
-                        Transaction.createEthCallTransaction(getFromAddress(), to, data),
-                        defaultBlockParameter)
-                .send()
-                .getValue();
+        EthCall ethCall =
+                web3j.ethCall(
+                                Transaction.createEthCallTransaction(getFromAddress(), to, data),
+                                defaultBlockParameter)
+                        .send();
+
+        assertCallNotReverted(ethCall);
+        return ethCall.getValue();
     }
 
     @Override
diff --git a/core/src/main/java/org/web3j/tx/ReadonlyTransactionManager.java b/core/src/main/java/org/web3j/tx/ReadonlyTransactionManager.java
index eee1ce5cf..4906697f9 100644
--- a/core/src/main/java/org/web3j/tx/ReadonlyTransactionManager.java
+++ b/core/src/main/java/org/web3j/tx/ReadonlyTransactionManager.java
@@ -18,6 +18,7 @@
 import org.web3j.protocol.Web3j;
 import org.web3j.protocol.core.DefaultBlockParameter;
 import org.web3j.protocol.core.methods.request.Transaction;
+import org.web3j.protocol.core.methods.response.EthCall;
 import org.web3j.protocol.core.methods.response.EthGetCode;
 import org.web3j.protocol.core.methods.response.EthSendTransaction;
 
@@ -48,11 +49,14 @@ public EthSendTransaction sendTransaction(
     @Override
     public String sendCall(String to, String data, DefaultBlockParameter defaultBlockParameter)
             throws IOException {
-        return web3j.ethCall(
-                        Transaction.createEthCallTransaction(fromAddress, to, data),
-                        defaultBlockParameter)
-                .send()
-                .getValue();
+        EthCall ethCall =
+                web3j.ethCall(
+                                Transaction.createEthCallTransaction(fromAddress, to, data),
+                                defaultBlockParameter)
+                        .send();
+
+        assertCallNotReverted(ethCall);
+        return ethCall.getValue();
     }
 
     @Override
diff --git a/core/src/main/java/org/web3j/tx/TransactionManager.java b/core/src/main/java/org/web3j/tx/TransactionManager.java
index 71d5405e7..8762db778 100644
--- a/core/src/main/java/org/web3j/tx/TransactionManager.java
+++ b/core/src/main/java/org/web3j/tx/TransactionManager.java
@@ -17,10 +17,12 @@
 
 import org.web3j.protocol.Web3j;
 import org.web3j.protocol.core.DefaultBlockParameter;
+import org.web3j.protocol.core.methods.response.EthCall;
 import org.web3j.protocol.core.methods.response.EthGetCode;
 import org.web3j.protocol.core.methods.response.EthSendTransaction;
 import org.web3j.protocol.core.methods.response.TransactionReceipt;
 import org.web3j.protocol.exceptions.TransactionException;
+import org.web3j.tx.exceptions.ContractCallException;
 import org.web3j.tx.response.PollingTransactionReceiptProcessor;
 import org.web3j.tx.response.TransactionReceiptProcessor;
 
@@ -34,6 +36,8 @@
 
     public static final int DEFAULT_POLLING_ATTEMPTS_PER_TX_HASH = 40;
     public static final long DEFAULT_POLLING_FREQUENCY = DEFAULT_BLOCK_TIME;
+    public static final String REVERT_ERR_STR =
+            "Contract Call has been reverted by the EVM with the reason: '%s'.";
 
     private final TransactionReceiptProcessor transactionReceiptProcessor;
     private final String fromAddress;
@@ -114,4 +118,11 @@ private TransactionReceipt processResponse(EthSendTransaction transactionRespons
 
         return transactionReceiptProcessor.waitForTransactionReceipt(transactionHash);
     }
+
+    static void assertCallNotReverted(EthCall ethCall) {
+        if (ethCall.isReverted()) {
+            throw new ContractCallException(
+                    String.format(REVERT_ERR_STR, ethCall.getRevertReason()));
+        }
+    }
 }
diff --git a/core/src/main/java/org/web3j/utils/RevertReasonExtractor.java b/core/src/main/java/org/web3j/utils/RevertReasonExtractor.java
new file mode 100644
index 000000000..efbc0f995
--- /dev/null
+++ b/core/src/main/java/org/web3j/utils/RevertReasonExtractor.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2019 Web3 Labs Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.web3j.utils;
+
+import java.io.IOException;
+
+import org.web3j.protocol.Web3j;
+import org.web3j.protocol.core.DefaultBlockParameter;
+import org.web3j.protocol.core.methods.request.Transaction;
+import org.web3j.protocol.core.methods.response.TransactionReceipt;
+
+/** Revert reason extraction and retrieval functions. */
+public class RevertReasonExtractor {
+
+    public static final String MISSING_REASON = "N/A";
+
+    /**
+     * Extracts the error reason of a reverted transaction (if one exists and enabled).
+     *
+     * @param transactionReceipt the reverted transaction receipt
+     * @param data the reverted transaction data
+     * @param web3j Web3j instance
+     * @param revertReasonCallEnabled flag of reason retrieval via additional call
+     * @return the reverted transaction error reason if exists or null otherwise
+     * @throws IOException if the call to the node fails
+     */
+    public static String extractRevertReason(
+            TransactionReceipt transactionReceipt,
+            String data,
+            Web3j web3j,
+            Boolean revertReasonCallEnabled)
+            throws IOException {
+
+        if (transactionReceipt.getRevertReason() != null) {
+            return transactionReceipt.getRevertReason();
+        } else if (revertReasonCallEnabled) {
+            String revertReason = retrieveRevertReason(transactionReceipt, data, web3j);
+            if (revertReason != null) {
+                transactionReceipt.setRevertReason(revertReason);
+                return revertReason;
+            }
+        }
+        return MISSING_REASON;
+    }
+
+    /**
+     * Retrieves the error reason of a reverted transaction (if one exists).
+     *
+     * @param transactionReceipt the reverted transaction receipt
+     * @param data the reverted transaction data
+     * @param web3j Web3j instance
+     * @return the reverted transaction error reason if exists or null otherwise
+     * @throws IOException if the call to the node fails
+     */
+    public static String retrieveRevertReason(
+            TransactionReceipt transactionReceipt, String data, Web3j web3j) throws IOException {
+
+        if (transactionReceipt.getBlockNumber() == null) {
+            return null;
+        }
+        return web3j.ethCall(
+                        Transaction.createEthCallTransaction(
+                                transactionReceipt.getFrom(), transactionReceipt.getTo(), data),
+                        DefaultBlockParameter.valueOf(transactionReceipt.getBlockNumber()))
+                .send()
+                .getRevertReason();
+    }
+}
diff --git a/core/src/test/java/org/web3j/crypto/WalletTest.java b/core/src/test/java/org/web3j/crypto/WalletTest.java
index 96f764213..3633f2bcf 100644
--- a/core/src/test/java/org/web3j/crypto/WalletTest.java
+++ b/core/src/test/java/org/web3j/crypto/WalletTest.java
@@ -19,6 +19,7 @@
 
 import org.web3j.utils.Numeric;
 
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class WalletTest {
@@ -67,7 +68,7 @@ public void testDecryptScrypt() throws Exception {
 
     @Test
     public void testGenerateRandomBytes() {
-        assertEquals(Wallet.generateRandomBytes(0), (new byte[] {}));
+        assertArrayEquals(Wallet.generateRandomBytes(0), (new byte[] {}));
         assertEquals(Wallet.generateRandomBytes(10).length, (10));
     }
 
diff --git a/core/src/test/java/org/web3j/protocol/RequestTester.java b/core/src/test/java/org/web3j/protocol/RequestTester.java
index c3f56b2fd..0f51829ac 100644
--- a/core/src/test/java/org/web3j/protocol/RequestTester.java
+++ b/core/src/test/java/org/web3j/protocol/RequestTester.java
@@ -15,10 +15,12 @@
 import java.io.IOException;
 
 import okhttp3.Interceptor;
+import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
 import okhttp3.Protocol;
 import okhttp3.Request;
 import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
 import okio.Buffer;
 import org.junit.jupiter.api.BeforeEach;
 
@@ -31,7 +33,8 @@
 
     private OkHttpClient httpClient;
     private HttpService httpService;
-
+    public static final MediaType JSON_MEDIA_TYPE =
+            MediaType.parse("application/json; charset=utf-8");
     private RequestInterceptor requestInterceptor;
 
     @BeforeEach
@@ -67,12 +70,16 @@ private String replaceRequestId(String json) {
 
             Request request = chain.request();
             this.requestBody = request.body();
-
             okhttp3.Response response =
                     new okhttp3.Response.Builder()
                             .request(chain.request())
                             .protocol(Protocol.HTTP_2)
                             .code(200)
+                            .body(
+                                    ResponseBody.create(
+                                            "{\"jsonrpc\":\"2.0\",\"method\":\"\","
+                                                    + "\"params\":[],\"id\":1}",
+                                            JSON_MEDIA_TYPE))
                             .message("")
                             .build();
 
diff --git a/core/src/test/java/org/web3j/protocol/core/ResponseTest.java b/core/src/test/java/org/web3j/protocol/core/ResponseTest.java
index 5824b71db..21d687ae6 100644
--- a/core/src/test/java/org/web3j/protocol/core/ResponseTest.java
+++ b/core/src/test/java/org/web3j/protocol/core/ResponseTest.java
@@ -79,7 +79,7 @@
 import org.web3j.protocol.core.methods.response.TransactionReceipt;
 import org.web3j.protocol.core.methods.response.Web3ClientVersion;
 import org.web3j.protocol.core.methods.response.Web3Sha3;
-import org.web3j.protocol.core.methods.response.management.AdminNodeInfo;
+import org.web3j.protocol.core.methods.response.admin.AdminNodeInfo;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
@@ -1028,7 +1028,8 @@ public void testeEthGetTransactionReceiptBeforeByzantium() {
                                         "mined",
                                         Arrays.asList(
                                                 "0x59ebeb90bc63057b6515673c3ecf9438e5058bca0f92585014eced636878c9a5"))),
-                        "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
+                        "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
+                        null);
 
         EthGetTransactionReceipt ethGetTransactionReceipt =
                 deserialiseResponse(EthGetTransactionReceipt.class);
@@ -1095,7 +1096,8 @@ public void testeEthGetTransactionReceiptAfterByzantium() {
                                         "mined",
                                         Arrays.asList(
                                                 "0x59ebeb90bc63057b6515673c3ecf9438e5058bca0f92585014eced636878c9a5"))),
-                        "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
+                        "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
+                        null);
 
         EthGetTransactionReceipt ethGetTransactionReceipt =
                 deserialiseResponse(EthGetTransactionReceipt.class);
diff --git a/core/src/test/java/org/web3j/protocol/http/HttpServiceTest.java b/core/src/test/java/org/web3j/protocol/http/HttpServiceTest.java
index c4ae1fa5c..36f66352a 100644
--- a/core/src/test/java/org/web3j/protocol/http/HttpServiceTest.java
+++ b/core/src/test/java/org/web3j/protocol/http/HttpServiceTest.java
@@ -73,7 +73,7 @@ public void httpWebException() throws IOException {
                 new Response.Builder()
                         .code(400)
                         .message("")
-                        .body(ResponseBody.create(null, content))
+                        .body(ResponseBody.create(content, null))
                         .request(new okhttp3.Request.Builder().url(HttpService.DEFAULT_URL).build())
                         .protocol(Protocol.HTTP_1_1)
                         .build();
diff --git a/core/src/test/java/org/web3j/tx/ContractTest.java b/core/src/test/java/org/web3j/tx/ContractTest.java
index 5bc561c13..5975292a3 100644
--- a/core/src/test/java/org/web3j/tx/ContractTest.java
+++ b/core/src/test/java/org/web3j/tx/ContractTest.java
@@ -36,10 +36,7 @@
 import org.web3j.crypto.Credentials;
 import org.web3j.crypto.SampleKeys;
 import org.web3j.protocol.Web3j;
-import org.web3j.protocol.core.DefaultBlockParameterName;
-import org.web3j.protocol.core.RemoteCall;
-import org.web3j.protocol.core.Request;
-import org.web3j.protocol.core.Response;
+import org.web3j.protocol.core.*;
 import org.web3j.protocol.core.methods.request.Transaction;
 import org.web3j.protocol.core.methods.response.EthCall;
 import org.web3j.protocol.core.methods.response.EthGetCode;
@@ -48,6 +45,7 @@
 import org.web3j.protocol.core.methods.response.Log;
 import org.web3j.protocol.core.methods.response.TransactionReceipt;
 import org.web3j.protocol.exceptions.TransactionException;
+import org.web3j.tx.exceptions.ContractCallException;
 import org.web3j.tx.gas.ContractGasProvider;
 import org.web3j.tx.gas.DefaultGasProvider;
 import org.web3j.tx.gas.StaticGasProvider;
@@ -75,6 +73,24 @@
 
     private static final String TEST_CONTRACT_BINARY = "12345";
 
+    private static final String TXN_SUCCESS_STATUS = "0x1";
+
+    private static final String TXN_FAIL_STATUS = "0x0";
+
+    private static final String TXN_GAS_USED = "0x1";
+
+    private static final String TXN_BLOCK_NUM = "0x2";
+
+    private static final String OWNER_REVERT_MSG_STR =
+            "Only the contract owner can perform this action";
+
+    private static final String OWNER_REVERT_MSG_HASH =
+            "0x08c379a"
+                    + "00000000000000000000000000000000000000000000000000000000000000020"
+                    + "000000000000000000000000000000000000000000000000000000000000002f4"
+                    + "f6e6c792074686520636f6e7472616374206f776e65722063616e20706572666f"
+                    + "726d207468697320616374696f6e0000000000000000000000000000000000";
+
     private TestContract contract;
 
     @BeforeEach
@@ -110,8 +126,9 @@ public void testDeploy() throws Exception {
     }
 
     @Test
-    public void testContractDeployFails() {
+    public void testContractDeployFails() throws IOException {
         TransactionReceipt transactionReceipt = createFailedTransactionReceipt();
+        prepareCall(null);
         assertThrows(TransactionException.class, () -> deployContract(transactionReceipt));
     }
 
@@ -201,11 +218,9 @@ public void testDeployInvalidContractAddress() throws Throwable {
     public void testCallSingleValue() throws Exception {
         // Example taken from FunctionReturnDecoderTest
 
-        EthCall ethCall = new EthCall();
-        ethCall.setResult(
+        prepareCall(
                 "0x0000000000000000000000000000000000000000000000000000000000000020"
                         + "0000000000000000000000000000000000000000000000000000000000000000");
-        prepareCall(ethCall);
 
         assertEquals(new Utf8String(""), contract.callSingleValue().send());
     }
@@ -214,20 +229,27 @@ public void testCallSingleValue() throws Exception {
     public void testCallSingleValueEmpty() throws Exception {
         // Example taken from FunctionReturnDecoderTest
 
-        EthCall ethCall = new EthCall();
-        ethCall.setResult("0x");
-        prepareCall(ethCall);
+        prepareCall("0x");
 
         assertNull(contract.callSingleValue().send());
     }
 
+    @Test
+    public void testCallSingleValueReverted() throws Exception {
+        prepareCall(OWNER_REVERT_MSG_HASH);
+        ContractCallException thrown =
+                assertThrows(ContractCallException.class, () -> contract.callSingleValue().send());
+
+        assertEquals(
+                String.format(TransactionManager.REVERT_ERR_STR, OWNER_REVERT_MSG_STR),
+                thrown.getMessage());
+    }
+
     @Test
     public void testCallMultipleValue() throws Exception {
-        EthCall ethCall = new EthCall();
-        ethCall.setResult(
+        prepareCall(
                 "0x0000000000000000000000000000000000000000000000000000000000000037"
                         + "0000000000000000000000000000000000000000000000000000000000000007");
-        prepareCall(ethCall);
 
         assertEquals(
                 Arrays.asList(
@@ -237,19 +259,20 @@ public void testCallMultipleValue() throws Exception {
 
     @Test
     public void testCallMultipleValueEmpty() throws Exception {
-        EthCall ethCall = new EthCall();
-        ethCall.setResult("0x");
-        prepareCall(ethCall);
+        prepareCall("0x");
 
         assertEquals(emptyList(), contract.callMultipleValue().send());
     }
 
     @SuppressWarnings("unchecked")
-    private void prepareCall(EthCall ethCall) throws IOException {
+    private void prepareCall(String result) throws IOException {
+        EthCall ethCall = new EthCall();
+        ethCall.setResult(result);
+
         Request<?, EthCall> request = mock(Request.class);
         when(request.send()).thenReturn(ethCall);
 
-        when(web3j.ethCall(any(Transaction.class), eq(DefaultBlockParameterName.LATEST)))
+        when(web3j.ethCall(any(Transaction.class), any(DefaultBlockParameter.class)))
                 .thenReturn((Request) request);
     }
 
@@ -257,7 +280,7 @@ private void prepareCall(EthCall ethCall) throws IOException {
     public void testTransaction() throws Exception {
         TransactionReceipt transactionReceipt = new TransactionReceipt();
         transactionReceipt.setTransactionHash(TRANSACTION_HASH);
-        transactionReceipt.setStatus("0x1");
+        transactionReceipt.setStatus(TXN_SUCCESS_STATUS);
 
         prepareTransaction(transactionReceipt);
 
@@ -269,11 +292,10 @@ public void testTransaction() throws Exception {
     }
 
     @Test
-    public void testTransactionFailed() {
-        TransactionReceipt transactionReceipt = new TransactionReceipt();
-        transactionReceipt.setTransactionHash(TRANSACTION_HASH);
-        transactionReceipt.setStatus("0x0");
-        transactionReceipt.setGasUsed("0x1");
+    public void testTransactionFailed() throws IOException {
+        TransactionReceipt transactionReceipt = createFailedTransactionReceipt();
+        prepareCall(null);
+
         assertThrows(
                 TransactionException.class,
                 () -> {
@@ -285,6 +307,31 @@ public void testTransactionFailed() {
                 });
     }
 
+    @Test
+    public void testTransactionFailedWithRevertReason() throws Exception {
+        TransactionReceipt transactionReceipt = createFailedTransactionReceipt();
+        prepareCall(OWNER_REVERT_MSG_HASH);
+
+        TransactionException thrown =
+                assertThrows(
+                        TransactionException.class,
+                        () -> {
+                            prepareTransaction(transactionReceipt);
+
+                            contract.performTransaction(
+                                            new Address(BigInteger.TEN),
+                                            new Uint256(BigInteger.ONE))
+                                    .send();
+                        });
+
+        assertEquals(
+                String.format(
+                        "Transaction %s has failed with status: %s. Gas used: 1. Revert reason: '%s'.",
+                        TRANSACTION_HASH, TXN_FAIL_STATUS, OWNER_REVERT_MSG_STR),
+                thrown.getMessage());
+        assertEquals(transactionReceipt, thrown.getTransactionReceipt().get());
+    }
+
     @Test
     public void testProcessEvent() {
         TransactionReceipt transactionReceipt = new TransactionReceipt();
@@ -466,11 +513,11 @@ void testErrorScenario() throws Throwable {
     }
 
     private TransactionReceipt createTransactionReceipt() {
-        return createTransactionReceiptWithStatus("0x1");
+        return createTransactionReceiptWithStatus(TXN_SUCCESS_STATUS);
     }
 
     private TransactionReceipt createFailedTransactionReceipt() {
-        return createTransactionReceiptWithStatus("0x0");
+        return createTransactionReceiptWithStatus(TXN_FAIL_STATUS);
     }
 
     private TransactionReceipt createTransactionReceiptWithStatus(String status) {
@@ -478,7 +525,8 @@ private TransactionReceipt createTransactionReceiptWithStatus(String status) {
         transactionReceipt.setTransactionHash(TRANSACTION_HASH);
         transactionReceipt.setContractAddress(ADDRESS);
         transactionReceipt.setStatus(status);
-        transactionReceipt.setGasUsed("0x1");
+        transactionReceipt.setGasUsed(TXN_GAS_USED);
+        transactionReceipt.setBlockNumber(TXN_BLOCK_NUM);
         return transactionReceipt;
     }
 
diff --git a/core/src/test/java/org/web3j/tx/ReadonlyTransactionManagerTest.java b/core/src/test/java/org/web3j/tx/ReadonlyTransactionManagerTest.java
index 816c42f9a..2a70b4d42 100644
--- a/core/src/test/java/org/web3j/tx/ReadonlyTransactionManagerTest.java
+++ b/core/src/test/java/org/web3j/tx/ReadonlyTransactionManagerTest.java
@@ -21,15 +21,20 @@
 import org.web3j.protocol.Web3jService;
 import org.web3j.protocol.core.DefaultBlockParameter;
 import org.web3j.protocol.core.methods.response.EthCall;
+import org.web3j.tx.exceptions.ContractCallException;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
+import static org.web3j.tx.TransactionManager.REVERT_ERR_STR;
 
 public class ReadonlyTransactionManagerTest {
 
+    private static final String OWNER_REVERT_MSG_STR =
+            "Only the contract owner can perform this action";
+
     Web3jService service = mock(Web3jService.class);
     Web3j web3j = Web3j.build(service);
     DefaultBlockParameter defaultBlockParameter = mock(DefaultBlockParameter.class);
@@ -45,6 +50,23 @@ public void sendCallTest() throws IOException {
         assertEquals("test", value);
     }
 
+    @Test
+    public void sendCallRevertedTest() throws IOException {
+        when(response.isReverted()).thenReturn(true);
+        when(response.getRevertReason()).thenReturn(OWNER_REVERT_MSG_STR);
+        when(service.send(any(), any())).thenReturn(response);
+
+        ReadonlyTransactionManager readonlyTransactionManager =
+                new ReadonlyTransactionManager(web3j, "");
+
+        ContractCallException thrown =
+                assertThrows(
+                        ContractCallException.class,
+                        () -> readonlyTransactionManager.sendCall("", "", defaultBlockParameter));
+
+        assertEquals(String.format(REVERT_ERR_STR, OWNER_REVERT_MSG_STR), thrown.getMessage());
+    }
+
     @Test
     public void testSendTransaction() {
         ReadonlyTransactionManager readonlyTransactionManager =
diff --git a/core/src/test/java/org/web3j/utils/CollectionTest.java b/core/src/test/java/org/web3j/utils/CollectionTest.java
index f23c0baa3..325817eff 100644
--- a/core/src/test/java/org/web3j/utils/CollectionTest.java
+++ b/core/src/test/java/org/web3j/utils/CollectionTest.java
@@ -17,6 +17,7 @@
 
 import org.junit.jupiter.api.Test;
 
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.web3j.utils.Collection.EMPTY_STRING_ARRAY;
 import static org.web3j.utils.Collection.Function;
@@ -28,16 +29,16 @@
 
     @Test
     public void testTail() {
-        assertEquals(tail(EMPTY_STRING_ARRAY), (EMPTY_STRING_ARRAY));
-        assertEquals(tail(create("a", "b", "c")), (create("b", "c")));
-        assertEquals(tail(create("a")), (EMPTY_STRING_ARRAY));
+        assertArrayEquals(tail(EMPTY_STRING_ARRAY), (EMPTY_STRING_ARRAY));
+        assertArrayEquals(tail(create("a", "b", "c")), (create("b", "c")));
+        assertArrayEquals(tail(create("a")), (EMPTY_STRING_ARRAY));
     }
 
     @Test
     public void testCreate() {
-        assertEquals(create("a"), (new String[] {"a"}));
-        assertEquals(create(""), (new String[] {""}));
-        assertEquals(create("a", "b"), (new String[] {"a", "b"}));
+        assertArrayEquals(create("a"), (new String[] {"a"}));
+        assertArrayEquals(create(""), (new String[] {""}));
+        assertArrayEquals(create("a", "b"), (new String[] {"a", "b"}));
     }
 
     @Test
diff --git a/crypto/src/test/java/org/web3j/crypto/KeysTest.java b/crypto/src/test/java/org/web3j/crypto/KeysTest.java
index 95b0419e1..17f84b60b 100644
--- a/crypto/src/test/java/org/web3j/crypto/KeysTest.java
+++ b/crypto/src/test/java/org/web3j/crypto/KeysTest.java
@@ -23,6 +23,7 @@
 import org.web3j.utils.Numeric;
 import org.web3j.utils.Strings;
 
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertThrows;
@@ -143,7 +144,7 @@ public void testToChecksumAddress() {
 
     @Test
     public void testSerializeECKey() {
-        assertEquals(Keys.serialize(SampleKeys.KEY_PAIR), (ENCODED));
+        assertArrayEquals(Keys.serialize(SampleKeys.KEY_PAIR), (ENCODED));
     }
 
     @Test
diff --git a/crypto/src/test/java/org/web3j/crypto/MnemonicUtilsTest.java b/crypto/src/test/java/org/web3j/crypto/MnemonicUtilsTest.java
index 8fa2dd44c..93248d1e0 100644
--- a/crypto/src/test/java/org/web3j/crypto/MnemonicUtilsTest.java
+++ b/crypto/src/test/java/org/web3j/crypto/MnemonicUtilsTest.java
@@ -16,12 +16,13 @@
 import java.nio.file.Files;
 import java.nio.file.Paths;
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.List;
 import java.util.stream.Collectors;
+import java.util.stream.Stream;
 
 import org.bouncycastle.util.encoders.Hex;
-import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
 import org.junit.jupiter.params.provider.MethodSource;
 
 import static org.junit.jupiter.api.Assertions.assertArrayEquals;
@@ -43,59 +44,46 @@
      * Loads the test vectors into a in-memory list and feed them one after another to our
      * parameterized tests.
      *
-     * @return Collection of test vectors in which each vector is an array containing initial
-     *     entropy, expected mnemonic and expected seed.
+     * @return Stream of test vectors in which each vector is an array containing initial entropy,
+     *     expected mnemonic and expected seed.
      * @throws IOException Shouldn't happen!
      */
-    @MethodSource
-    public static Collection<Object[]> data() throws IOException {
+    public static Stream<Arguments> data() throws IOException {
         String data = Files.lines(Paths.get(SAMPLE_FILE)).collect(Collectors.joining("\n"));
         String[] each = data.split("###");
 
-        List<Object[]> parameters = new ArrayList<>();
+        List<Arguments> parameters = new ArrayList<>();
         for (String part : each) {
-            parameters.add(part.trim().split("\n"));
+            parameters.add(Arguments.of((Object[]) part.trim().split("\n")));
         }
 
-        return parameters;
+        return parameters.stream();
     }
 
-    /**
-     * The initial entropy for the current test vector. This entropy should be used to generate
-     * mnemonic and seed.
-     */
-    private byte[] initialEntropy;
-
-    /** Expected mnemonic for the given {@link #initialEntropy}. */
-    private String mnemonic;
-
-    /** Expected seed based on the calculated {@link #mnemonic} and default passphrase. */
-    private byte[] seed;
-
-    public MnemonicUtilsTest(String initialEntropy, String mnemonic, String seed) {
-        this.initialEntropy = Hex.decode(initialEntropy);
-        this.mnemonic = mnemonic;
-        this.seed = Hex.decode(seed);
-    }
-
-    @Test
-    public void generateMnemonicShouldGenerateExpectedMnemonicWords() {
-        String actualMnemonic = MnemonicUtils.generateMnemonic(initialEntropy);
+    @ParameterizedTest
+    @MethodSource("data")
+    public void generateMnemonicShouldGenerateExpectedMnemonicWords(
+            String initialEntropy, String mnemonic) {
+        String actualMnemonic = MnemonicUtils.generateMnemonic(Hex.decode(initialEntropy));
 
         assertEquals(mnemonic, actualMnemonic);
     }
 
-    @Test
-    public void generateSeedShouldGenerateExpectedSeeds() {
+    @ParameterizedTest
+    @MethodSource("data")
+    public void generateSeedShouldGenerateExpectedSeeds(
+            String initialEntropy, String mnemonic, String seed) {
         byte[] actualSeed = MnemonicUtils.generateSeed(mnemonic, "TREZOR");
 
-        assertArrayEquals(seed, actualSeed);
+        assertArrayEquals(Hex.decode(seed), actualSeed);
     }
 
-    @Test
-    public void generateEntropyShouldGenerateExpectedEntropy() {
+    @ParameterizedTest
+    @MethodSource("data")
+    public void generateEntropyShouldGenerateExpectedEntropy(
+            String initialEntropy, String mnemonic) {
         byte[] actualEntropy = MnemonicUtils.generateEntropy(mnemonic);
 
-        assertArrayEquals(initialEntropy, actualEntropy);
+        assertArrayEquals(Hex.decode(initialEntropy), actualEntropy);
     }
 }
diff --git a/crypto/src/test/java/org/web3j/crypto/TransactionEncoderTest.java b/crypto/src/test/java/org/web3j/crypto/TransactionEncoderTest.java
index 2e38c0d83..313e4f32c 100644
--- a/crypto/src/test/java/org/web3j/crypto/TransactionEncoderTest.java
+++ b/crypto/src/test/java/org/web3j/crypto/TransactionEncoderTest.java
@@ -21,6 +21,7 @@
 import org.web3j.rlp.RlpType;
 import org.web3j.utils.Numeric;
 
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 
 @SuppressWarnings("deprecation")
@@ -59,7 +60,7 @@ public void testContractAsRlpValues() {
 
     @Test
     public void testEip155Encode() {
-        assertEquals(
+        assertArrayEquals(
                 TransactionEncoder.encode(createEip155RawTransaction(), (byte) 1),
                 (Numeric.hexStringToByteArray(
                         "0xec098504a817c800825208943535353535353535353535353535353535353535880de0"
@@ -73,7 +74,7 @@ public void testEip155Transaction() {
                 Credentials.create(
                         "0x4646464646464646464646464646464646464646464646464646464646464646");
 
-        assertEquals(
+        assertArrayEquals(
                 TransactionEncoder.signMessage(createEip155RawTransaction(), (byte) 1, credentials),
                 (Numeric.hexStringToByteArray(
                         "0xf86c098504a817c800825208943535353535353535353535353535353535353535880"
diff --git a/docs/application_binary_interface.md b/docs/application_binary_interface.md
deleted file mode 100644
index e88e90b74..000000000
--- a/docs/application_binary_interface.md
+++ /dev/null
@@ -1,40 +0,0 @@
-Application Binary Interface
-============================
-
-The Application Binary Interface (ABI) is a data encoding scheme used in Ethereum for working with smart contracts. The types defined in the ABI are the same as those you encounter when writing [Smart Contracts](smart_contracts.md) with Solidity - i.e. *uint8, ..., uint256, int8, ..., int256, bool, string,* etc.
-
-The [ABI module](https://github.com/web3j/web3j/tree/master/abi) in web3j provides full support for the ABI specification, and includes:
-
--   Java implementations of all ABI types, including conversion from and to native Java types
--   Function and event support
--   Plenty of unit tests
-
-Type mappings
--------------
-
-The native Java to ABI type mappings used within web3j are as follows:
-
--   boolean -> bool
--   BigInteger -> uint/int
--   byte[\] -> bytes
--   String -> string and address types
--   List<\> -> dynamic/static array
-
-BigInteger types have to be used for numeric types, as numeric types in Ethereum are 256 bit integer values.
-
-[Fixed point types](http://solidity.readthedocs.io/en/develop/abi-spec.html#types) have been defined for Ethereum, but are [not currently implemented in Solidity](https://github.com/ethereum/solidity/issues/409), hence web3j does not currently support them (they were provided in versions prior to 3.x). Once available in Solidity, they will be reintroduced back into the web3j ABI module.
-
-For more information on using ABI types in Java, refer to [Solidity smart contract wrappers](smart_contracts.md#solidity-smart-contract-wrappers).
-
-Further details
----------------
-
-Please refer to the various [ABI unit tests](https://github.com/web3j/web3j/tree/master/abi/src/test/java/org/web3j/abi) for encoding/decoding examples.
-
-A full ABI specification is maintained with the [Solidity documentation](http://solidity.readthedocs.io/en/develop/abi-spec.html).
-
-Dependencies
-------------
-
-This is a very lightweight module, with the only third-party dependency being [Bouncy Castle](https://www.bouncycastle.org/) for cryptographic hashing ([Spongy Castle](https://rtyley.github.io/spongycastle/) on Android). The hope is that other projects wishing to work with
-Ethereum's ABI on the JVM or Android will choose to make use of this module rather then write their own implementations.
\ No newline at end of file
diff --git a/docs/command_line_tools.md b/docs/command_line_tools.md
deleted file mode 100644
index b1768d564..000000000
--- a/docs/command_line_tools.md
+++ /dev/null
@@ -1,360 +0,0 @@
-Web3j CLI
-=========
-
-A web3j binary is distributed with each release providing an interactive command line (CLI). It allows you to use some of the key functionality of web3j from your terminal, including:
-
-- New project creation
-- Project creation from existing Solidity code
-- Wallet creation
-- Wallet password management
-- Ether transfer from one wallet to another
-- Generation of Solidity smart contract wrappers
-- Smart contract auditing
-
-Installation
-------------
-
-### Script
-
-The simplest way to install the Web3j CLI is via the following script:
-
-```bash
-curl -L https://get.web3j.io | sh
-```
-
-You can veriify the installation was successful by running th web3j command:
-
-```bash
-web3j version
-
-              _      _____ _     _        
-             | |    |____ (_)   (_)       
-__      _____| |__      / /_     _   ___  
-\ \ /\ / / _ \ '_ \     \ \ |   | | / _ \ 
- \ V  V /  __/ |_) |.___/ / | _ | || (_) |
-  \_/\_/ \___|_.__/ \____/| |(_)|_| \___/ 
-                         _/ |             
-                        |__/              
-
-Version: 4.5.5
-Build timestamp: 2019-09-24 16:00:04.332 UTC
-```
-
-If you encounter problems with the installation, please refer to the manual installation instructions [below](#manual-installation).
-
-
-Web3j new & import
------------------------------------------
-The `web3j new` and `web3j import` commands provide a convenient way to create a new Java project using Web3j's Command Line Tools.
-
-These commands provide the following functionality:
-
-- Creation of a new Java project.
-- Generation of a simple *Hello World* Solidity contract (named the `Greeter`) or import an exisiting Solidity project from a file or directory.
-- Compilation of the Solidity files.
-- Configure the project to use the Gradle build tool.
-- Generate Java smart contract wrappers for all provided Solidity files.
-- Add the required web3j dependencies, to deploy and interact with the contracts.
-
-### web3j new
-
-To generate a new project interactively:
-
-```bash
-web3j new 
-``` 
-
-You will be prompted to answer a series of questions to create your project:
-
-```bash
-$ web3j new
-
-              _      _____ _     _        
-             | |    |____ (_)   (_)       
-__      _____| |__      / /_     _   ___  
-\ \ /\ / / _ \ '_ \     \ \ |   | | / _ \ 
- \ V  V /  __/ |_) |.___/ / | _ | || (_) |
-  \_/\_/ \___|_.__/ \____/| |(_)|_| \___/ 
-                         _/ |             
-                        |__/              
-
-Please enter the project name (required): 
-MyProject
-Please enter the package name for your project (required): 
-com.web3labs.eth
-Please enter the destination of your project (default .): 
-myproject
-Downloading https://services.gradle.org/distributions/gradle-5.0-bin.zip
-...................................................................
-Done
-Project MyProject created at location: myproject
-..............
-
-Welcome to Gradle 5.0!
-
-Here are the highlights of this release:
- - Kotlin DSL 1.0
- - Task timeouts
- - Dependency alignment aka BOM support
- - Interactive `gradle init`
-
-For more details see https://docs.gradle.org/5.0/release-notes.html
-
-$
-```
-
-Details of the created project structure are [below](#generated-project-structure).
-
-
-Or using non-interactive mode:
-
-```bash
-web3j new -n <project name> -p <package name> [-o <path>]
-```
-
-The `-o` option can be omitted if you want to generate the project in the current directory.
-
-The `project name ` and `package name` values must comply with the Java standard. The project name is also used as the class name.
-
-
-
-### web3j import
-
-Similarly to `web3j new`, `web3j import` will create a new java project but with user defined smart contracts.
-
-Again, to generate a new project interactively:
-
-```bash
-web3j new 
-``` 
-
-You will be prompted to answer a series of questions to create your project:
-
-```bash
-$ web3j import
-
-              _      _____ _     _        
-             | |    |____ (_)   (_)       
-__      _____| |__      / /_     _   ___  
-\ \ /\ / / _ \ '_ \     \ \ |   | | / _ \ 
- \ V  V /  __/ |_) |.___/ / | _ | || (_) |
-  \_/\_/ \___|_.__/ \____/| |(_)|_| \___/ 
-                         _/ |             
-                        |__/              
-
-Please enter the project name (Required Field): 
-MyImportedProject
-Please enter the package name for your project (Required Field): 
-com.web3labs.eth
-Please enter the path to your solidity file/folder (Required Field): 
-/path/to/solidity
-Please enter the destination of your project (current by default): 
-.
-Project created with name: myimportedproject at location: .
-$
-```
-
-This command can also be used non-interactively
-
-```
-web3j import -n <project name> -p <package name> -s <path to solidity sources> [-o <path>]
-```
-
-or 
-
-```
-web3j import 
-```
-
-The `-s` option will work with a single solidity file or a folder containing solidity files.
-
-
-Generated project structure
----------------------------
-
-Your application code and tests will be located in the following project directories:
-
-- `./src/main/java` - Generated Java appliciation code stub
-- `./src/test/java` - Generated Java test code stub
-- `./src/main/solidity` - Solidity source code
-
-If you need to edit the build file, it is located in the project root directory:
-
-- `./build.gradle` - Gradle build configuration file
-
-Additionally there are the following Gradle artifacts which you can ignore.
-
-- `/gradle` - local Gradle installation
-- `/.gradle` - local Gradle cache
-- `/build` - compiled classes including smart contract bindings
-
-If you need to view any of the generated Solidity or contract artifacts, they are available in the following locations.
-
-Solidity `bin` and `abi` files are located at:
-
-- `./build/resources/main/solidity/`
-
-The source code for the generated smart contract bindings can be found at:
-
-- `./build/generated/source/web3j/main/java/<your-package>/generated/contracts`
-
-The compiled code for the generated smart contracts bindings is available at the below location. These are the artifacts that you use to deploy, transact and query your smart contracts.
-
-- `./build/classes/java/main/<your-package>/generated/contracts/`
-
-
-Build commands
---------------
-
-Web3j projects use the Gradle build tool under the covers. Gradle is a build DSL  for JVM projects used widely in Java, Kotlin and Android projects. You shouldn't need to be too concerned with the semantics of Gradle beyond the following build commands:
-
-To build the project run:
-
-```bash
-./gradlew build
-```
-
-To update the just the smart contract bindings following changes to the Solidity code run:
-
-```bash
-./gradlew generateContractWrappers
-```
-
-To delete all project build artifacts, creating a clean environment, run:
-
-```bash
-./gradlew clean
-```
-
-
-
-Wallet tools
-------------
-
-To generate a new Ethereum wallet:
-
-``` bash
-$ web3j wallet create
-```
-
-To update the password for an existing wallet:
-
-``` bash
-$ web3j wallet update <walletfile>
-```
-
-To send Ether to another address:
-
-``` bash
-$ web3j wallet send <walletfile> 0x<address>|<ensName>
-```
-
-When sending Ether to another address you will be asked a series of questions before the transaction takes place. See the below for a full example
-
-The following example demonstrates using web3j to send Ether to another wallet.
-
-``` console
-$ ./web3j-<version>/bin/web3j wallet send <walletfile> 0x<address>|<ensName>
-
-              _      _____ _     _
-             | |    |____ (_)   (_)
-__      _____| |__      / /_     _   ___
-\ \ /\ / / _ \ '_ \     \ \ |   | | / _ \
- \ V  V /  __/ |_) |.___/ / | _ | || (_) |
-  \_/\_/ \___|_.__/ \____/| |(_)|_| \___/
-                         _/ |
-                        |__/
-
-Please enter your existing wallet file password:
-Wallet for address 0x19e03255f667bdfd50a32722df860b1eeaf4d635 loaded
-Please confirm address of running Ethereum client you wish to send the transfer request to [http://localhost:8545/]:
-Connected successfully to client: Geth/v1.4.18-stable-c72f5459/darwin/go1.7.3
-What amound would you like to transfer (please enter a numeric value): 0.000001
-Please specify the unit (ether, wei, ...) [ether]:
-Please confim that you wish to transfer 0.000001 ether (1000000000000 wei) to address 0x9c98e381edc5fe1ac514935f3cc3edaa764cf004
-Please type 'yes' to proceed: yes
-Commencing transfer (this may take a few minutes)...................................................................................................................$
-
-Funds have been successfully transferred from 0x19e03255f667bdfd50a32722df860b1eeaf4d635 to 0x9c98e381edc5fe1ac514935f3cc3edaa764cf004
-Transaction hash: 0xb00afc5c2bb92a76d03e17bd3a0175b80609e877cb124c02d19000d529390530
-Mined block number: 1849039
-```
-
-Auditing Tools
-------------
-
-Smart contracts written in Solidity often include logic bugs and other issues which might compromise their security. These are not always obvious to programmers. Issues can include [integer precision problems](https://github.com/smartdec/classification#arithmetic), [re-entrancy attacks](https://github.com/smartdec/classification#contract-interaction), and many other flaws. As Ethereum smart contracts are immutable once they have been deployed, it is important that they are bug-free at this point. Web3j is able to audit smart contracts for certain common issues and vulnerabilities using static code analysis. 
-
-To audit a smart contract (in this instance, Campaign.sol):
-
-``` bash
-$ web3j audit Campaign.sol
-```
-
-An example of the output from this command is as follows:
-``` bash
-              _      _____ _     _        
-             | |    |____ (_)   (_)       
-__      _____| |__      / /_     _   ___  
-\ \ /\ / / _ \ '_ \     \ \ |   | | / _ \ 
- \ V  V /  __/ |_) |.___/ / | _ | || (_) |
-  \_/\_/ \___|_.__/ \____/| |(_)|_| \___/ 
-                         _/ |             
-                        |__/              
-
-./Campaign.sol
-   131:58   severity:2   Multiplication after division                  SOLIDITY_DIV_MUL_09hhh1                              
-   91:8     severity:1   Revert inside the if-operator                  SOLIDITY_REVERT_REQUIRE_c56b12                       
-   5:4      severity:1   Use of SafeMath                                SOLIDITY_SAFEMATH_837cac                             
-   148:4    severity:1   Replace multiple return values with a struct   SOLIDITY_SHOULD_RETURN_STRUCT_83hf3l                 
-   125:4    severity:1   Prefer external to public visibility level     SOLIDITY_UNUSED_FUNCTION_SHOULD_BE_EXTERNAL_73ufc1   
-
-✖ 5 problems (5 errors)
-
-```
-
-The output is in the form of a list of issues/errors detected by the static analysis tool. The first column of output shows the line and the character at which the issue was encountered. The second column shows the severity; this ranges from 1 to 3, with 3 being the most severe. The next column contains a description of the issue found, and the final column provides a reference to the rule used to find the issue.
-
-
-This functionality is provided by [SmartCheck](https://github.com/smartdec/smartcheck).
-
-
-Solidity smart contract wrapper generator
------------------------------------------
-
-Please refer to [Solidity smart contract wrappers](smart_contracts.md#solidity-smart-contract-wrappers).
-
-
-Manual installation
--------------------
-Manual installation
-
-The command line tools can also be obtained as a zipfile/tarball from the [releases](https://github.com/web3j/web3j/releases/latest) page of the project repository, under the **Downloads** section, or for OS X users via [Homebrew](https://github.com/web3j/homebrew-web3j), or for Arch linux users via the [AUR](https://aur.archlinux.org/packages/web3j/).
-
-``` bash
-brew tap web3j/web3j
-brew install web3j
-```
-
-To run via the zipfile, simply extract the zipfile and run the binary:
-
-``` console
-$ unzip web3j-<version>.zip
-   creating: web3j-3.0.0/lib/
-  inflating: web3j-3.0.0/lib/core-1.0.2-all.jar
-   creating: web3j-3.0.0/bin/
-  inflating: web3j-3.0.0/bin/web3j
-  inflating: web3j-3.0.0/bin/web3j.bat
-$ ./web3j-<version>/bin/web3j
-
-              _      _____ _     _
-             | |    |____ (_)   (_)
-__      _____| |__      / /_     _   ___
-\ \ /\ / / _ \ '_ \     \ \ |   | | / _ \
- \ V  V /  __/ |_) |.___/ / | _ | || (_) |
-  \_/\_/ \___|_.__/ \____/| |(_)|_| \___/
-                         _/ |
-                        |__/
-
-Usage: web3j version|wallet|solidity|new|import ...
-```
diff --git a/docs/companies_using_web3j.md b/docs/companies_using_web3j.md
deleted file mode 100644
index 2b9d6da50..000000000
--- a/docs/companies_using_web3j.md
+++ /dev/null
@@ -1,11 +0,0 @@
-Companies using web3j
-=====================
-
--   [Amberdata](https://www.amberdata.io/)
--   [Web3Labs](https://www.web3labs.com/)
--   [comitFS](http://www.comitfs.com/)
--   [ConsenSys](https://consensys.net/)
--   [ING](https://www.ing.com)
--   [Othera](http://www.othera.io/)
--   [TrustWallet](http://trustwalletapp.com)
-
diff --git a/docs/contracts_supported_by_web3j.md b/docs/contracts_supported_by_web3j.md
deleted file mode 100644
index 93f5850aa..000000000
--- a/docs/contracts_supported_by_web3j.md
+++ /dev/null
@@ -1,30 +0,0 @@
-#Contracts supported by web3j
-
-EIP20
-=====
-
-ERC20 tokens are supported via ERC20 contract wrapper as defined in [EIP20](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md) To fetch your token balance you can simply do:
-
-```java
-ERC20 contract = ERC20.load(tokenAddress, web3j, txManager, gasPriceProvider);
-BigInteger balance = contract.balanceOf(account).send();
-```
-
-EIP165
-======
-
-Smart contract interfaces support and discovery as defined in [EIP165](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md) To check whether token contract supports particular interface:
-
-```java
-ERC165 contract = ERC165.load(tokenAddress, web3j, txManager, gasPriceProvider);
-Boolean isSupported = contract.supportsInterface(interfaceID).send();
-```
-
-EIP721
-======
-
-Support for non-fungible tokens, also known as deeds as defined in [EIP721](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md). This contains the following contract wrappers:
-
--   ERC721 is a set of methods that NFT should support
--   ERC721Metadata optional metadata extension for NFT
--   ERC721Enumerable optional enumeration extension for NFT
diff --git a/docs/developer_guide.md b/docs/developer_guide.md
deleted file mode 100644
index 0939e7ad8..000000000
--- a/docs/developer_guide.md
+++ /dev/null
@@ -1,79 +0,0 @@
-Developer Guide
-===============
-
-Dependency management
----------------------
-
-We recommend you use formal releases of web3j, these can be found on most public maven
-[repositories](https://mvnrepository.com/search?q=web3j).
-
-> Release versions follow the `<major>.<minor>.<build>` convention, for example: 4.2.0
-
-> Snapshot versions of web3j follow the <major>.<minor>.<build>-SNAPSHOT` convention, for example:    	4.2.0-SNAPSHOT.
-
-> If you would like to use snapshots instead please add a new maven repository pointing to:
-
-```bash
-https://oss.sonatype.org/content/repositories/snapshots
-```
-
-Please refer to the [Maven](https://maven.apache.org/guides/mini/guide-multiple-repositories.html) or [Gradle](https://docs.gradle.org/current/userguide/userguide.html) documentation for further detail.
-
-Sample gradle configuration:
-
-``` groovy
-repositories {
-   maven {
-      url "https://oss.sonatype.org/content/repositories/snapshots"
-   }
-}
-```
-
-Sample maven configuration:
-
-``` xml
-<repositories>
-  <repository>
-    <id>sonatype-snasphots</id>
-    <name>Sonatype snapshots repo</name>
-    <url>https://oss.sonatype.org/content/repositories/snapshots</url>
-  </repository>
-</repositories>
-```
-
-Building web3j
---------------
-
-web3j includes integration tests for running against a live Ethereum client. If you do not have a client running, you can exclude their execution as per the below instructions.
-
-To run a full build (excluding integration tests):
-
-``` bash
-$ ./gradlew check
-```
-
-To run the integration tests:
-
-``` bash
-$ ./gradlew  -Pintegration-tests=true :integration-tests:test
-```
-
-Generating documentation
-------------------------
-
-web3j uses the [Sphinx](http://www.sphinx-doc.org/en/stable/) documentation generator.
-
-All documentation (apart from the project README.md) resides under the [/docs](https://github.com/web3j/web3j/tree/master/docs) directory.
-
-To build a copy of the documentation, from the project root:
-
-``` bash
-$ cd docs
-$ make clean html
-```
-
-Then browse the build documentation via:
-
-``` bash
-$ open build/html/index.html
-```
diff --git a/docs/ethereum_name_service.md b/docs/ethereum_name_service.md
deleted file mode 100644
index 9adb914d0..000000000
--- a/docs/ethereum_name_service.md
+++ /dev/null
@@ -1,53 +0,0 @@
-Ethereum Name Service
-=====================
-
-The [Ethereum Name Service (ENS)](https://ens.domains) provides a human readable names to identify addresses on the Ethereum network. It is similar to the internet's domain name service (DNS) which provides human-readable domain names which are mapped to IP addresses.
-
-In the case of ENS, the addresses are either wallet or smart contract addresses.
-
-E.g. instead of using the wallet address *0x19e03255f667bdfd50a32722df860b1eeaf4d635*, you can use *web3j.eth*.
-
-Usage in web3j
---------------
-
-You can use ENS names anywhere you wish to transact in web3j. In practice this means, in smart contract wrappers, when you load them, such as:
-
-```java
-YourSmartContract contract = YourSmartContract.load(
-        "0x<address>|<ensName>", web3j, credentials, GAS_PRICE, GAS_LIMIT);
-```
-
-Also, when performing Ether transfers, such as using the command line
-tools:
-
-``` bash
-$ web3j wallet send <walletfile> 0x<address>|<ensName>
-```
-
-web3j implementation 
---------------------
-
-Behind the scenes, whenever you using web3j's transaction managers (which are derived from the
-[ManagedTransaction](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/tx/ManagedTransaction.java) class), the [EnsResolver](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/ens/EnsResolver.java) is invoked to perform an ENS lookup if applicable.
-
-The resolution process is as follows:
-
--   Check to see if our Ethereum node is fully synced
--   If not fail
--   If it is synced, check the timestamp on the most recent block it has.
-
-    - If it's more than 3 minutes old, fail.
-    - Otherwise perform the lookup
-
-If you need to change the threshold parameter of what constitutes being synced to something other then 3 minutes, this can be done via the *setSyncThreshold* method in the [ManagedTransaction](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/tx/ManagedTransaction.java) class.
-
-Unicode Technical Standard (UTS) \#46
--------------------------------------
-
-UTS #46 is the standard used to sanitise input on domain names. The web3j ENS implementation peforms this santisation on all inputs before attempting resolution. For details of the implementation, refer to the [NameHash](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/ens/NameHash.java) class.
-
-Registering domain names
-------------------------
-
-Currently, web3j only supports the resolution of ENS domains. It does not support the registration. For instructions on how to do this, refer to the ENS [documentation](https://docs.ens.domains/).
-
diff --git a/docs/filters_and_events.md b/docs/filters_and_events.md
deleted file mode 100644
index ebb209aee..000000000
--- a/docs/filters_and_events.md
+++ /dev/null
@@ -1,168 +0,0 @@
-Filters and Events
-==================
-
-Filters provide notifications of certain events taking place in the Ethereum network. There are three classes of filter supported in Ethereum:
-
-1.  Block filters
-2.  Pending transaction filters
-3.  Topic filters
-
-Block filters and pending transaction filters provide notification of the creation of new transactions or blocks on the network.
-
-Topic filters are more flexible. These allow you to create a filter based on specific criteria that you provide.
-
-Unfortunately, unless you are using a WebSocket connection to Geth, working with filters via the JSON-RPC API is a tedious process, where you need to poll the Ethereum client in order to find out if there are any updates to your filters due to the synchronous nature of HTTP and IPC requests. Additionally the block and transaction filters only provide the transaction or block hash, so a further request is required to obtain the actual transaction or block referred to by the hash.
-
-web3j's managed [Filter](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/protocol/core/filters/Filter.java) implementation address these issues, so you have a fully asynchronous event based API for working with filters. It uses [RxJava](https://github.com/ReactiveX/RxJava)'s [Flowables](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html) which provides a consistent API for working with events, which facilitates the chaining together of JSON-RPC calls via functional
-composition.
-
-**Note:** filters are not supported on Infura.
-
-Block and transaction filters
------------------------------
-
-To receive all new blocks as they are added to the blockchain (the false
-parameter specifies that we only want the blocks, not the embedded
-transactions too):
-
-```java
-Subscription subscription = web3j.blockFlowable(false).subscribe(block -> {
-    ...
-});
-```
-
-To receive all new transactions as they are added to the blockchain:
-
-```java
-Subscription subscription = web3j.transactionFlowable().subscribe(tx -> {
-    ...
-});
-```
-
-To receive all pending transactions as they are submitted to the network
-(i.e. before they have been grouped into a block together):
-
-```java
-Subscription subscription = web3j.pendingTransactionFlowable().subscribe(tx -> {
-    ...
-});
-```
-
-Subscriptions should always be cancelled when no longer required via
-*unsubscribe*:
-
-```java
-subscription.unsubscribe();
-```
-
-Other callbacks are also provided which provide simply the block or transaction hashes, for details of these refer to the [Web3jRx](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/protocol/rx/Web3jRx.java) interface.
-
-Replay filters
---------------
-
-web3j also provides filters for replaying block and transaction history.
-
-To replay a range of blocks from the blockchain:
-
-```java
-Subscription subscription = web3j.replayBlocksFlowable(
-        <startBlockNumber>, <endBlockNumber>, <fullTxObjects>)
-        .subscribe(block -> {
-            ...
-});
-```
-
-To replay the individual transactions contained within a range of blocks:
-
-```java
-Subscription subscription = web3j.replayTransactionsFlowable(
-        <startBlockNumber>, <endBlockNumber>)
-        .subscribe(tx -> {
-            ...
-});
-```
-
-You can also get web3j to replay all blocks up to the most current, and provide notification (via the submitted Flowable) once you've caught up:
-
-```java
-Subscription subscription = web3j.replayPastBlocksFlowable(
-        <startBlockNumber>, <fullTxObjects>, <onCompleteFlowable>)
-        .subscribe(block -> {
-            ...
-});
-```
-
-Or, if you'd rather replay all blocks to the most current, then be notified of new subsequent blocks being created:
-
-```java
-Subscription subscription = web3j.replayPastAndFutureBlocksFlowable(
-        <startBlockNumber>, <fullTxObjects>)
-        .subscribe(block -> {
-            ...
-});
-```
-
-As above, but with transactions contained within blocks:
-
-```java
-Subscription subscription = web3j.replayPastAndFutureTransactionsFlowable(
-        <startBlockNumber>)
-        .subscribe(tx -> {
-            ...
-});
-```
-
-All of the above filters are exported via the [Web3jRx](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/protocol/rx/Web3jRx.java) interface.
-
-Topic filters and EVM events {#filters-and-events}
-----------------------------
-
-Topic filters capture details of Ethereum Virtual Machine (EVM) events taking place in the network. These events are created by smart contracts and stored in the transaction log associated with a smart contract.
-
-The [Solidity documentation](http://solidity.readthedocs.io/en/develop/contracts.html#events) provides a good overview of EVM events.
-
-You use the [EthFilter](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/protocol/core/methods/request/EthFilter.java) type to specify the topics that you wish to apply to the filter. This can include the address of the smart contract you wish to apply the filter to. You can also provide specific topics to filter on. Where the individual topics represent indexed parameters on the smart contract:
-
-```java
-EthFilter filter = new EthFilter(DefaultBlockParameterName.EARLIEST,
-        DefaultBlockParameterName.LATEST, <contract-address>)
-             [.addSingleTopic(...) | .addOptionalTopics(..., ...) | ...];
-```
-
-This filter can then be created using a similar syntax to the block and transaction filters above:
-
-```java
-web3j.ethLogFlowable(filter).subscribe(log -> {
-    ...
-});
-```
-
-The filter topics can only refer to the indexed Solidity event parameters. It is not possible to filter on the non-indexed event parameters. Additionally, for any indexed event parameters that are variable length array types such as string and bytes, the Keccak-256 hash of their value is stored on the EVM log. It is not possible to store or filter using their full value.
-
-If you create a filter instance with no topics associated with it, all EVM events taking place in the network will be captured by the filter.
-
-A note on functional composition
---------------------------------
-
-In addition to *send()* and *sendAsync*, all JSON-RPC method implementations in web3j support the *flowable()* method to create a Flowable to execute the request asynchronously. This makes it very straight forwards to compose JSON-RPC calls together into new functions.
-
-For instance, the [blockFlowable](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/protocol/rx/JsonRpc2_0Rx.java) is itself composed of a number of separate JSON-RPC calls:
-
-```java
-public Flowable<EthBlock> blockFlowable(
-        boolean fullTransactionObjects, long pollingInterval) {
-    return this.ethBlockHashFlowable(pollingInterval)
-            .flatMap(blockHash ->
-                    web3j.ethGetBlockByHash(blockHash, fullTransactionObjects).flowable());
-}
-```
-
-Here we first create a flowable that provides notifications of the block hash of each newly created block. We then use *flatMap* to invoke a call to *ethGetBlockByHash* to obtain the full block details which is what is passed to the subscriber of the flowable.
-
-Further examples
-----------------
-
-Please refer to the integration test [FlowableIT](https://github.com/web3j/web3j/blob/master/integration-tests/src/test/java/org/web3j/protocol/core/FlowableIT.java) for further examples.
-
-For a demonstration of using the manual filter API, you can take a look
-at the test [EventFilterIT](https://github.com/web3j/web3j/blob/master/integration-tests/src/test/java/org/web3j/protocol/scenarios/EventFilterIT.java).
\ No newline at end of file
diff --git a/docs/getting_started.md b/docs/getting_started.md
deleted file mode 100644
index 7379d082a..000000000
--- a/docs/getting_started.md
+++ /dev/null
@@ -1,412 +0,0 @@
-Getting Started
-===============
-
-Add the latest web3j version to your project build configuration.
-
-Maven
------
-
-Java 8:
-
-``` xml
-<dependency>
-  <groupId>org.web3j</groupId>
-  <artifactId>core</artifactId>
-  <version>4.5.5</version>
-</dependency>
-```
-
-Android:
-
-``` xml
-<dependency>
-  <groupId>org.web3j</groupId>
-  <artifactId>core</artifactId>
-  <version>4.2.0-android</version>
-</dependency>
-```
-
-Gradle
-------
-
-Java 8:
-
-``` groovy
-compile ('org.web3j:core:4.5.5')
-```
-
-Android:
-
-``` groovy
-compile ('org.web3j:core:4.2.0-android')
-```
-
-Start a client
---------------
-
-Start up an Ethereum client if you don't already have one running, such as [Geth](https://github.com/ethereum/go-ethereum/wiki/geth):
-
-``` {.bash}
-$ geth --rpcapi personal,db,eth,net,web3 --rpc --rinkeby
-```
-
-Or [Parity](https://github.com/paritytech/parity):
-
-``` {.bash}
-$ parity --chain testnet
-```
-
-Or use [Infura](https://infura.io/), which provides **free clients** running in the cloud:
-
-``` java
-Web3j web3 = Web3j.build(new HttpService("https://morden.infura.io/your-token"));
-```
-
-For further information refer to [Using Infura with web3j](using_infura_with_web3j.md).
-
-Instructions on obtaining Ether to transact on the network can be found in the [testnet section of the docs](transactions.md#ethereum-testnets).
-
-When you no longer need a _Web3j_ instance you need to call the _shutdown_ method to close resources used by it.
-
-``` java
-web3.shutdown()
-```
-
-Start sending requests
-----------------------
-
-To send synchronous requests:
-
-```java
-Web3j web3 = Web3j.build(new HttpService());  // defaults to http://localhost:8545/
-Web3ClientVersion web3ClientVersion = web3.web3ClientVersion().send();
-String clientVersion = web3ClientVersion.getWeb3ClientVersion();
-```
-
-To send asynchronous requests using a CompletableFuture (Future on Android):
-
-```java
-Web3j web3 = Web3j.build(new HttpService());  // defaults to http://localhost:8545/
-Web3ClientVersion web3ClientVersion = web3.web3ClientVersion().sendAsync().get();
-String clientVersion = web3ClientVersion.getWeb3ClientVersion();
-```
-
-To use an RxJava Flowable:
-
-```java
-Web3j web3 = Web3j.build(new HttpService());  // defaults to http://localhost:8545/
-web3.web3ClientVersion().flowable().subscribe(x -> {
-    String clientVersion = x.getWeb3ClientVersion();
-    ...
-});
-```
-
-IPC
----
-
-web3j also supports fast inter-process communication (IPC) via file sockets to clients running on the same host as web3j. To connect simply use the relevant *IpcService* implementation instead of *HttpService*
-when you create your service:
-
-``` java
-// OS X/Linux/Unix:
-Web3j web3 = Web3j.build(new UnixIpcService("/path/to/socketfile"));
-...
-
-// Windows
-Web3j web3 = Web3j.build(new WindowsIpcService("/path/to/namedpipefile"));
-...
-```
-
-**Note:** IPC is not available on *web3j-android*.
-
-Working with smart contracts with Java smart contract wrappers 
---------------------------------------------------------------
-
-web3j can auto-generate smart contract wrapper code to deploy and interact with smart contracts without leaving the JVM.
-
-To generate the wrapper code, compile your smart contract:
-
-``` bash
-$ solc <contract>.sol --bin --abi --optimize -o <output-dir>/
-```
-
-Then generate the wrapper code using web3j's [Command Line Tools](command_line_tools.md):
-
-``` bash
-web3j solidity generate -b /path/to/<smart-contract>.bin -a /path/to/<smart-contract>.abi -o /path/to/src/main/java -p com.your.organisation.name
-```
-
-Now you can create and deploy your smart contract:
-
-```java
-Web3j web3 = Web3j.build(new HttpService());  // defaults to http://localhost:8545/
-Credentials credentials = WalletUtils.loadCredentials("password", "/path/to/walletfile");
-
-YourSmartContract contract = YourSmartContract.deploy(
-        <web3j>, <credentials>,
-        GAS_PRICE, GAS_LIMIT,
-        <param1>, ..., <paramN>).send();  // constructor params
-```
-
-Or use an existing contract:
-
-```java
-YourSmartContract contract = YourSmartContract.load(
-        "0x<address>|<ensName>", <web3j>, <credentials>, GAS_PRICE, GAS_LIMIT);
-```
-
-To transact with a smart contract:
-
-```java
-TransactionReceipt transactionReceipt = contract.someMethod(
-             <param1>,
-             ...).send();
-```
-
-To call a smart contract:
-
-```java
-Type result = contract.someMethod(<param1>, ...).send();
-```
-
-For more information refer to [Solidity smart contract wrappers](smart_contracts.md#solidity-smart-contract-wrappers).
-
-Filters
--------
-
-web3j functional-reactive nature makes it really simple to setup observers that notify subscribers of events taking place on the blockchain.
-
-To receive all new blocks as they are added to the blockchain:
-
-```java
-Subscription subscription = web3j.blockFlowable(false).subscribe(block -> {
-    ...
-});
-```
-
-To receive all new transactions as they are added to the blockchain:
-
-```java
-Subscription subscription = web3j.transactionFlowable().subscribe(tx -> {
-    ...
-});
-```
-
-To receive all pending transactions as they are submitted to the network (i.e. before they have been grouped into a block together):
-
-```java
-Subscription subscription = web3j.pendingTransactionFlowable().subscribe(tx -> {
-    ...
-});
-```
-
-Or, if you'd rather replay all blocks to the most current, and be notified of new subsequent blocks being created:
-
-```java
-Subscription subscription = replayPastAndFutureBlocksFlowable(
-        <startBlockNumber>, <fullTxObjects>)
-        .subscribe(block -> {
-            ...
-});
-```
-
-There are a number of other transaction and block replay Flowables described in [Filters and Events](filters_and_events.md).
-
-Topic filters are also supported:
-
-```java
-EthFilter filter = new EthFilter(DefaultBlockParameterName.EARLIEST,
-        DefaultBlockParameterName.LATEST, <contract-address>)
-             .addSingleTopic(...)|.addOptionalTopics(..., ...)|...;
-web3j.ethLogFlowable(filter).subscribe(log -> {
-    ...
-});
-```
-
-Subscriptions should always be cancelled when no longer required:
-
-```Java
-subscription.unsubscribe();
-```
-
-**Note:** filters are not supported on Infura.
-
-For further information refer to [Filters and Events](filters_and_events.md) and the [Web3jRx](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/protocol/rx/Web3jRx.java) interface.
-
-Transactions
-------------
-
-web3j provides support for both working with Ethereum wallet files (*recommended*) and Ethereum client admin commands for sending transactions.
-
-To send Ether to another party using your Ethereum wallet file:
-
-```Java
-Web3j web3 = Web3j.build(new HttpService());  // defaults to http://localhost:8545/
-Credentials credentials = WalletUtils.loadCredentials("password", "/path/to/walletfile");
-TransactionReceipt transactionReceipt = Transfer.sendFunds(
-        web3, credentials, "0x<address>|<ensName>",
-        BigDecimal.valueOf(1.0), Convert.Unit.ETHER)
-        .send();
-```
-
-Or if you wish to create your own custom transaction:
-
-```Java
-Web3j web3 = Web3j.build(new HttpService());  // defaults to http://localhost:8545/
-Credentials credentials = WalletUtils.loadCredentials("password", "/path/to/walletfile");
-
-// get the next available nonce
-EthGetTransactionCount ethGetTransactionCount = web3j.ethGetTransactionCount(
-             address, DefaultBlockParameterName.LATEST).send();
-BigInteger nonce = ethGetTransactionCount.getTransactionCount();
-
-// create our transaction
-RawTransaction rawTransaction  = RawTransaction.createEtherTransaction(
-             nonce, <gas price>, <gas limit>, <toAddress>, <value>);
-
-// sign & send our transaction
-byte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, credentials);
-String hexValue = Numeric.toHexString(signedMessage);
-EthSendTransaction ethSendTransaction = web3j.ethSendRawTransaction(hexValue).send();
-// ...
-```
-
-Although it's far simpler using web3j's [Transfer](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/tx/Transfer.java) for transacting with Ether.
-
-Using an Ethereum client's admin commands (make sure you have your wallet in the client's keystore):
-
-```Java
-Admin web3j = Admin.build(new HttpService());  // defaults to http://localhost:8545/
-PersonalUnlockAccount personalUnlockAccount = web3j.personalUnlockAccount("0x000...", "a password").sendAsync().get();
-if (personalUnlockAccount.accountUnlocked()) {
-    // send a transaction
-}
-```
-
-If you want to make use of Parity's [Personal](https://github.com/paritytech/parity/wiki/JSONRPC-personal-module) or [Trace](https://github.com/paritytech/parity/wiki/JSONRPC-trace-module), or Geth's [Personal](https://github.com/ethereum/go-ethereum/wiki/Management-APIs#personal) client APIs, you can use the *org.web3j:parity* and *org.web3j:geth* modules respectively.
-
-Publish/Subscribe (pub/sub)
----------------------------
-
-Ethereum clients implement the [pub/sub](https://github.com/ethereum/go-ethereum/wiki/RPC-PUB-SUB) mechanism that provides the capability to subscribe to events from the network, allowing these clients to take custom actions as needed. In doing so it alleviates the need to use polling and is more efficient. This is achieved by using the WebSocket protocol instead of HTTP protocol.
-
-Pub/Sub methods are available via the _WebSocketService_ class, and allows the client to:
-
--   send an RPC call over WebSocket protocol
--   subscribe to WebSocket events
--   unsubscribe from a stream of events
-
-To create an instance of the _WebSocketService_ class you need to first to create an instance of the _WebSocketClient_ that connects to an Ethereum client via WebSocket protocol, and then pass it to the _WebSocketService_ constructor:
-
-```Java
-final WebSocketClient webSocketClient = new WebSocketClient(new URI("ws://localhost/"));
-final boolean includeRawResponses = false;
-final WebSocketService webSocketService = new WebSocketService(webSocketClient, includeRawResponses)
-```
-
-To send an RPC request using the WebSocket protocol one need to use the _sendAsync_ method on the _WebSocketService_ instance:
-
-```java
-// Request to get a version of an Ethereum client
-final Request<?, Web3ClientVersion> request = new Request<>(
-     // Name of an RPC method to call
-     "web3_clientVersion",
-     // Parameters for the method. "web3_clientVersion" does not expect any
-     Collections.<String>emptyList(),
-     // Service that is used to send a request
-     webSocketService,
-     // Type of an RPC call to get an Ethereum client version
-     Web3ClientVersion.class);
-
-// Send an asynchronous request via WebSocket protocol
-final CompletableFuture<Web3ClientVersion> reply = webSocketService.sendAsync(
-                request,
-                Web3ClientVersion.class);
-
-// Get result of the reply
-final Web3ClientVersion clientVersion = reply.get();
-```
-
-To use synchronous communication (i.e send a request and await a
-response) one would need to use the _sync_ method instead:
-
-```java
-// Send a (synchronous) request via WebSocket protocol
-final Web3ClientVersion clientVersion = webSocketService.send(
-                request,
-                Web3ClientVersion.class);
-```
-
-To subscribe to WebSocket events _WebSocketService_ provides the _subscribe_ method. _subscribe_ returns an
-instance of the [Flowable](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html) interface from the RxJava library, which allows the processing of incoming events from an Ethereum network as a reactive stream.
-
-To subscribe to a stream of events you should use _WebSocketService_ to send an RPC method via WebSocket; this is usually _eth_subscribe_. Events that it subscribes to depend on parameters to the _eth_subscribe_ method. You can find more in the [RPC documentation](https://github.com/ethereum/go-ethereum/wiki/RPC-PUB-SUB#supported-subscriptions):
-
-```java
-// A request to subscribe to a stream of events
-final Request<?, EthSubscribe> subscribeRequest = new Request<>(
-    // RPC method to subscribe to events
-    "eth_subscribe",
-    // Parameters that specify what events to subscribe to
-    Arrays.asList("newHeads", Collections.emptyMap()),
-    // Service that is used to send a request
-    webSocketService,
-    EthSubscribe.class);
-
-final Flowable<NewHeadsNotification> events = webSocketService.subscribe(
-     subscribeRequest,
-     // RPC method that should be used to unsubscribe from events
-     "eth_unsubscribe",
-     // Type of events returned by a request
-     NewHeadsNotification.class
-);
-
-// Subscribe to incoming events and process incoming events
-final Disposable disposable = events.subscribe(event -> {
-    // Process new heads event
-});
-```
-
-Notice that we need to provide a name of a method to _WebSocketService_ that needs to be called to unsubscribe from a stream of events. This is because different Ethereum clients may have different methods to unsubscribe from particular events. For example, the Parity client requires use of the
-_parity_unsubscribe_ method to unsubscribe from [pub/sub events](https://wiki.parity.io/JSONRPC-eth_pubsub-module).
-
-To unsubscribe from a stream of events one needs to use a _Flowable_ instance for a particular events stream:
-
-```java
-final Flowable<NewHeadsNotification> events = ...
-final Disposable disposable = events.subscribe(...)
-disposable.dispose();
-```
-
-The methods described above are quite low-level, so we can use _Web3j_ implementation instead:
-
-```java
-final WebSocketService webSocketService = ...
-final Web3j web3j = Web3j.build(webSocketService)
-final Flowable<NewHeadsNotification> notifications = web3j.newHeadsNotifications()
-```
-
-Command line tools
-------------------
-
-A web3j fat jar is distributed with each release providing command line tools. The command line tools allow you to use some of the functionality of web3j from the command line:
-
--   Wallet creation
--   Wallet password management
--   Transfer of funds from one wallet to another
--   Generate Solidity smart contract function wrappers
-
-Please refer to the [documentation](command_line_tools.md) for further information.
-
-Further details
----------------
-
-In the Java 8 build:
-
--   web3j provides type safe access to all responses. Optional or null responses are wrapped in Java 8's [Optional](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html) type.
--   Asynchronous requests are wrapped in a Java 8 [CompletableFutures](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html). web3j provides a wrapper around all async requests to ensure that any exceptions during execution will be captured rather then silently discarded. This is due to the lack of support in *CompletableFutures* for checked exceptions, which are often rethrown as unchecked exception causing problems with detection. See the [Async.run()](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/utils/Async.java) and its associated [test](https://github.com/web3j/web3j/blob/master/core/src/test/java/org/web3j/utils/AsyncTest.java) for details.
-
-In both the Java 8 and Android builds:
-
--   Quantity payload types are returned as [BigIntegers](https://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html). For simple results, you can obtain the quantity as a String via [Response](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/protocol/core/Response.java).getResult().
--   It's also possible to include the raw JSON payload in responses via the *includeRawResponse* parameter, present in the [HttpService](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/protocol/http/HttpService.java) and [IpcService](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/protocol/ipc/IpcService.java) classes.
diff --git a/docs/img/favicon.ico b/docs/img/favicon.ico
deleted file mode 100644
index a1bc9d618..000000000
Binary files a/docs/img/favicon.ico and /dev/null differ
diff --git a/docs/img/infura_cert.png b/docs/img/infura_cert.png
deleted file mode 100644
index 3238d2164..000000000
Binary files a/docs/img/infura_cert.png and /dev/null differ
diff --git a/docs/img/logo.png b/docs/img/logo.png
deleted file mode 100644
index ec031cb32..000000000
Binary files a/docs/img/logo.png and /dev/null differ
diff --git a/docs/img/pending_transaction.png b/docs/img/pending_transaction.png
deleted file mode 100644
index 8e999c0b8..000000000
Binary files a/docs/img/pending_transaction.png and /dev/null differ
diff --git a/docs/img/smart_contract.png b/docs/img/smart_contract.png
deleted file mode 100644
index a7d1ded33..000000000
Binary files a/docs/img/smart_contract.png and /dev/null differ
diff --git a/docs/img/transaction_process.png b/docs/img/transaction_process.png
deleted file mode 100644
index 69730fe2c..000000000
Binary files a/docs/img/transaction_process.png and /dev/null differ
diff --git a/docs/img/web3j_network.png b/docs/img/web3j_network.png
deleted file mode 100644
index 2ee7caa6d..000000000
Binary files a/docs/img/web3j_network.png and /dev/null differ
diff --git a/docs/img/web3j_transaction.png b/docs/img/web3j_transaction.png
deleted file mode 100644
index f6b918505..000000000
Binary files a/docs/img/web3j_transaction.png and /dev/null differ
diff --git a/docs/index.md b/docs/index.md
deleted file mode 100644
index 722b4a7a7..000000000
--- a/docs/index.md
+++ /dev/null
@@ -1,57 +0,0 @@
-web3j
-=====
-
-web3j is a highly modular, reactive, type safe Java and Android library for working with Smart Contracts and integrating with clients (nodes) on the Ethereum network:
-
-![image](img/web3j_network.png)
-
-This allows you to work with the [Ethereum](https://www.ethereum.org/) blockchain, without the additional overhead of having to write your own integration code for the platform.
-
-The [Java and the Blockchain](https://www.youtube.com/watch?v=ea3miXs_P6Y) talk provides an overview of blockchain, Ethereum and web3j.
-
-Features
-========
-
--   Complete implementation of Ethereum's [JSON-RPC](https://github.com/ethereum/wiki/wiki/JSON-RPC) client API over HTTP and IPC
--   Ethereum wallet support
--   Auto-generation of Java smart contract wrappers to create, deploy, transact with and call smart contracts from native Java code ([Solidity](http://solidity.readthedocs.io/en/latest/using-the-compiler.html#using-the-commandline-compiler) and [Truffle](https://github.com/trufflesuite/truffle) definition formats supported)
--   Reactive-functional API for working with filters
--   [Ethereum Name Service (ENS)](https://ens.domains/) support
--   Support for Parity's [Personal](https://github.com/paritytech/parity/wiki/JSONRPC-personal-module), and Geth's [Personal](https://github.com/ethereum/go-ethereum/wiki/Management-APIs#personal) client APIs
--   Support for [Infura](https://infura.io/), so you don't have to run an Ethereum client yourself
--   Support for ERC20 and ERC721 token standards
--   Comprehensive integration tests demonstrating a number of the above scenarios
--   Command line tools
--   Android compatible
--   Support for JP Morgan's Quorum via
-    [web3j-quorum](https://github.com/web3j/quorum)
-
-Dependencies
-============
-
-It has five runtime dependencies:
-
--   [RxJava](https://github.com/ReactiveX/RxJava) for its reactive-functional API
--   [OKHttp](https://hc.apache.org/httpcomponents-client-ga/index.html) for HTTP connections
--   [Jackson Core](https://github.com/FasterXML/jackson-core) for fast JSON serialisation/deserialisation
--   [Bouncy Castle](https://www.bouncycastle.org/) ([Spongy Castle](https://rtyley.github.io/spongycastle/) on Android) for crypto
--   [Jnr-unixsocket](https://github.com/jnr/jnr-unixsocket) for \*nix IPC (not available on Android)
-
-It also uses [JavaPoet](https://github.com/square/javapoet) for generating smart contract wrappers
-
-Donate
-======
-
-You can help fund the development of web3j by donating to the following wallet addresses:
-
----------- --------------------------------------------
-  Ethereum   0x2dfBf35bb7c3c0A466A6C48BEBf3eF7576d3C420
-
-  Bitcoin    1DfUeRWUy4VjekPmmZUNqCjcJBMwsyp61G
----------- --------------------------------------------
-
-Commercial support and training
-===============================
-
-Commercial support and training is available from [web3labs](https://www.web3labs.com/).
-
diff --git a/docs/links_and_useful_resources.md b/docs/links_and_useful_resources.md
deleted file mode 100644
index ae76dd50a..000000000
--- a/docs/links_and_useful_resources.md
+++ /dev/null
@@ -1,14 +0,0 @@
-Links and Useful Resources
-==========================
-
--   Ethereum [Homestead Documentation](https://ethereum-homestead.readthedocs.io/en/latest/)
--   Ethereum [Wiki](https://github.com/ethereum/wiki/wiki)
--   Ethereum [JSON-RPC specification](https://github.com/ethereum/wiki/wiki/JSON-RPC)
--   Ethereum Yellow Paper on the [GitHub](https://github.com/ethereum/yellowpaper) repository
--   [Homestead](https://ethereum-homestead.readthedocs.org/en/latest/) docs
--   [Solidity](http://solidity.readthedocs.io/en/develop/) docs
--   [Layout of variables in storage](http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage)
--   [Ethereum tests](https://github.com/ethereum/tests) contains lots of common tests for clients
--   [Etherscan](https://etherscan.io) is very useful for exploring blocks and transactions, it also has a [testnetsite](https://testnet.etherscan.io)
--   [Ethstats](https://ethstats.net/) provides a useful network dashboard. There is also a dedicated [Parity dashboard](https://stats.parity.io/), [Rinkeby testnet dashboard](http://rinkeby.io/), and one for the [Kovan testnet](http://kovan-stats.parity.io/).
--   [Ethereum reddit](https://www.reddit.com/r/ethereum/)
diff --git a/docs/management_apis.md b/docs/management_apis.md
deleted file mode 100644
index adf3fa621..000000000
--- a/docs/management_apis.md
+++ /dev/null
@@ -1,26 +0,0 @@
-Management APIs
-===============
-
-In addition to implementing the standard [JSON-RPC](https://github.com/ethereum/wiki/wiki/JSON-RPC) API, Ethereum clients, such as [Geth](https://github.com/ethereum/go-ethereum/wiki/geth) and [Parity](https://github.com/paritytech/parity) provide additional management via JSON-RPC.
-
-One of the key common pieces of functionality that they provide is the ability to create and unlock Ethereum accounts for transacting on the network. In Geth and Parity, this is implemented in their Personal modules, details of which are available below:
-
--   [Parity](https://github.com/paritytech/parity/wiki/JSONRPC-personal-module)
--   [Geth](https://github.com/ethereum/go-ethereum/wiki/Management-APIs#personal)
-
-Support for the personal modules is available in web3j. Those methods that are common to both Geth and Parity reside in the [Admin](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/protocol/admin/Admin.java) module of web3j.
-
-You can initialise a new web3j connector that supports this module using the factory method:
-
-```Java
-Admin web3j = Admin.build(new HttpService());  // defaults to http://localhost:8545/
-PersonalUnlockAccount personalUnlockAccount = admin.personalUnlockAccount("0x000...", "a password").send();
-if (personalUnlockAccount.accountUnlocked()) {
-    // send a transaction
-}
-```
-
-For Geth specific methods, you can use the [Geth](https://github.com/web3j/web3j/blob/master/geth/src/main/java/org/web3j/protocol/geth/Geth.java) connector, and for Parity you can use the associated
-[Parity](https://github.com/web3j/web3j/blob/master/parity/src/main/java/org/web3j/protocol/parity/Parity.java) connector. The *Parity* connector also provides support for Parity's [Trace](https://github.com/paritytech/parity/wiki/JSONRPC-trace-module) module. These connectors are available in the web3j *geth* and *parity* modules respectively.
-
-You can refer to the integration test [ParityIT](https://github.com/web3j/web3j/blob/master/integration-tests/src/test/java/org/web3j/protocol/parity/ParityIT.java) for further examples of working with these APIs.
diff --git a/docs/modules.md b/docs/modules.md
deleted file mode 100644
index 7ac31b748..000000000
--- a/docs/modules.md
+++ /dev/null
@@ -1,35 +0,0 @@
-Modules
-=======
-
-To provide greater flexibility for developers wishing to work with web3j, the project is made up of a number of modules.
-
-In dependency order, they are as follows:
-
--   utils - Minimal set of utility classes
--   rlp - Recursive Length Prefix (RLP) encoders
--   abi - Application Binary Interface (ABI) encoders
--   crypto - cryptographic library for transaction signing and key/wallet management in Ethereum
--   tuples - Simple tuples library
--   core - Much like the previous web3j core artifact without the code generators
--   codegen - code generators
--   console - command-line tools
-
-The below modules only depend on the core module.
-
--   geth - Geth specific JSON-RPC module
--   parity - Parity specific JSON-RPC module
--   infura - Infura specific HTTP header support
--   contracts - Support for specific EIP's (Ethereum Improvement Proposals)
-
-For most use cases (interacting with the network and smart contracts) the *core* module should be all you need. The dependencies of the core module are very granular and only likely to be of use if your project is
-focussed on a very specific interaction with the Ethereum network (such as ABI/RLP encoding, transaction signing but not submission, etc).
-
-All modules are published to both Maven Central and Bintray, with the published artifact names using the names listed above, i.e.:
-
-For Java:
-
-   org.web3j: <module-name\> : <version\>
-
-For Android:
-
-   org.web3j: <module-name\> : <version\>-android
diff --git a/docs/projects_using_web3j.md b/docs/projects_using_web3j.md
deleted file mode 100644
index 403604eda..000000000
--- a/docs/projects_using_web3j.md
+++ /dev/null
@@ -1,8 +0,0 @@
-Projects using web3j
-====================
-
--   [EtherWallet](https://play.google.com/store/apps/details?id=org.vikulin.etherwallet) by [@vikulin](https://github.com/vikulin)
--   [eth-contract-api](https://github.com/adridadou/eth-contract-api) by [@adridadou](https://github.com/adridadou)
--   [Ethereum Paper Wallet](https://github.com/matthiaszimmermann/ethereum-paper-wallet) by [@matthiaszimmermann](https://github.com/matthiaszimmermann)
--   [web3j-scala](https://github.com/mslinn/web3j-scala) by [@mslinn](https://github.com/mslinn)
-
diff --git a/docs/quickstart.md b/docs/quickstart.md
deleted file mode 100644
index 3c0e8284c..000000000
--- a/docs/quickstart.md
+++ /dev/null
@@ -1,47 +0,0 @@
-Quickstart
-==========
-
-Web3j CLI
----------
-
-Install the Web3j binary.
-
-To get the latest version on Mac OS or Linux, type the following in your terminal:
-
-```bash
-curl -L https://get.web3j.io | sh
-```
-
-Then to create a new project, simply run:
-
-```bash
-web3j new
-```
-
-Or, to import an existing Solidity project into Web3j, run:
-
-```bash
-web3j import
-```
-
-Then to build your project run:
-
-```bash
-./gradlew build
-```
-
-For more information on using the Web3j CLI, head to the [CLI section](command_line_tools.md).
-
-
-Sample project
---------------
-
-A [web3j sample project](https://github.com/web3j/sample-project-gradle) is available that demonstrates a number of core features of Ethereum with web3j, including:
-
--   Connecting to a node on the Ethereum network
--   Loading an Ethereum wallet file
--   Sending Ether from one address to another
--   Deploying a smart contract to the network
--   Reading a value from the deployed smart contract
--   Updating a value in the deployed smart contract
--   Viewing an event logged by the smart contract
diff --git a/docs/recursive_length_prefix.md b/docs/recursive_length_prefix.md
deleted file mode 100644
index b58b3c28c..000000000
--- a/docs/recursive_length_prefix.md
+++ /dev/null
@@ -1,30 +0,0 @@
-Recursive Length Prefix
-=======================
-
-The Recursive Length Prefix (RLP) encoding scheme is a space efficient object serialization scheme used in Ethereum.
-
-The specification itself is defined in the [Yellow Paper](http://gavwood.com/paper.pdf), and the following page on the
-[Ethereum Wiki](https://github.com/ethereum/wiki/wiki/RLP).
-
-RLP Types
----------
-
-The RLP encoder defined two supported types:
-
--   string
--   list
-
-The list type can be nested an arbitrary number of times allowing
-complex data structures to be encoded.
-
-The [RLP module](https://github.com/web3j/web3j/tree/master/rlp) in web3j provides RLP encoding capabilities, with the [RlpEncoderTest](https://github.com/web3j/web3j/blob/master/rlp/src/test/java/org/web3j/rlp/RlpEncoderTest.java) demonstrating encoding of a number of different values.
-
-Transaction encoding
---------------------
-
-Within web3j, RLP encoding is used to encode Ethereum transaction objects into a byte array which is signed before submission to the network. The transaction types and signing logic are located within the Crypto module, with the [TransactionEncoderTest](https://github.com/web3j/web3j/blob/master/crypto/src/test/java/org/web3j/crypto/TransactionEncoderTest.java) providing examples of transaction signing and encoding.
-
-Dependencies
-------------
-
-This is a very lightweight module, with no other dependencies. The hope is that other projects wishing to work with Ethereum's RLP encoding on the JVM or Android will choose to make use of this module rather then write their own implementations.
diff --git a/docs/smart_contracts.md b/docs/smart_contracts.md
deleted file mode 100644
index 0fb217b5c..000000000
--- a/docs/smart_contracts.md
+++ /dev/null
@@ -1,340 +0,0 @@
-Smart Contracts
-===============
-
-Developers have the choice of three languages for writing smart contracts:
-
-[Solidity](https://Solidity.readthedocs.io/)
-
-> The flagship language of Ethereum, and most popular language for smart contracts.
-
-[Serpent](https://github.com/ethereum/wiki/wiki/Serpent)
-
-> A Python like language for writing smart contracts.
-
-LISP Like Language (LLL)
-
-> A low level language, Serpent provides a superset of LLL. There's not a great deal of information for       working with LLL, the following blog [/var/log/syrinx](http://blog.syrinx.net/) and associated [lll-resurrected GitHub](https://github.com/zigguratt/lll-resurrected) repository is a  good place to start.
-
-In order to deploy a smart contract onto the Ethereum blockchain, it must first be compiled into a bytecode format, then it can be sent as part of a transaction. web3j can do all of this for you with its [Solidity smart contract wrappers](#solidity-smart-contract-wrappers). To understand what is happening behind the scenes, you can refer to the details in [Creation of a smart contract](transactions.md#creation-of-a-smart-contract).
-
-Given that Solidity is the language of choice for writing smart contracts, it is the language supported by web3j, and is used for all subsequent examples.
-
-Getting started with Solidity
------------------------------
-
-An overview of Solidity is beyond the scope of these docs, however, the following resources are a good place to start:
-
--   [Contract Tutorial](https://github.com/ethereum/go-ethereum/wiki/Contract-Tutorial) on the Go Ethereum Wiki
--   [Introduction to Smart Contracts](http://Solidity.readthedocs.io/en/develop/introduction-to-smart-contracts.html) in the Solidity project documentation
--   [Writing a contract](https://ethereum-homestead.readthedocs.io/en/latest/contracts-and-transactions/contracts.html#writing-a-contract) in the Ethereum Homestead Guide
-
-Compiling Solidity source code 
-------------------------------
-
-Compilation to bytecode is performed by the Solidity compiler, *solc*. You can install the compiler, locally following the instructions as per [the project documentation](http://solidity.readthedocs.io/en/develop/installing-solidity.html).
-
-To compile the Solidity code run:
-
-``` bash
-$ solc <contract>.sol --bin --abi --optimize -o <output-dir>/
-```
-
-The *--bin* and *--abi* compiler arguments are both required to take full advantage of working with smart contracts from web3j.
-
-*--bin*
-
- Outputs a Solidity binary file containing the hex-encoded binary to provide with the transaction request. This is required only for *deploy* and *isValid* [Solidity smart contract wrappers](#solidity-smart-contract-wrappers) methods.
-
-*--abi*
-
- Outputs a Solidity [Application Binary Interface](application_binary_interface.md) file which details all of the publicly accessible contract methods and their associated parameters. These details along with the contract address are crucial for interacting with smart contracts. The ABI file is also used for the generation of [Solidity smart contract wrappers](#solidity-smart-contract-wrappers)
-
-There is also a *--gas* argument for providing estimates of the [Gas](transactions.md#gas) required to create a contract and transact with its methods.
-
-Alternatively, you can write and compile Solidity code in your browser via the [browser-solidity](https://remix.ethereum.org/#optimize=false&evmVersion=null&version=soljson-v0.5.1+commit.c8a2cb62.js) project. browser-solidity is great for smaller smart contracts, but you may run into issues working with larger contracts.
-
-You can also compile Solidity code via Ethereum clients such as Geth and Parity, using the JSON-RPC method [eth_compileSolidity](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_compileSolidity) which is also supported in web3j. However, the Solidity compiler must be
-installed on the client for this to work.
-
-There are further options available, please refer to the [relevant section](https://ethereum-homestead.readthedocs.io/en/latest/contracts-and-transactions/contracts.html#compiling-a-contract) in the Homestead documentation.
-
-Deploying and interacting with smart contracts
-----------------------------------------------
-
-If you want to avoid the underlying implementation detail for working with smart contracts, web3j provides [Solidity smart contract wrappers](#solidity-smart-contract-wrappers) which enable you to interact directly with all of a smart contract's methods via a generated wrapper object.
-
-Alternatively, if you wish to send regular transactions or have more control over your interactions with your smart contracts, please refer to the sections [Solidity smart contract wrappers](#solidity-smart-contract-wrappers), [Transacting with a smart contract](transactions.md#transacting-with-a-smart-contract) and [Querying the state of a smart contract](transactions.md#querying-the-state-of-a-smart-contract) for details.
-
-Smart contract examples
------------------------
-
-web3j provides a number of smart contract examples in the project directory [codegen/src/test/resources/solidity](https://github.com/web3j/web3j/tree/master/codegen/src/test/resources/solidity)
-
-It also provides integration tests for demonstrating the deploying and working with those smart contracts in the [integration-tests/src/test/java/org/web3j/protocol/scenarios](https://github.com/web3j/web3j/tree/master/integration-tests/src/test/java/org/web3j/protocol/scenarios) module.
-
-![image](img/smart_contract.png)
-
-EIP-20 Ethereum token standard smart contract 
----------------------------------------------
-
-There an Ethereum standard, [EIP-20](https://github.com/ethereum/EIPs/issues/20) which started off as an [Ethereum Improvement Proposal
-(EIP)](https://github.com/ethereum/EIPs), that defines the standard functions that a smart contract providing tokens should implement.
-
-The EIP-20 standard provides function definitions, but does not provide an implementation example. However, there is an implementation provided in
-[codegen/src/test/resources/solidity/contracts](https://github.com/web3j/web3j/tree/master/codegen/src/test/resources/solidity/contracts), which has been taken from ConsenSys' [Tokens project](https://github.com/ConsenSys/Tokens).
-
-Open Zepplin also provide an example implementation on [GitHub](https://github.com/OpenZeppelin/zeppelin-solidity/tree/master/contracts/token).
-
-There are two integration tests that have been written to fully demonstrate the functionality of this token smart contract.
-
-[HumanStandardTokenGeneratedIT](https://github.com/web3j/web3j/tree/master/integration-tests/src/test/java/org/web3j/protocol/scenarios/HumanStandardTokenGeneratedIT.java) uses the generated HumanStandardTokenGenerated [Solidity smart contract wrappers](#solidity-smart-contract-wrappers) to demonstrate this.
-
-Alternatively, if you do not wish to use a smart contract wrapper and would like to work directly with the underlying JSON-RPC calls, please refer to [HumanStandardTokenIT](https://github.com/web3j/web3j/tree/master/integration-tests/src/test/java/org/web3j/protocol/scenarios/HumanStandardTokenIT.java).
-
-Solidity smart contract wrappers
---------------------------------
-
-web3j supports the auto-generation of smart contract function wrappers in Java from Solidity ABI files.
-
-The web3j [Command Line Tools](command_line_tools.md) tools ship with a command line utility for generating the smart contract function wrappers:
-
-``` bash
-$ web3j solidity generate [-hV] [-jt] [-st] -a=<abiFile> [-b=<binFile>] -o=<destinationFileDir> -p=<packageName>
-
-   -h, --help                        Show this help message and exit.
-   -V, --version                     Print version information and exit.
-   -jt, --javaTypes                  use native java types. Default: true
-   -st, --solidityTypes              use solidity types.
-   -a, --abiFile=<abiFile>           abi file with contract definition.
-   -b, --binFile=<binFile>           optional bin file with contract compiled code in order to generate deploy methods.
-   -o, --outputDir=<destinationFileDir> destination base directory.
-   -p, --package=<packageName>       base package name.
-```
-
-BinFile is required for [Contract validity](#contract-validity)
-
-In versions prior to 3.x of web3j, the generated smart contract wrappers used native Solidity types. From web3j 3.x onwards, Java types are created by default. You can create Solidity types using the *--solidityTypes* command line argument.
-
-You can also generate the wrappers by calling the Java class directly:
-
-``` bash
-org.web3j.codegen.SolidityFunctionWrapperGenerator -b /path/to/<smart-contract>.bin -a /path/to/<smart-contract>.abi -o /path/to/src/main/java -p com.your.organisation.name
-```
-
-Where the *bin* and *abi* are obtained as per [Compiling Solidity sourse code](#compiling-solidity-source-code)
-
-The native Java to Solidity type conversions used are detailed in the [Application Binary Interface](application_binary_interface.md) section.
-
-The smart contract wrappers support all common operations for working with smart contracts:
-
--   [Construction and deployment](#construction-and-deployment)
--   [Invoking transactions and events](#invoking-transactions-and-events)
--   [Calling constant methods](#calling-constant-methods)
--   [Contract validity](#contract-validity)
-
-Any method calls that requires an underlying JSON-RPC call to take place will return a Future to avoid blocking.
-
-web3j also supports the generation of Java smart contract function wrappers directly from [Truffle's](http://truffleframework.com/) [Contract
-Schema](https://github.com/trufflesuite/truffle/tree/develop/packages/truffle-contract-schema) via the [Command Line Tools](command_line_tools.md) utility.
-
-``` bash
-$ web3j truffle generate [--javaTypes|--solidityTypes] /path/to/<truffle-smart-contract-output>.json -o /path/to/src/main/java -p com.your.organisation.name
-```
-
-And this also can be invoked by calling the Java class:
-
-``` bash
-org.web3j.codegen.TruffleJsonFunctionWrapperGenerator /path/to/<truffle-smart-contract-output>.json -o /path/to/src/main/java -p com.your.organisation.name
-```
-
-A wrapper generated this way is "enhanced" to expose the per-network deployed address of the contract. These addresses are from the truffle deployment at the time the wrapper is generared.
-
-Construction and deployment
----------------------------
-
-Construction and deployment of smart contracts happens with the *deploy* method:
-
-```java
-YourSmartContract contract = YourSmartContract.deploy(
-        <web3j>, <credentials>, GAS_PRICE, GAS_LIMIT,
-        [<initialValue>,]
-        <param1>, ..., <paramN>).send();
-```
-
-This will create a new instance of the smart contract on the Ethereum blockchain using the supplied credentials, and constructor parameter values.
-
-The *<initialValue\>* parameter is only required if your smart contract accepts Ether on construction. This requires the Solidity [payable](https://solidity.readthedocs.io/en/v0.5.10/contracts.html#function-modifiers) modifier to be present in the contract.
-
-It returns a new smart contract wrapper instance which contains the underlying address of the smart contract. If you wish to construct an instance of a smart contract wrapper with an existing smart contract,
-simply pass in it's address:
-
-```java
-YourSmartContract contract = YourSmartContract.load(
-        "0x<address>|<ensName>", web3j, credentials, GAS_PRICE, GAS_LIMIT);
-```
-
-Contract validity
------------------
-
-Using this method, you may want to ascertain that the contract address that you have loaded is the smart contract that you expect. For this you can use the *isValid* smart contract method, which will only return true
-if the deployed bytecode at the contract address matches the bytecode in the smart contract wrapper.:
-
-```java
-contract.isValid();  // returns false if the contract bytecode does not match what's deployed
-                     // at the provided address
-```
-
-Note: Contract wrapper has to be generated with *--bin* for this to work.
-
-Transaction Managers
---------------------
-
-web3j provides a [TransactionManager](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/tx/TransactionManager.java) abstraction to control the manner you connect to Ethereum clients with. The default mechanism uses web3j's [RawTransactionManager](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/tx/RawTransactionManager.java) which works with Ethereum wallet files to sign transactions offline before submitting them to the network.
-
-However, you may wish to modify the transaction manager, which you can pass to the smart contract deployment and creation methods instead of a credentials object, i.e.:
-
-```java
-YourSmartContract contract = YourSmartContract.deploy(
-        <web3j>, <transactionManager>, GAS_PRICE, GAS_LIMIT,
-        <param1>, ..., <paramN>).send();
-```
-
-In addition to the RawTransactionManager, web3j provides a [ClientTransactionManager](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/tx/ClientTransactionManager.java) which passes the responsibility of signing your transaction on to the Ethereum client you are connecting to.
-
-There is also a [ReadonlyTransactionManager](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/tx/ReadonlyTransactionManager.java) for when you only want to retrieve data from a smart contract, but not transact with it.
-
-Specifying the Chain Id on Transactions (EIP-155)
--------------------------------------------------
-
-The RawTransactionManager takes an optional *chainId* parameter to specify the chain id to be used on transactions as per [EIP-155](https://github.com/ethereum/EIPs/issues/155). This prevents transactions from one chain being re-broadcast onto another chain, such as from Ropsten to Mainnet:
-
-```java
-TransactionManager transactionManager = new RawTransactionManager(
-        web3j, credentials, ChainId.MAINNET);
-```
-
-In order to avoid having to change config or code to specify which chain you are working with, web3j's default behaviour is to not specify chain ids on transactions to simplify working with the library. However, the recommendation of the Ethereum community is to use them.
-
-You can obtain the chain id of the network that your Ethereum client is connected to with the following request:
-
-```java
-web3j.netVersion().send().getNetVersion();
-```
-
-Transaction Receipt Processors
-------------------------------
-
-By default, when a new transaction is submitted by web3j to an Ethereum client, web3j will continually poll the client until it receives a [TransactionReceipt](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/protocol/core/methods/response/TransactionReceipt.java), indicating that the transaction has been added to the blockchain. If you are sending a number of transactions asynchronously with web3j, this can result in a number of threads polling the client concurrently.
-
-To reduce this polling overhead, web3j provides configurable [TransactionReceiptProcessors](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/tx/response/TransactionReceiptProcessor.java).
-
-There are a number of processors provided in web3j:
-
--   [PollingTransactionReceiptProcessor](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/tx/response/PollingTransactionReceiptProcessor.java) is the default processor used in web3j, which polls periodically for a transaction receipt for each individual pending transaction.
--   [QueuingTransactionReceiptProcessor](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/tx/response/QueuingTransactionReceiptProcessor.java) has an internal queue of all pending transactions. It contains a
-    worker that runs periodically to query if a transaction receipt is available yet. If a receipt is found, a callback to the client is invoked.
--   [NoOpProcessor](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/tx/response/NoOpProcessor.java) provides an [EmptyTransactionReceipt](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/tx/response/EmptyTransactionReceipt.java) to clients which only contains the transaction hash. This is for clients who do not want web3j to perform any polling for a transaction receipt.
-
-**Note:** the
-[EmptyTransactionReceipt](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/tx/response/EmptyTransactionReceipt.java) is also provided in the the initial response from the [QueuingTransactionReceiptProcessor](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/tx/response/QueuingTransactionReceiptProcessor.java). This allows the caller to have the transaction hash for the transaction
-that was submitted to the network.
-
-If you do not wish to use the default processor([PollingTransactionReceiptProcessor](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/tx/response/PollingTransactionReceiptProcessor.java)), you can specify the transaction receipt processor to use as follows:
-
-```java
-TransactionReceiptProcessor transactionReceiptProcessor =
-        new QueuingTransactionReceiptProcessor(web3j, new Callback() {
-                 @Override
-                 public void accept(TransactionReceipt transactionReceipt) {
-                     // process transactionReceipt
-                 }
-
-                 @Override
-                 public void exception(Exception exception) {
-                     // handle exception
-                 }
-TransactionManager transactionManager = new RawTransactionManager(
-        web3j, credentials, ChainId.MAINNET, transactionReceiptProcessor);
-```
-
-If you require further information, the [FastRawTransactionManagerIT](https://github.com/web3j/web3j/blob/master/integration-tests/src/test/java/org/web3j/protocol/scenarios/FastRawTransactionManagerIT.java) demonstrates the polling and queuing approaches.
-
-Invoking transactions and events 
---------------------------------
-
-All transactional smart contract methods are named identically to their Solidity methods, taking the same parameter values. Transactional calls do not return any values, regardless of the return type specified on the method. Hence, for all transactional methods the [Transaction Receipt](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_gettransactionreceipt) associated with the transaction is returned.:
-
-```java
-TransactionReceipt transactionReceipt = contract.someMethod(
-             <param1>,
-             ...).send();
-```
-
-The transaction receipt is useful for two reasons:
-
-1.  It provides details of the mined block that the transaction resides in
-2.  [Solidity events](http://Solidity.readthedocs.io/en/develop/contracts.html?highlight=events#events) that are called will be logged as part of the transaction, which can then be extracted
-
-Any events defined within a smart contract will be represented in the smart contract wrapper with a method named *process<Event Name\>Event*, which takes the Transaction Receipt and from this extracts the indexed and non-indexed event parameters, which are returned decoded in an
-instance of the [EventValues](https://github.com/web3j/web3j/blob/master/abi/src/main/java/org/web3j/abi/EventValues.java) object.:
-
-```java
-EventValues eventValues = contract.processSomeEvent(transactionReceipt);
-```
-
-Alternatively you can use an Flowable filter instead which will listen for events associated with the smart contract:
-
-```java
-contract.someEventFlowable(startBlock, endBlock).
-        .subscribe(event -> ...);
-```
-
-For more information on working with Flowable filters, refer to [Filters and Events](filters_and_events.md).
-
-**Remember** that for any indexed array, bytes and string Solidity parameter types, a Keccak-256 hash of their values will be returned, see the [documentation](http://Solidity.readthedocs.io/en/latest/contracts.html#events) for further information.
-
-Calling constant methods
-------------------------
-
-Constant methods are those that read a value in a smart contract, and do not alter the state of the smart contract. These methods are available with the same method signature as the smart contract they were generated from:
-
-```java
-Type result = contract.someMethod(<param1>, ...).send();
-```
-
-Dynamic gas price and limit 
----------------------------
-
-When working with smart contracts you may want to specify different gas price and limit values depending on the function being invoked. You can do that by creating your own [ContractGasProvider](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/tx/gas/ContractGasProvider.java) for the smart contract wrapper.
-
-Every generated wrapper contains all smart contract method names listed as a constants, which facilitates compilation-time matching via a *switch* statement.
-
-For example, using the [Greeter](https://github.com/web3j/web3j/blob/master/codegen/src/test/resources/solidity/greeter/Greeter.sol) contract:
-
-```java
-Greeter greeter = new Greeter(...);
-greeter.setGasProvider(new DefaultGasProvider() {
-    @Override
-    public BigInteger getGasPrice(String contractFunc) {
-        switch (contractFunc) {
-            case Greeter.FUNC_GREET: return BigInteger.valueOf(22_000_000_000L);
-            case Greeter.FUNC_KILL: return BigInteger.valueOf(44_000_000_000L);
-            default: throw new NotImplementedException();
-        }
-    }
-
-    @Override
-    public BigInteger getGasLimit(String contractFunc) {
-        switch (contractFunc) {
-            case Greeter.FUNC_GREET: return BigInteger.valueOf(4_300_000);
-            case Greeter.FUNC_KILL: return BigInteger.valueOf(5_300_000);
-            default: throw new NotImplementedException();
-        }
-    }
-});
-```
-
-Examples
---------
-
-Please refer to [EIP-20 Ethereum token standard smart contract](#eip-20-ethereum-token-standard-smart-contract)
diff --git a/docs/stylesheets/extra.css b/docs/stylesheets/extra.css
deleted file mode 100644
index 7ab7c11a9..000000000
--- a/docs/stylesheets/extra.css
+++ /dev/null
@@ -1,4 +0,0 @@
-.md-header-nav__button img {
-  width: 18px;
-  height: 24px;
-}
diff --git a/docs/thanks_and_credits.md b/docs/thanks_and_credits.md
deleted file mode 100644
index a648844d1..000000000
--- a/docs/thanks_and_credits.md
+++ /dev/null
@@ -1,9 +0,0 @@
-Thanks and Credits
-==================
-
--   The [Nethereum](https://github.com/Nethereum/Nethereum) project for the inspiration
--   [Othera](https://www.othera.com.au/) for the great things they are building on the platform
--   [Finhaus](http://finhaus.com.au/) guys for putting me onto Nethereum
--   [bitcoinj](https://bitcoinj.github.io/) for the reference Elliptic Curve crypto implementation
--   Everyone involved in the Ethererum project and its surrounding ecosystem
--   And of course the users of the library, who've provided valuable input & feedback
diff --git a/docs/transactions.md b/docs/transactions.md
deleted file mode 100644
index daa2ae185..000000000
--- a/docs/transactions.md
+++ /dev/null
@@ -1,409 +0,0 @@
-# Transactions
-
-Broadly speaking there are three types transactions supported on Ethereum:
-
-1.  [Transfer of Ether from one party to another](#transfer-of-ether-from-one-party-to-another)
-2.  [Creation of a smart contract](#creation-of-a-smart-contract)
-3.  [Transacting with a smart contract](#transacting-with-a-smart-contract)
-
-To undertake any of these transactions, it is necessary to have Ether (the fuel of the Ethereum blockchain) residing in the Ethereum account which the transactions are taking place from. This is to pay for the [Gas](#gas) costs, which is the transaction execution cost for the Ethereum client that performs the transaction on your behalf, comitting the result to the Ethereum blockchain. Instructions for obtaining Ether are described below in [Obtaining Ether](#obtaining-ether)
-
-Additionally, it is possible to query the state of a smart contract, this is described in [Querying the state of a smart contract](#querying-the-state-of-a-smart-contract)
-
-![image](img/web3j_transaction.png)
-
-## Obtaining Ether
-
-To obtain Ether you have two options:
-
-1.  Mine it yourself
-2.  Obtain Ether from another party
-
-Mining it yourself in a private environment, or the public test environment (testnet) is very straight forwards. However, in the main live environment (mainnet) it requires significant dedicated GPU time
-which is not likely to be feasible unless you already have a gaming PC with multiple dedicated GPUs. If you wish to use a private environment, there is some guidance on the [Homestead
-documentation](https://ethereum-homestead.readthedocs.io/en/latest/network/test-networks.html#id3).
-
-To purchase Ether you will need to go via an exchange. As different regions have different exchanges, you will need to research the best location for this yourself. The [Homestead documentation](https://ethereum-homestead.readthedocs.io/en/latest/ether.html#list-of-centralised-exchange-marketplaces) contains a number of exchanges which is a good place to start.
-
-## Ethereum testnets
-
-There are a number of dedicated test networks in Ethereum, which are
-supported by various clients.
-
-- Rinkeby (Geth only)
-- Kovan (Parity only)
-- Ropsten (Geth and Parity)
-
-For development, its recommended you use the Rinkeby or Kovan test networks. This is because they use a Proof of Authority (PoA) consensus mechanism, ensuring transactions and blocks are created in a consistent and timely manner. The Ropsten testnet, although closest to the Mainnet as it uses Proof of Work (PoW) consensus, has been subject to attacks in the past and tends to be more problematic for developers.
-
-You can request Ether for the Rinkeby testnet via the Rinkeby Crypto Faucet, available at <https://www.rinkeby.io/>.
-
-Details of how to request Ether for the Kovan testnet are available [here](https://github.com/kovan-testnet/faucet).
-
-If you need some Ether on the Ropsten testnet to get started, please post a message with your wallet address to the [web3j Gitter channel](https://gitter.im/web3j/web3j) and you will be sent some.
-
-## Mining on testnet/private blockchains
-
-In the Ethereum test environment (testnet), the mining difficulty is set lower then the main environment (mainnet). This means that you can mine new Ether with a regular CPU, such as your laptop. What you'll need to do is run an Ethereum client such as Geth or Parity to start building up reserves. Further instructions are available on the respective sites.
-
-Geth
-
-<https://github.com/ethereum/go-ethereum/wiki/Mining>
-
-Parity
-
-<https://github.com/paritytech/parity/wiki/Mining>
-
-Once you have mined some Ether, you can start transacting with the blockchain.
-
-However, as mentioned [above](#ethereum-testnets) it's simpler to use the Kovan or Rinkeby test networks.
-
-## Gas
-
-When a transaction takes place in Ethereum, a transaction cost must be paid to the client that executes the transaction on your behalf, committing the output of this transaction to the Ethereum blockchain.
-
-This cost is measure in gas, where gas is the number of instructions used to execute a transaction in the Ethereum Virtual Machine. Please refer to the [Homestead
-documentation](http://ethdocs.org/en/latest/contracts-and-transactions/account-types-gas-and-transactions.html?highlight=gas#what-is-gas) for further information.
-
-What this means for you when working with Ethereum clients is that there are two parameters which are used to dictate how much Ether you wish to spend in order for a tranaction to complete:
-
-_Gas price_
-
-> This is the amount you are prepared in Ether per unit of gas. web3j
-> uses a default price of 22,000,000,000 Wei (22 x 10^-8^ Ether). This
-> is defined in
-> [ManagedTransaction](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/tx/ManagedTransaction.java).
-
-_Gas limit_
-
-> This is the total amount of gas you are happy to spend on the
-> transaction execution. There is an upper limit of how large a single
-> transaction can be in an Ethereum block which restricts this value
-> typically to less then 6,700,000. The current gas limit is visible at
-> <https://ethstats.net/>.
-
-These parameters taken together dictate the maximum amount of Ether you are willing to spend on transaction costs. i.e. you can spend no more then gas price \* gas limit. The gas price can also affect how quickly a transaction takes place depending on what other transactions are available with a more profitable gas price for miners.
-
-You may need to adjust these parameters to ensure that transactions take place in a timely manner.
-
-## Transaction mechanisms
-
-When you have a valid account created with some Ether, there are two mechanisms you can use to transact with Ethereum.
-
-1.  [Transaction signing via an Ethereum client](#transaction-signing-via-an-ethereum-client)
-2.  [Offline transaction signing](#offline-transaction-signing)
-
-Both mechanisms are supported via web3j.
-
-## Transaction signing via an Ethereum client
-
-In order to transact via an Ethereum client, you first need to ensure that the client you're transacting with knows about your wallet address. You are best off running your own Ethereum client such as Geth/Parity in order to do this. Once you have a client running, you can
-create a wallet via:
-
-- The [GethWiki](https://github.com/ethereum/go-ethereum/wiki/Managing-your-accounts) contains a good run down of the different mechanisms Geth supports such as importing private key files, and creating a new account via it's console
-- Alternatively you can use a JSON-RPC admin command for your client, such as _personal_newAccount_ for
-  [Parity](https://github.com/paritytech/parity/wiki/JSONRPC-personal-module#personal_newaccount) or [Geth](https://github.com/ethereum/go-ethereum/wiki/Management-APIs#personal_newaccount)
-
-With your wallet file created, you can unlock your account via web3j by first of all creating an instance of web3j that supports Parity/Geth admin commands:
-
-```java
-Admin web3j = Admin.build(new HttpService());
-```
-
-Then you can unlock the account, and providing this was successful, send a transaction:
-
-```java
-PersonalUnlockAccount personalUnlockAccount = web3j.personalUnlockAccount("0x000...", "a password").send();
-if (personalUnlockAccount.accountUnlocked()) {
-    // send a transaction
-}
-```
-
-Transactions for sending in this manner should be created via [EthSendTransaction](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/protocol/core/methods/response/EthSendTransaction.java),
-with the [Transaction](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/protocol/core/methods/request/Transaction.java) type:
-
-```java
-Transaction transaction = Transaction.createContractTransaction(
-              <from address>,
-              <nonce>,
-              BigInteger.valueOf(<gas price>),  // we use default gas limit
-              "0x...<smart contract code to execute>"
-      );
-
-      org.web3j.protocol.core.methods.response.EthSendTransaction
-              transactionResponse = parity.ethSendTransaction(ethSendTransaction)
-              .send();
-
-      String transactionHash = transactionResponse.getTransactionHash();
-
-      // poll for transaction response via org.web3j.protocol.Web3j.ethGetTransactionReceipt(<txHash>)
-```
-
-Where the _<nonce\>_ value is obtained as per [below](#the-transaction-nonce)
-
-Please refer to the integration test [DeployContractIT](https://github.com/web3j/web3j/blob/master/integration-tests/src/test/java/org/web3j/protocol/scenarios/DeployContractIT.java) and its superclass [Scenario](https://github.com/web3j/web3j/blob/master/integration-tests/src/test/java/org/web3j/protocol/scenarios/Scenario.java) for further details of this transaction workflow.
-
-Further details of working with the different admin commands supported by web3j are available in the section
-[Managment APIs](management_apis.md).
-
-## Offline transaction signing
-
-If you'd prefer not to manage your own Ethereum client, or do not want to provide wallet details such as your password to an Ethereum client, then offline transaction signing is the way to go.
-
-Offline transaction signing allows you to sign a transaction using your Ethereum Ethereum wallet within web3j, allowing you to have complete control over your private credentials. A transaction created offline can then be sent to any Ethereum client on the network, which will propagate the transaction out to other nodes, provided it is a valid transaction.
-
-You can also perform out of process transaction signing if required. This can be achieved by overriding the _sign_ method in [ECKeyPair](https://github.com/web3j/web3j/blob/master/crypto/src/main/java/org/web3j/crypto/ECKeyPair.java#L41).
-
-## Creating and working with wallet files 
-
-In order to sign transactions offline, you need to have either your Ethereum wallet file or the public and private keys associated with an Ethereum wallet/account.
-
-web3j is able to both generate a new secure Ethereum wallet file for you, or work with an existing wallet file.
-
-To create a new wallet file:
-
-```java
-String fileName = WalletUtils.generateNewWalletFile(
-        "your password",
-        new File("/path/to/destination"));
-```
-
-To load the credentials from a wallet file:
-
-```java
-Credentials credentials = WalletUtils.loadCredentials(
-        "your password",
-        "/path/to/walletfile");
-```
-
-These credentials are then used to sign transactions.
-
-Please refer to the [Web3 Secret Storage Definition](https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition) for the full wallet file specification.
-
-## Signing transactions
-
-Transactions to be used in an offline signing capacity, should use the [RawTransaction](https://github.com/web3j/web3j/blob/master/crypto/src/main/java/org/web3j/crypto/RawTransaction.java) type for this purpose. The RawTransaction is similar to the previously mentioned Transaction type, however it does not require a _from_ address, as this can be inferred from the signature.
-
-In order to create and sign a raw transaction, the sequence of events is as follows:
-
-1.  Identify the next available [nonce](#the-transaction-nonce) for the sender account
-2.  Create the RawTransaction object
-3.  Encode the RawTransaction object using [Recursive Length Prefix](#) encoding
-4.  Sign the RawTransaction object
-5.  Send the RawTransaction object to a node for processing
-
-The nonce is an increasing numeric value which is used to uniquely identify transactions. A nonce can only be used once and until a transaction is mined, it is possible to send multiple versions of a transaction with the same nonce, however, once mined, any subsequent submissions will be rejected.
-
-Once you have obtained the next available [nonce](#the-transaction-nonce), the value can then be used to create your transaction object:
-
-```java
-RawTransaction rawTransaction  = RawTransaction.createEtherTransaction(
-             nonce, <gas price>, <gas limit>, <toAddress>, <value>);
-```
-
-The transaction can then be signed and encoded:
-
-```java
-byte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, <credentials>);
-String hexValue = Numeric.toHexString(signedMessage);
-```
-
-Where the credentials are those loaded as per [Creating and working with wallet files](#creating-and-working-with-wallet-files)
-
-The transaction is then sent using [eth_sendRawTransaction](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sendrawtransaction):
-
-```java
-EthSendTransaction ethSendTransaction = web3j.ethSendRawTransaction(hexValue).sendAsync().get();
-String transactionHash = ethSendTransaction.getTransactionHash();
-// poll for transaction response via org.web3j.protocol.Web3j.ethGetTransactionReceipt(<txHash>)
-```
-
-Please refer to the integration test [CreateRawTransactionIT](https://github.com/web3j/web3j/blob/master/integration-tests/src/test/java/org/web3j/protocol/scenarios/CreateRawTransactionIT.java) for a full example of creating and sending a raw transaction.
-
-## The transaction nonce 
-
-The nonce is an increasing numeric value which is used to uniquely identify transactions. A nonce can only be used once and until a transaction is mined, it is possible to send multiple versions of a transaction with the same nonce, however, once mined, any subsequent submissions will be rejected.
-
-You can obtain the next available nonce via the [eth_getTransactionCount](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_gettransactioncount) method:
-
-```java
-EthGetTransactionCount ethGetTransactionCount = web3j.ethGetTransactionCount(
-             address, DefaultBlockParameterName.LATEST).sendAsync().get();
-
-     BigInteger nonce = ethGetTransactionCount.getTransactionCount();
-```
-
-The nonce can then be used to create your transaction object:
-
-```java
-RawTransaction rawTransaction  = RawTransaction.createEtherTransaction(
-             nonce, <gas price>, <gas limit>, <toAddress>, <value>);
-```
-
-## Transaction types
-
-The different types of transaction in web3j work with both Transaction and RawTransaction objects. The key difference is that Transaction objects must always have a from address, so that the Ethereum client
-which processes the [eth_sendTransaction](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sendtransaction) request know which wallet to use in order to sign and send the
-transaction on the message senders behalf. As mentioned [above](#offline-transaction-signing), this is not necessary for raw transactions which are signed offline.
-
-The subsequent sections outline the key transaction attributes required for the different transaction types. The following attributes remain constant for all:
-
-- Gas price
-- Gas limit
-- Nonce
-- From
-
-Transaction and RawTransaction objects are used interchangeably in all of the subsequent examples.
-
-## Transfer of Ether from one party to another
-
-The sending of Ether between two parties requires a minimal number of details of the transaction object:
-
-_to_
-
- the destination wallet address
-
-_value_
-
-  the amount of Ether you wish to send to the destination address
-
-```java
-BigInteger value = Convert.toWei("1.0", Convert.Unit.ETHER).toBigInteger();
-RawTransaction rawTransaction  = RawTransaction.createEtherTransaction(
-             <nonce>, <gas price>, <gas limit>, <toAddress>, value);
-// send...
-```
-
-However, it is recommended that you use the [Transfer class](https://github.com/web3j/web3j/blob/master/core/src/main/java/org/web3j/tx/Transfer.java) for sending Ether, which takes care of the nonce management and polling for a response for you:
-
-```java
-Web3j web3 = Web3j.build(new HttpService());  // defaults to http://localhost:8545/
-Credentials credentials = WalletUtils.loadCredentials("password", "/path/to/walletfile");
-TransactionReceipt transactionReceipt = Transfer.sendFunds(
-        web3, credentials, "0x<address>|<ensName>",
-        BigDecimal.valueOf(1.0), Convert.Unit.ETHER).send();
-```
-
-## Recommended approach for working with smart contracts
-
-When working with smart contract wrappers as outlined below, you will have to perform all of the conversions from Solidity to native Java types manually. It is far more effective to use web3j's
-[Solidity smart contract wrappers](smart_contracts.md#solidity-smart-contract-wrappers) which take care of all code generation and this conversion for you.
-
-## Creation of a smart contract
-
-To deploy a new smart contract, the following attributes will need to be provided
-
-_value_
-
- the amount of Ether you wish to deposit in the smart contract
- (assumes zero if not provided)
-
-_data_
-
- the hex formatted, compiled smart contract creation code
-
-```java
-// using a raw transaction
-RawTransaction rawTransaction = RawTransaction.createContractTransaction(
-        <nonce>,
-        <gasPrice>,
-        <gasLimit>,
-        <value>,
-        "0x <compiled smart contract code>");
-// send...
-
-// get contract address
-EthGetTransactionReceipt transactionReceipt =
-             web3j.ethGetTransactionReceipt(transactionHash).send();
-
-if (transactionReceipt.getTransactionReceipt.isPresent()) {
-    String contractAddress = transactionReceipt.get().getContractAddress();
-} else {
-    // try again
-}
-```
-
-If the smart contract contains a constructor, the associated constructor field values must be encoded and appended to the _compiled smart
-contract code_:
-
-```java
-String encodedConstructor =
-             FunctionEncoder.encodeConstructor(Arrays.asList(new Type(value), ...));
-
-// using a regular transaction
-Transaction transaction = Transaction.createContractTransaction(
-        <fromAddress>,
-        <nonce>,
-        <gasPrice>,
-        <gasLimit>,
-        <value>,
-        "0x <compiled smart contract code>" + encodedConstructor);
-
-// send...
-```
-
-## Transacting with a smart contract
-
-To transact with an existing smart contract, the following attributes will need to be provided:
-
-_to_
-
- the smart contract address
-
-_value_
-
- the amount of Ether you wish to deposit in the smart contract (if
- the smart contract accepts ether)
-
-_data_
-
- the encoded function selector and parameter arguments
-
-web3j takes care of the function encoding for you, for further details on the implementation refer to the [Application Binary Interface](application_binary_interface.md) section.
-
-```java
-Function function = new Function<>(
-             "functionName",  // function we're calling
-             Arrays.asList(new Type(value), ...),  // Parameters to pass as Solidity Types
-             Arrays.asList(new TypeReference<Type>() {}, ...));
-
-String encodedFunction = FunctionEncoder.encode(function)
-Transaction transaction = Transaction.createFunctionCallTransaction(
-             <from>, <gasPrice>, <gasLimit>, contractAddress, <funds>, encodedFunction);
-
-org.web3j.protocol.core.methods.response.EthSendTransaction transactionResponse =
-             web3j.ethSendTransaction(transaction).sendAsync().get();
-
-String transactionHash = transactionResponse.getTransactionHash();
-
-// wait for response using EthGetTransactionReceipt...
-```
-
-It is not possible to return values from transactional functional calls, regardless of the return type of the message signature. However, it is possible to capture values returned by functions using filters. Please
-refer to the [Filters and Events](filters_and_events.md) section for details.
-
-## Querying the state of a smart contract 
-
-This functionality is facilitated by the [eth_call](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_call) JSON-RPC call.
-
-eth_call allows you to call a method on a smart contract to query a value. There is no transaction cost associated with this function, this is because it does not change the state of any smart contract method's
-called, it simply returns the value from them:
-
-```java
-Function function = new Function<>(
-             "functionName",
-             Arrays.asList(new Type(value)),  // Solidity Types in smart contract functions
-             Arrays.asList(new TypeReference<Type>() {}, ...));
-
-String encodedFunction = FunctionEncoder.encode(function)
-org.web3j.protocol.core.methods.response.EthCall response = web3j.ethCall(
-             Transaction.createEthCallTransaction(<from>, contractAddress, encodedFunction),
-             DefaultBlockParameterName.LATEST)
-             .sendAsync().get();
-
-List<Type> someTypes = FunctionReturnDecoder.decode(
-             response.getValue(), function.getOutputParameters());
-```
-
-**Note:** If an invalid function call is made, or a null result is obtained, the return value will be an instance of
-[Collections.emptyList()](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#emptyList--)
diff --git a/docs/troubleshooting.md b/docs/troubleshooting.md
deleted file mode 100644
index 61c434401..000000000
--- a/docs/troubleshooting.md
+++ /dev/null
@@ -1,135 +0,0 @@
-Troubleshooting
-===============
-
-Do you have a sample web3j project
-----------------------------------
-
-Yes, refer to the web3j sample project outlined in the [Quickstart](quickstart.md).
-
-I'm submitting a transaction, but it's not being mined
---------------------------------------------------------
-
-After creating and sending a transaction, you receive a transaction hash, however calling [eth_getTransactionReceipt](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_gettransactionreceipt) always returns a blank value, indicating the transaction has not been
-mined:
-
-```java
-String transactionHash = sendTransaction(...);
-
-// you loop through the following expecting to eventually get a receipt once the transaction
-// is mined
-EthGetTransactionReceipt.TransactionReceipt transactionReceipt =
-        web3j.ethGetTransactionReceipt(transactionHash).sendAsync().get();
-
-if (!transactionReceipt.isPresent()) {
-    // try again, ad infinitum
-}
-```
-
-However, you never receive a transaction receipt. Unfortunately there may not be a an error in your Ethereum client indicating any issues with the transaction:
-
-```java
-I1025 18:13:32.817691 eth/api.go:1185] Tx(0xeaac9aab7f9aeab189acd8714c5a60c7424f86820884b815c4448cfcd4d9fc79) to: 0x9c98e381edc5fe1ac514935f3cc3edaa764cf004
-```
-
-The easiest way to see if the submission is waiting to mined is to refer to Etherscan and search for the address the transaction was sent using <https://testnet.etherscan.io/address/0x>\... If the submission has been successful it should be visible in Etherscan within seconds of you performing the transaction submission. The wait is for the mining to take place.
-
-![image](img/pending_transaction.png)
-
-
-
-If there is no sign of it then the transaction has vanished into the ether (sorry). The likely cause of this is likely to be to do with the transaction's nonce either not being set, or being too low. Please refer to the section [Transaction nonce](transactions.md#the-transaction-nonce) for more information.
-
-I want to see details of the JSON-RPC requests and responses
-------------------------------------------------------------
-
-web3j uses the [SLF4J](https://www.slf4j.org/) logging facade, which you can easily integrate with your preferred logging framework. One lightweight approach is to use [LOGBack](https://logback.qos.ch/), which is already configured in the integration-tests module.
-
-Include the LOGBack dependencies listed in [integration-tests/build.gradle](https://github.com/web3j/web3j/blob/master/integration-tests/build.gradle#L7) and associated log configuration as per [integration-tests/src/test/resources/logback-test.xml](https://github.com/web3j/web3j/blob/master/integration-tests/src/test/resources/logback-test.xml).
-
-**Note:** if you are configuring logging for an application (not tests), you will need to ensure that the Logback dependencies are configured as *compile* dependencies, and that the configuration file is named and
-located in *src/main/resources/logback.xml*.
-
-I want to obtain some Ether on Testnet, but don't want to have to mine it myself
----------------------------------------------------------------------------------
-
-Please refer to the [Ethereum testnets](transactions.md#ethereum-testnets) for how to obtain some Ether.
-
-How do I obtain the return value from a smart contract method invoked by a transaction?
----------------------------------------------------------------------------------------
-
-You can't. It is not possible to return values from methods on smart contracts that are called as part of a transaction. If you wish to read a value during a transaction, you must use [Events](http://solidity.readthedocs.io/en/develop/contracts.html#events). To query values from smart contracts you must use a call, which is separate to a transaction. These methods should be marked as [constant](http://solidity.readthedocs.io/en/develop/contracts.html?highlight=constant#constant-functions) functions. [Solidity smart contract wrappers](smart_contracts.md#solidity-smart-contract-wrappers) created by web3j handle these differences for you.
-
-The following StackExchange [post](http://ethereum.stackexchange.com/questions/765/what-is-the-difference-between-a-transaction-and-a-call) is useful for background.
-
-Is it possible to send arbitrary text with transactions?
---------------------------------------------------------
-
-Yes it is. Text should be ASCII encoded and provided as a hexadecimal String in the data field of the transaction. This is demonstrated below:
-
-```java
-RawTransaction.createTransaction(
-        <nonce>, GAS_PRICE, GAS_LIMIT, "0x<address>", <amount>, "0x<hex encoded text>");
-
-byte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, ALICE);
-String hexValue = Numeric.toHexString(signedMessage);
-
-EthSendTransaction ethSendTransaction =
-        web3j.ethSendRawTransaction(hexValue).send();
-String transactionHash = ethSendTransaction.getTransactionHash();
-...
-```
-
-*Note*: Please ensure you increase the gas limit on the transaction to allow for the storage of text.
-
-The following StackExchange [post](http://ethereum.stackexchange.com/questions/2466/how-do-i-send-an-arbitary-message-to-an-ethereum-address) is useful for background.
-
-I've generated my smart contract wrapper, but the binary for the smart contract is empty?
-------------------------------------------------------------------------------------------
-
-If you have defined an interface in Solidity, but one of your method implementations doesn't match the original interface definitions, the produced binary will be blank.
-
-In the following example:
-
-```java
-contract Web3jToken is ERC20Basic, Ownable {
-    ...
-    function transfer(address _from, address _to, uint256 _value) onlyOwner returns (bool) {
-    ...
-}
-```
-
-We forgot to define the *from* parameter in one of the inherited contracts:
-
-```javascript
-contract ERC20Basic {
-    ...
-    function transfer(address to, uint256 value) returns (bool);
-    ...
-}
-```
-
-The Solidity compiler will not complain about this, however, the produced binary file for the Web3jToken will be blank.
-
-My ENS lookups are failing
---------------------------
-
-Are you sure that you are connecting to the correct network to perform the lookup?
-
-If web3j is telling you that the node is not in sync, you may need to change the *syncThreshold* in the
-[ENS resolver](ethereum_name_service.md#web3j-implementation).
-
-Do you have a project donation address?
----------------------------------------
-
-Absolutely, you can contribute Bitcoin or Ether to help fund the development of web3j.
-
----------- --------------------------------------------
-  Ethereum   0x2dfBf35bb7c3c0A466A6C48BEBf3eF7576d3C420
-
-  Bitcoin    	1DfUeRWUy4VjekPmmZUNqCjcJBMwsyp61G
----------- --------------------------------------------
-
-Where can I get commercial support for web3j?
----------------------------------------------
-
-Commercial support and training is available from [web3labs](https://www.web3labs.com/).
diff --git a/docs/using_infura_with_web3j.md b/docs/using_infura_with_web3j.md
deleted file mode 100644
index b7c6b9660..000000000
--- a/docs/using_infura_with_web3j.md
+++ /dev/null
@@ -1,54 +0,0 @@
-Using Infura with web3j
-=======================
-
-Signing up
-----------
-
-The [Infura](https://infura.io/) service by [ConsenSys](https://consensys.net/), provides Ethereum clients running in the cloud, so you don't have to run one yourself to work with Ethereum.
-
-When you sign up to the service you are provided with a token you can use to connect to the relevant Ethereum network:
-
-Main Ethereum Network:
-
-  <https://mainnet.infura.io/> <your-token\>
-
-Test Ethereum Network (Rinkeby):
-
-  <https://rinkeby.infura.io/><your-token\>
-
-Test Ethereum Network (Kovan):
-
-  <https://kovan.infura.io/><your-token\>
-
-Test Ethereum Network (Ropsten):
-
-  <https://ropsten.infura.io/><your-token\>
-
-For obtaining ether to use in these networks, you can refer to
-[Ethereum testnets](transactions.md#ethereum-testnets)
-
-InfuraHttpClient
-----------------
-
-The web3j infura module provides an Infura HTTP client ([InfuraHttpService](https://github.com/web3j/web3j/blob/master/hosted-providers/src/main/java/org/web3j/protocol/infura/InfuraHttpService.java)) which provides support for the Infura specific *Infura-Ethereum-Preferred-Client* header. This allows you to specify whether you want a Geth or Parity client to respond to your request. You can create the client just like the regular HTTPClient:
-
-```java
-Web3j web3 = Web3j.build(new HttpService("https://rinkeby.infura.io/<your-token>"));
-Web3ClientVersion web3ClientVersion = web3.web3ClientVersion().send();
-System.out.println(web3ClientVersion.getWeb3ClientVersion());
-```
-
-``` bash
-Geth/v1.7.2-stable-1db4ecdc/darwin-amd64/go1.9.1
-```
-
-If you want to test a number of the JSON-RPC calls against Infura, update the integration test [CoreIT](https://github.com/web3j/web3j/blob/master/integration-tests/src/test/java/org/web3j/protocol/core/CoreIT.java) with your Infura URL & run it.
-
-For further information, refer to the [Infura docs](https://infura.io/docs).
-
-Transactions
-------------
-
-In order to transact with Infura nodes, you will need to create and sign transactions offline before sending them, as Infura nodes have no visibility of your encrypted Ethereum key files, which are required to unlock accounts via the Personal Geth/Parity admin commands.
-
-Refer to the [Offline transaction signing](transactions.md#offline-transaction-signing) and [Management APIs](management_apis.md) sections for further details.
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index f04d6a20a..5844d93a4 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,6 @@
+#Mon Jan 13 09:55:58 GMT 2020
+distributionUrl=https\://services.gradle.org/distributions/gradle-5.6.3-all.zip
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-5.6.3-bin.zip
-zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
diff --git a/mkdocs.yml b/mkdocs.yml
deleted file mode 100644
index 47e538e1c..000000000
--- a/mkdocs.yml
+++ /dev/null
@@ -1,71 +0,0 @@
-site_name: "Web3j"
-site_description: "Documentation portal for the web3j Blockchain Library"
-site_author: "Web3 Labs"
-site_url: "https://web3j.io/"
-
-repo_name: "web3j/web3j"
-repo_url: "https://github.com/web3j/web3j"
-
-# Copyright
-copyright: "Copyright &copy; 2017-2019 Web3 Labs Ltd"
-
-nav:
-  - Quickstart: quickstart.md
-  - Getting Started: getting_started.md
-  - Modules: modules.md
-  - Transactions: transactions.md
-  - Smart Contracts: smart_contracts.md
-  - Application Binary Interface: application_binary_interface.md
-  - Recursive Length Prefix: recursive_length_prefix.md
-  - Filters and Events: filters_and_events.md
-  - Command Line Tools: command_line_tools.md
-  - Management Apis: management_apis.md
-  - Using Infura with Web3j: using_infura_with_web3j.md
-  - Ethereum Name Service: ethereum_name_service.md
-  - Contracts Supported by Web3j: contracts_supported_by_web3j.md
-  - Troubleshooting: troubleshooting.md
-  - Projects using Web3j: projects_using_web3j.md
-  - Companies using Web3j: companies_using_web3j.md
-  - Developer Guide: developer_guide.md
-  - Links and Useful Resources: links_and_useful_resources.md
-  - Thanks and Credits: thanks_and_credits.md
-
-# Configuration
-theme:
-  name: "material"
-  language: "en"
-  logo: "img/logo.png"
-  favicon: "img/favicon.ico"
-  feature:
-    tabs: true
-  palette:
-    primary: "white"
-    accent: "deep-orange"
-# Customization
-extra:
-  manifest: "manifest.webmanifest"
-  social:
-    - type: "github"
-      link: "https://github.com/web3j"
-    - type: "twitter"
-      link: "https://twitter.com/web3labs"
-    - type: "linkedin"
-      link: "https://linkedin.com/in/web3labs"
-extra_css:
-  - "stylesheets/extra.css"
-
-# Google Analytics
-google_analytics:
-  - 'UA-85710619-1'
-  - 'auto'
-
-
-# Extensions
-markdown_extensions:
-  - admonition
-  - codehilite:
-      guess_lang: false
-  - pymdownx.details
-  - toc:
-      permalink: true
-      toc_depth: 3
diff --git a/rlp/src/test/java/org/web3j/rlp/RlpEncoderTest.java b/rlp/src/test/java/org/web3j/rlp/RlpEncoderTest.java
index 95a6d586d..1b2626611 100644
--- a/rlp/src/test/java/org/web3j/rlp/RlpEncoderTest.java
+++ b/rlp/src/test/java/org/web3j/rlp/RlpEncoderTest.java
@@ -17,7 +17,7 @@
 
 import org.junit.jupiter.api.Test;
 
-import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
 
 public class RlpEncoderTest {
 
@@ -28,30 +28,30 @@
      */
     @Test
     public void testEncode() {
-        assertEquals(
+        assertArrayEquals(
                 RlpEncoder.encode(RlpString.create("dog")),
                 (new byte[] {(byte) 0x83, 'd', 'o', 'g'}));
 
-        assertEquals(
+        assertArrayEquals(
                 RlpEncoder.encode(new RlpList(RlpString.create("cat"), RlpString.create("dog"))),
                 (new byte[] {(byte) 0xc8, (byte) 0x83, 'c', 'a', 't', (byte) 0x83, 'd', 'o', 'g'}));
 
-        assertEquals(RlpEncoder.encode(RlpString.create("")), (new byte[] {(byte) 0x80}));
+        assertArrayEquals(RlpEncoder.encode(RlpString.create("")), (new byte[] {(byte) 0x80}));
 
-        assertEquals(
+        assertArrayEquals(
                 RlpEncoder.encode(RlpString.create(new byte[] {})), (new byte[] {(byte) 0x80}));
 
-        assertEquals(RlpEncoder.encode(new RlpList()), (new byte[] {(byte) 0xc0}));
+        assertArrayEquals(RlpEncoder.encode(new RlpList()), (new byte[] {(byte) 0xc0}));
 
-        assertEquals(
+        assertArrayEquals(
                 RlpEncoder.encode(RlpString.create(BigInteger.valueOf(0x0f))),
                 (new byte[] {(byte) 0x0f}));
 
-        assertEquals(
+        assertArrayEquals(
                 RlpEncoder.encode(RlpString.create(BigInteger.valueOf(0x0400))),
                 (new byte[] {(byte) 0x82, (byte) 0x04, (byte) 0x00}));
 
-        assertEquals(
+        assertArrayEquals(
                 RlpEncoder.encode(
                         new RlpList(
                                 new RlpList(),
@@ -68,7 +68,7 @@ public void testEncode() {
                     (byte) 0xc0
                 }));
 
-        assertEquals(
+        assertArrayEquals(
                 RlpEncoder.encode(
                         RlpString.create(
                                 "Lorem ipsum dolor sit amet, consectetur adipisicing elit")),
@@ -133,14 +133,14 @@ public void testEncode() {
                     't'
                 }));
 
-        assertEquals(
+        assertArrayEquals(
                 RlpEncoder.encode(RlpString.create(BigInteger.ZERO)), (new byte[] {(byte) 0x80}));
 
         // https://github.com/paritytech/parity-common/blob/master/rlp/tests/tests.rs#L237
-        assertEquals(
+        assertArrayEquals(
                 RlpEncoder.encode(RlpString.create(new byte[] {0})), (new byte[] {(byte) 0x00}));
 
-        assertEquals(
+        assertArrayEquals(
                 RlpEncoder.encode(
                         new RlpList(
                                 RlpString.create("zw"),
@@ -162,6 +162,6 @@ public void testEncode() {
         byte[] expectedEncoding = new byte[56];
         expectedEncoding[0] = (byte) 0xb7;
         System.arraycopy(encodeMe, 0, expectedEncoding, 1, encodeMe.length);
-        assertEquals(RlpEncoder.encode(RlpString.create(encodeMe)), (expectedEncoding));
+        assertArrayEquals(RlpEncoder.encode(RlpString.create(encodeMe)), (expectedEncoding));
     }
 }
diff --git a/scripts/common.bash b/scripts/common.bash
index 06b0fce30..b3d197dea 100755
--- a/scripts/common.bash
+++ b/scripts/common.bash
@@ -25,7 +25,7 @@ ensure_version() {
 
 ensure_product() {
     if [[ -z "$PRODUCT" ]]; then
-        PRODUCT="${TRAVIS_REPO_SLUG//release\/}"
+        PRODUCT="${TRAVIS_REPO_SLUG//web3j\/}"
     fi
 
     if [[ "$PRODUCT" = "" ]]; then
diff --git a/utils/src/main/java/org/web3j/commons/JavaVersion.java b/utils/src/main/java/org/web3j/commons/JavaVersion.java
new file mode 100644
index 000000000..e0227c135
--- /dev/null
+++ b/utils/src/main/java/org/web3j/commons/JavaVersion.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2019 Web3 Labs Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+package org.web3j.commons;
+
+public class JavaVersion {
+
+    public static String getJavaVersion() {
+        return System.getProperty("java.specification.version");
+    }
+
+    public static double getJavaVersionAsDouble() {
+        return Double.parseDouble(System.getProperty("java.specification.version"));
+    }
+}
diff --git a/utils/src/test/java/org/web3j/crypto/HashTest.java b/utils/src/test/java/org/web3j/crypto/HashTest.java
index 0b2c6a6b2..b2dc8106e 100644
--- a/utils/src/test/java/org/web3j/crypto/HashTest.java
+++ b/utils/src/test/java/org/web3j/crypto/HashTest.java
@@ -14,6 +14,7 @@
 
 import org.junit.jupiter.api.Test;
 
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.web3j.utils.Numeric.asByte;
 
@@ -73,7 +74,7 @@ public void testSha3() {
                 };
 
         byte[] result = Hash.sha3(input);
-        assertEquals(result, (expected));
+        assertArrayEquals(result, (expected));
     }
 
     @Test
diff --git a/utils/src/test/java/org/web3j/utils/BytesTest.java b/utils/src/test/java/org/web3j/utils/BytesTest.java
index 5bda3cfe2..a4b4b8e62 100644
--- a/utils/src/test/java/org/web3j/utils/BytesTest.java
+++ b/utils/src/test/java/org/web3j/utils/BytesTest.java
@@ -14,18 +14,18 @@
 
 import org.junit.jupiter.api.Test;
 
-import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
 import static org.web3j.utils.Bytes.trimLeadingZeroes;
 
 public class BytesTest {
 
     @Test
     public void testTrimLeadingZeroes() {
-        assertEquals(trimLeadingZeroes(new byte[] {}), (new byte[] {}));
-        assertEquals(trimLeadingZeroes(new byte[] {0}), (new byte[] {0}));
-        assertEquals(trimLeadingZeroes(new byte[] {1}), (new byte[] {1}));
-        assertEquals(trimLeadingZeroes(new byte[] {0, 1}), (new byte[] {1}));
-        assertEquals(trimLeadingZeroes(new byte[] {0, 0, 1}), (new byte[] {1}));
-        assertEquals(trimLeadingZeroes(new byte[] {0, 0, 1, 0}), (new byte[] {1, 0}));
+        assertArrayEquals(trimLeadingZeroes(new byte[] {}), (new byte[] {}));
+        assertArrayEquals(trimLeadingZeroes(new byte[] {0}), (new byte[] {0}));
+        assertArrayEquals(trimLeadingZeroes(new byte[] {1}), (new byte[] {1}));
+        assertArrayEquals(trimLeadingZeroes(new byte[] {0, 1}), (new byte[] {1}));
+        assertArrayEquals(trimLeadingZeroes(new byte[] {0, 0, 1}), (new byte[] {1}));
+        assertArrayEquals(trimLeadingZeroes(new byte[] {0, 0, 1, 0}), (new byte[] {1, 0}));
     }
 }
diff --git a/utils/src/test/java/org/web3j/utils/NumericTest.java b/utils/src/test/java/org/web3j/utils/NumericTest.java
index f7217243f..c452f50f4 100644
--- a/utils/src/test/java/org/web3j/utils/NumericTest.java
+++ b/utils/src/test/java/org/web3j/utils/NumericTest.java
@@ -19,7 +19,9 @@
 import org.junit.jupiter.api.Test;
 
 import org.web3j.exceptions.MessageDecodingException;
+import org.web3j.exceptions.MessageEncodingException;
 
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertThrows;
@@ -111,7 +113,7 @@ public void testQuantityEncode() {
     public void testQuantityEncodeNegative() {
 
         assertThrows(
-                MessageDecodingException.class,
+                MessageEncodingException.class,
                 () -> Numeric.encodeQuantity(BigInteger.valueOf(-1)));
     }
 
@@ -143,12 +145,12 @@ public void testToHexStringNoPrefix() {
 
     @Test
     public void testToBytesPadded() {
-        assertEquals(Numeric.toBytesPadded(BigInteger.TEN, 1), (new byte[] {0xa}));
+        assertArrayEquals(Numeric.toBytesPadded(BigInteger.TEN, 1), (new byte[] {0xa}));
 
-        assertEquals(
+        assertArrayEquals(
                 Numeric.toBytesPadded(BigInteger.TEN, 8), (new byte[] {0, 0, 0, 0, 0, 0, 0, 0xa}));
 
-        assertEquals(
+        assertArrayEquals(
                 Numeric.toBytesPadded(BigInteger.valueOf(Integer.MAX_VALUE), 4),
                 (new byte[] {0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff}));
     }
@@ -163,12 +165,12 @@ public void testToBytesPaddedInvalid() {
 
     @Test
     public void testHexStringToByteArray() {
-        assertEquals(Numeric.hexStringToByteArray(""), (new byte[] {}));
-        assertEquals(Numeric.hexStringToByteArray("0"), (new byte[] {0}));
-        assertEquals(Numeric.hexStringToByteArray("1"), (new byte[] {0x1}));
-        assertEquals(Numeric.hexStringToByteArray(HEX_RANGE_STRING), (HEX_RANGE_ARRAY));
+        assertArrayEquals(Numeric.hexStringToByteArray(""), (new byte[] {}));
+        assertArrayEquals(Numeric.hexStringToByteArray("0"), (new byte[] {0}));
+        assertArrayEquals(Numeric.hexStringToByteArray("1"), (new byte[] {0x1}));
+        assertArrayEquals(Numeric.hexStringToByteArray(HEX_RANGE_STRING), (HEX_RANGE_ARRAY));
 
-        assertEquals(Numeric.hexStringToByteArray("0x123"), (new byte[] {0x1, 0x23}));
+        assertArrayEquals(Numeric.hexStringToByteArray("0x123"), (new byte[] {0x1, 0x23}));
     }
 
     @Test
