diff --git a/.idea/uiDesigner.xml b/.idea/uiDesigner.xml
deleted file mode 100644
index e96534f..0000000
--- a/.idea/uiDesigner.xml
+++ /dev/null
@@ -1,124 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="Palette2">
-    <group name="Swing">
-      <item class="com.intellij.uiDesigner.HSpacer" tooltip-text="Horizontal Spacer" icon="/com/intellij/uiDesigner/icons/hspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="1" hsize-policy="6" anchor="0" fill="1" />
-      </item>
-      <item class="com.intellij.uiDesigner.VSpacer" tooltip-text="Vertical Spacer" icon="/com/intellij/uiDesigner/icons/vspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="6" hsize-policy="1" anchor="0" fill="2" />
-      </item>
-      <item class="javax.swing.JPanel" icon="/com/intellij/uiDesigner/icons/panel.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3" />
-      </item>
-      <item class="javax.swing.JScrollPane" icon="/com/intellij/uiDesigner/icons/scrollPane.png" removable="false" auto-create-binding="false" can-attach-label="true">
-        <default-constraints vsize-policy="7" hsize-policy="7" anchor="0" fill="3" />
-      </item>
-      <item class="javax.swing.JButton" icon="/com/intellij/uiDesigner/icons/button.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="3" anchor="0" fill="1" />
-        <initial-values>
-          <property name="text" value="Button" />
-        </initial-values>
-      </item>
-      <item class="javax.swing.JRadioButton" icon="/com/intellij/uiDesigner/icons/radioButton.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
-        <initial-values>
-          <property name="text" value="RadioButton" />
-        </initial-values>
-      </item>
-      <item class="javax.swing.JCheckBox" icon="/com/intellij/uiDesigner/icons/checkBox.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
-        <initial-values>
-          <property name="text" value="CheckBox" />
-        </initial-values>
-      </item>
-      <item class="javax.swing.JLabel" icon="/com/intellij/uiDesigner/icons/label.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="0" anchor="8" fill="0" />
-        <initial-values>
-          <property name="text" value="Label" />
-        </initial-values>
-      </item>
-      <item class="javax.swing.JTextField" icon="/com/intellij/uiDesigner/icons/textField.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
-          <preferred-size width="150" height="-1" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JPasswordField" icon="/com/intellij/uiDesigner/icons/passwordField.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
-          <preferred-size width="150" height="-1" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JFormattedTextField" icon="/com/intellij/uiDesigner/icons/formattedTextField.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
-          <preferred-size width="150" height="-1" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JTextArea" icon="/com/intellij/uiDesigner/icons/textArea.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
-          <preferred-size width="150" height="50" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JTextPane" icon="/com/intellij/uiDesigner/icons/textPane.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
-          <preferred-size width="150" height="50" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JEditorPane" icon="/com/intellij/uiDesigner/icons/editorPane.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
-          <preferred-size width="150" height="50" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JComboBox" icon="/com/intellij/uiDesigner/icons/comboBox.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="0" hsize-policy="2" anchor="8" fill="1" />
-      </item>
-      <item class="javax.swing.JTable" icon="/com/intellij/uiDesigner/icons/table.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
-          <preferred-size width="150" height="50" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JList" icon="/com/intellij/uiDesigner/icons/list.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="6" hsize-policy="2" anchor="0" fill="3">
-          <preferred-size width="150" height="50" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JTree" icon="/com/intellij/uiDesigner/icons/tree.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
-          <preferred-size width="150" height="50" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JTabbedPane" icon="/com/intellij/uiDesigner/icons/tabbedPane.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
-          <preferred-size width="200" height="200" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JSplitPane" icon="/com/intellij/uiDesigner/icons/splitPane.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
-          <preferred-size width="200" height="200" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JSpinner" icon="/com/intellij/uiDesigner/icons/spinner.png" removable="false" auto-create-binding="true" can-attach-label="true">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
-      </item>
-      <item class="javax.swing.JSlider" icon="/com/intellij/uiDesigner/icons/slider.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
-      </item>
-      <item class="javax.swing.JSeparator" icon="/com/intellij/uiDesigner/icons/separator.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3" />
-      </item>
-      <item class="javax.swing.JProgressBar" icon="/com/intellij/uiDesigner/icons/progressbar.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1" />
-      </item>
-      <item class="javax.swing.JToolBar" icon="/com/intellij/uiDesigner/icons/toolbar.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1">
-          <preferred-size width="-1" height="20" />
-        </default-constraints>
-      </item>
-      <item class="javax.swing.JToolBar$Separator" icon="/com/intellij/uiDesigner/icons/toolbarSeparator.png" removable="false" auto-create-binding="false" can-attach-label="false">
-        <default-constraints vsize-policy="0" hsize-policy="0" anchor="0" fill="1" />
-      </item>
-      <item class="javax.swing.JScrollBar" icon="/com/intellij/uiDesigner/icons/scrollbar.png" removable="false" auto-create-binding="true" can-attach-label="false">
-        <default-constraints vsize-policy="6" hsize-policy="0" anchor="0" fill="2" />
-      </item>
-    </group>
-  </component>
-</project>
\ No newline at end of file
diff --git a/.travis.yml b/.travis.yml
index 51b3513..ad7b7b5 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,4 +1,5 @@
 language: java
+dist: trusty
 cache:
   directories:
   - .autoconf
diff --git a/README.md b/README.md
index 2ef2a90..8741228 100644
--- a/README.md
+++ b/README.md
@@ -22,7 +22,7 @@ If you have any questions or are interested in adding new functionality, feel fr
 | Component Invocation | A relationship between two Components, typically through type declaration, instantiation, extension, implementation, etc.. |
 
 # Getting Started
-An excellent way to get started is to look at Clarpe's unit tests.
+First execute `mvn generate-resources` to generate neccessary Antlr files. An excellent way to get familiar with Clarpse is to check out some unit tests.
 ```java
    // Create a new ParseRequestContent Object representing a codebase
    final String code =                       " package com.foo;  "
diff --git a/clarpse.iml b/clarpse.iml
deleted file mode 100644
index da4c882..0000000
--- a/clarpse.iml
+++ /dev/null
@@ -1,65 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module org.jetbrains.idea.maven.project.MavenProjectsManager.isMavenModule="true" type="JAVA_MODULE" version="4">
-  <component name="NewModuleRootManager" LANGUAGE_LEVEL="JDK_1_8">
-    <output url="file://$MODULE_DIR$/clarpse/target/classes" />
-    <output-test url="file://$MODULE_DIR$/clarpse/target/test-classes" />
-    <content url="file://$MODULE_DIR$/clarpse">
-      <sourceFolder url="file://$MODULE_DIR$/clarpse/src/main/java" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/clarpse/src/main/resources" type="java-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/clarpse/src/test/java" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/clarpse/src/test/resources" type="java-test-resource" />
-      <sourceFolder url="file://$MODULE_DIR$/clarpse/target/generated-sources/antlr4" isTestSource="false" generated="true" />
-      <excludeFolder url="file://$MODULE_DIR$/clarpse/target" />
-    </content>
-    <orderEntry type="inheritedJdk" />
-    <orderEntry type="sourceFolder" forTests="false" />
-    <orderEntry type="library" name="Maven: com.google.javascript:closure-compiler:v20170626" level="project" />
-    <orderEntry type="library" name="Maven: com.google.javascript:closure-compiler-externs:v20170626" level="project" />
-    <orderEntry type="library" name="Maven: args4j:args4j:2.33" level="project" />
-    <orderEntry type="library" name="Maven: com.google.errorprone:error_prone_annotations:2.0.18" level="project" />
-    <orderEntry type="library" name="Maven: com.google.guava:guava:20.0" level="project" />
-    <orderEntry type="library" name="Maven: com.google.protobuf:protobuf-java:3.0.2" level="project" />
-    <orderEntry type="library" name="Maven: com.google.code.gson:gson:2.7" level="project" />
-    <orderEntry type="library" name="Maven: com.google.code.findbugs:jsr305:3.0.1" level="project" />
-    <orderEntry type="library" name="Maven: com.google.jsinterop:jsinterop-annotations:1.0.0" level="project" />
-    <orderEntry type="library" name="Maven: com.tunnelvisionlabs:antlr4-runtime:4.3" level="project" />
-    <orderEntry type="library" name="Maven: org.abego.treelayout:org.abego.treelayout.core:1.0.1" level="project" />
-    <orderEntry type="library" name="Maven: com.tunnelvisionlabs:antlr4-annotations:4.3" level="project" />
-    <orderEntry type="library" name="Maven: com.tunnelvisionlabs:antlr4-maven-plugin:4.3" level="project" />
-    <orderEntry type="library" name="Maven: org.apache.maven:maven-plugin-api:3.0.5" level="project" />
-    <orderEntry type="library" name="Maven: org.apache.maven:maven-model:3.0.5" level="project" />
-    <orderEntry type="library" name="Maven: org.apache.maven:maven-artifact:3.0.5" level="project" />
-    <orderEntry type="library" name="Maven: org.sonatype.sisu:sisu-inject-plexus:2.3.0" level="project" />
-    <orderEntry type="library" name="Maven: org.codehaus.plexus:plexus-component-annotations:1.5.5" level="project" />
-    <orderEntry type="library" name="Maven: org.codehaus.plexus:plexus-classworlds:2.4" level="project" />
-    <orderEntry type="library" name="Maven: org.sonatype.sisu:sisu-inject-bean:2.3.0" level="project" />
-    <orderEntry type="library" name="Maven: org.sonatype.sisu:sisu-guice:no_aop:3.1.0" level="project" />
-    <orderEntry type="library" name="Maven: org.sonatype.sisu:sisu-guava:0.9.9" level="project" />
-    <orderEntry type="library" name="Maven: org.apache.maven:maven-project:2.2.1" level="project" />
-    <orderEntry type="library" name="Maven: org.apache.maven:maven-settings:2.2.1" level="project" />
-    <orderEntry type="library" name="Maven: org.apache.maven:maven-profile:2.2.1" level="project" />
-    <orderEntry type="library" name="Maven: org.apache.maven:maven-artifact-manager:2.2.1" level="project" />
-    <orderEntry type="library" name="Maven: org.apache.maven:maven-repository-metadata:2.2.1" level="project" />
-    <orderEntry type="library" name="Maven: org.apache.maven.wagon:wagon-provider-api:1.0-beta-6" level="project" />
-    <orderEntry type="library" name="Maven: backport-util-concurrent:backport-util-concurrent:3.1" level="project" />
-    <orderEntry type="library" name="Maven: org.apache.maven:maven-plugin-registry:2.2.1" level="project" />
-    <orderEntry type="library" name="Maven: org.codehaus.plexus:plexus-interpolation:1.11" level="project" />
-    <orderEntry type="library" name="Maven: org.codehaus.plexus:plexus-utils:1.5.15" level="project" />
-    <orderEntry type="library" name="Maven: org.codehaus.plexus:plexus-container-default:1.0-alpha-9-stable-1" level="project" />
-    <orderEntry type="library" name="Maven: classworlds:classworlds:1.1-alpha-2" level="project" />
-    <orderEntry type="library" name="Maven: org.codehaus.plexus:plexus-compiler-api:2.2" level="project" />
-    <orderEntry type="library" name="Maven: org.sonatype.plexus:plexus-build-api:0.0.7" level="project" />
-    <orderEntry type="library" name="Maven: com.tunnelvisionlabs:antlr4:4.3" level="project" />
-    <orderEntry type="library" name="Maven: org.antlr:antlr-runtime:3.5.2" level="project" />
-    <orderEntry type="library" name="Maven: org.antlr:ST4:4.0.8" level="project" />
-    <orderEntry type="library" name="Maven: org.apache.commons:commons-lang3:3.4" level="project" />
-    <orderEntry type="library" name="Maven: com.github.javaparser:javaparser-core:3.5.8" level="project" />
-    <orderEntry type="library" name="Maven: com.fasterxml.jackson.core:jackson-databind:2.8.3" level="project" />
-    <orderEntry type="library" name="Maven: com.fasterxml.jackson.core:jackson-annotations:2.8.0" level="project" />
-    <orderEntry type="library" name="Maven: com.fasterxml.jackson.core:jackson-core:2.8.3" level="project" />
-    <orderEntry type="library" name="Maven: com.fasterxml.jackson.module:jackson-module-afterburner:2.8.3" level="project" />
-    <orderEntry type="library" scope="TEST" name="Maven: junit:junit:4.11" level="project" />
-    <orderEntry type="library" scope="TEST" name="Maven: org.hamcrest:hamcrest-core:1.3" level="project" />
-    <orderEntry type="library" name="Maven: commons-io:commons-io:2.4" level="project" />
-  </component>
-</module>
\ No newline at end of file
diff --git a/clarpse/.gitignore b/clarpse/.gitignore
index 9eeaefc..9a47933 100644
--- a/clarpse/.gitignore
+++ b/clarpse/.gitignore
@@ -1,2 +1,74 @@
 /.apt_generated/
 target/
+.idea/*
+# Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm, CLion, Android Studio and WebStorm
+# Reference: https://intellij-support.jetbrains.com/hc/en-us/articles/206544839
+
+# User-specific stuff
+.idea/**/workspace.xml
+.idea/**/tasks.xml
+.idea/**/usage.statistics.xml
+.idea/**/dictionaries
+.idea/**/shelf
+
+# Generated files
+.idea/**/contentModel.xml
+
+# Sensitive or high-churn files
+.idea/**/dataSources/
+.idea/**/dataSources.ids
+.idea/**/dataSources.local.xml
+.idea/**/sqlDataSources.xml
+.idea/**/dynamic.xml
+.idea/**/uiDesigner.xml
+.idea/**/dbnavigator.xml
+
+# Gradle
+.idea/**/gradle.xml
+.idea/**/libraries
+
+# Gradle and Maven with auto-import
+# When using Gradle or Maven with auto-import, you should exclude module files,
+# since they will be recreated, and may cause churn.  Uncomment if using
+# auto-import.
+# .idea/artifacts
+# .idea/compiler.xml
+# .idea/jarRepositories.xml
+# .idea/modules.xml
+# .idea/*.iml
+# .idea/modules
+# *.iml
+# *.ipr
+
+# CMake
+cmake-build-*/
+
+# Mongo Explorer plugin
+.idea/**/mongoSettings.xml
+
+# File-based project format
+*.iws
+
+# IntelliJ
+out/
+
+# mpeltonen/sbt-idea plugin
+.idea_modules/
+
+# JIRA plugin
+atlassian-ide-plugin.xml
+
+# Cursive Clojure plugin
+.idea/replstate.xml
+
+# Crashlytics plugin (for Android Studio and IntelliJ)
+com_crashlytics_export_strings.xml
+crashlytics.properties
+crashlytics-build.properties
+fabric.properties
+
+# Editor-based Rest Client
+.idea/httpRequests
+
+# Android studio 3.1+ serialized cache file
+.idea/caches/build_file_checksums.ser
\ No newline at end of file
diff --git a/clarpse/pom.xml b/clarpse/pom.xml
index fbf08f4..e3e9947 100644
--- a/clarpse/pom.xml
+++ b/clarpse/pom.xml
@@ -1,11 +1,11 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+		 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
 	<modelVersion>4.0.0</modelVersion>
 	<groupId>com.clarityviews</groupId>
 	<artifactId>clarpse</artifactId>
 	<name>clarpse</name>
 	<packaging>jar</packaging>
-	<version>4.1.0</version>
+	<version>5.0.0</version>
 	<properties>
 		<java-version>1.8</java-version>
 	</properties>
@@ -15,9 +15,8 @@
 		<dependency>
 			<groupId>com.google.javascript</groupId>
 			<artifactId>closure-compiler</artifactId>
-			<version>v20170626</version>
+			<version>v20191111</version>
 		</dependency>
-		<!-- https://mvnrepository.com/artifact/org.antlr/antlr4-runtime -->
 		<!-- https://mvnrepository.com/artifact/com.tunnelvisionlabs/antlr4-runtime -->
 		<dependency>
 			<groupId>com.tunnelvisionlabs</groupId>
@@ -46,12 +45,12 @@
 		<dependency>
 			<groupId>com.fasterxml.jackson.core</groupId>
 			<artifactId>jackson-databind</artifactId>
-			<version>2.8.3</version>
+			<version>2.8.8</version>
 		</dependency>
 		<dependency>
 			<groupId>com.fasterxml.jackson.module</groupId>
 			<artifactId>jackson-module-afterburner</artifactId>
-			<version>2.8.3</version>
+			<version>2.8.8</version>
 		</dependency>
 		<!-- Testing -->
 		<dependency>
@@ -72,7 +71,7 @@
 		<repository>
 			<id>central</id>
 			<name>ip-172-31-28-11-releases</name>
-			<url>http://ec2-35-163-144-148.us-west-2.compute.amazonaws.com/artifactory/libs-release-local</url>
+			<url>http://artifactory.clarity-bot.com/artifactory/libs-release-local</url>
 		</repository>
 	</distributionManagement>
 	<build>
@@ -175,14 +174,15 @@
 			<plugin>
 				<groupId>org.codehaus.mojo</groupId>
 				<artifactId>findbugs-maven-plugin</artifactId>
-				<version>3.0.0</version>
+				<version>3.0.1</version>
 				<configuration>
 					<!-- Enables analysis which takes more memory but finds more bugs. If 
 						you run out of memory, changes the value of the effort element to 'Low'. -->
 					<effort>default</effort>
 					<!-- Reports all bugs (other values are medium and max) -->
 					<threshold>low</threshold>
-					<includeFilterFile>${project.basedir}/src/main/resources/findbugsexcludefilter.xml</includeFilterFile>
+					<includeFilterFile>${project.basedir}/src/main/resources/findbugsexcludefilter.xml
+					</includeFilterFile>
 				</configuration>
 				<executions>
 					<!-- Ensures that FindBugs inspects source code when project is compiled. -->
diff --git a/clarpse/src/main/java/com/clarity/ClarpseUtil.java b/clarpse/src/main/java/com/clarity/ClarpseUtil.java
index 1fffa08..458c660 100644
--- a/clarpse/src/main/java/com/clarity/ClarpseUtil.java
+++ b/clarpse/src/main/java/com/clarity/ClarpseUtil.java
@@ -1,20 +1,5 @@
 package com.clarity;
 
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import org.apache.commons.io.IOUtils;
-import org.apache.commons.lang3.StringUtils;
-
 import com.clarity.compiler.Lang;
 import com.clarity.compiler.RawFile;
 import com.clarity.compiler.SourceFiles;
@@ -26,13 +11,25 @@
 import com.fasterxml.jackson.databind.JsonMappingException;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.module.afterburner.AfterburnerModule;
+import org.apache.commons.io.IOUtils;
+import org.apache.commons.lang3.StringUtils;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
 
-@SuppressWarnings("deprecation")
 public final class ClarpseUtil {
 
     public static final int BUFFER_SIZE = 4096;
 
-    static final ObjectMapper JSON_MAPPER = new ObjectMapper();;
+    private static final ObjectMapper JSON_MAPPER = new ObjectMapper();
+
     static {
         JSON_MAPPER.setSerializationInclusion(Include.NON_NULL);
         JSON_MAPPER.registerModule(new AfterburnerModule());
@@ -52,7 +49,6 @@ private ClarpseUtil() {
     public static Object getObjectFromStringObjectKeyValueMap(final String value, final Map<?, ?> map) {
         final Iterator<?> it = map.entrySet().iterator();
         while (it.hasNext()) {
-            @SuppressWarnings("rawtypes")
             final Map.Entry pair = (Map.Entry) it.next();
             if (pair.getValue().equals(value)) {
                 return pair.getKey();
@@ -61,7 +57,7 @@ public static Object getObjectFromStringObjectKeyValueMap(final String value, fi
         return null;
     }
 
-    public static String fromJavaToJson(final Serializable object, final boolean prettyPrint)
+    private static String fromJavaToJson(final Serializable object, final boolean prettyPrint)
             throws JsonGenerationException, JsonMappingException, IOException {
 
         final byte[] bytes = JSON_MAPPER.writeValueAsBytes(object);
@@ -74,7 +70,7 @@ public static String fromJavaToJson(final Serializable object)
     }
 
     @SuppressWarnings("unchecked")
-    public static Object fromJsonToJava(final String json, @SuppressWarnings("rawtypes") final Class type)
+    public static Object fromJsonToJava(final String json, final Class type)
             throws JsonParseException, JsonMappingException, IOException {
         return JSON_MAPPER.readValue(json.getBytes("UTF-8"), type);
     }
@@ -152,30 +148,4 @@ public static SourceFiles parseRequestContentObjFromResourceDir(String dir, Lang
         }
         return req;
     }
-
-    public static List<String> extractDocTypeMentions(String docComment) {
-        List<String> docTypeMentions = new ArrayList<String>();
-        Pattern linkPattern = Pattern.compile("\\{ *\\@link +(([a-z]|[A-Z]|[0-9]|\\.)+)( +.*)? *\\}");
-        Pattern linkPlainPattern = Pattern.compile("\\{ *\\@linkplain +(([a-z]|[A-Z]|[0-9]|\\.)+)( +.*)? *\\}");
-
-        Matcher matchPattern = linkPattern.matcher(docComment);
-        while (matchPattern.find()) {
-            docTypeMentions.add(matchPattern.group(1));
-        }
-        matchPattern = linkPlainPattern.matcher(docComment);
-        while (matchPattern.find()) {
-            docTypeMentions.add(matchPattern.group(1));
-        }
-        // we only consider doc links to other classes, interfaces, etc... (no methods
-        // or variables)
-        List<String> invalidMentions = new ArrayList<String>();
-        docTypeMentions.forEach(mention -> {
-            mention = mention.split(" ")[0];
-            if (mention.matches(".*[#/:\\[\\]\\(\\)].*")) {
-                invalidMentions.add(mention);
-            }
-        });
-        docTypeMentions.removeAll(invalidMentions);
-        return docTypeMentions;
-    }
 }
diff --git a/clarpse/src/main/java/com/clarity/CommonDir.java b/clarpse/src/main/java/com/clarity/CommonDir.java
index fcef153..8503d75 100644
--- a/clarpse/src/main/java/com/clarity/CommonDir.java
+++ b/clarpse/src/main/java/com/clarity/CommonDir.java
@@ -45,5 +45,4 @@ public String value() throws Exception {
             return commonDir;
         }
     }
-
 }
diff --git a/clarpse/src/main/java/com/clarity/Emptyable.java b/clarpse/src/main/java/com/clarity/Emptyable.java
deleted file mode 100644
index 4a3cf2c..0000000
--- a/clarpse/src/main/java/com/clarity/Emptyable.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package com.clarity;
-
-public interface Emptyable {
-
-    boolean empty();
-}
diff --git a/clarpse/src/main/java/com/clarity/ResolvedRelativePath.java b/clarpse/src/main/java/com/clarity/ResolvedRelativePath.java
index ace1543..b0aab90 100644
--- a/clarpse/src/main/java/com/clarity/ResolvedRelativePath.java
+++ b/clarpse/src/main/java/com/clarity/ResolvedRelativePath.java
@@ -1,10 +1,10 @@
 package com.clarity;
 
+import edu.emory.mathcs.backport.java.util.Arrays;
+
 import java.util.ArrayList;
 import java.util.List;
 
-import edu.emory.mathcs.backport.java.util.Arrays;
-
 /**
  * Represents a resolved path.
  */
@@ -43,7 +43,7 @@ private String preprocessedPath(String path) throws Exception {
     }
 
     /**
-     * @see {@link ResolvedRelativePath#ResolvedRelativePath(String, String)}
+     * @see ResolvedRelativePath#ResolvedRelativePath(String, String)
      */
     public String value() throws Exception {
 
@@ -51,7 +51,7 @@ public String value() throws Exception {
         String relativePath = preprocessedPath(this.unresolvedRelativePath);
 
         // build absolute path representing the given relative path
-        List<String> absoluteParts = new ArrayList<String>(Arrays.asList(absolutePath.split("/")));
+        @SuppressWarnings("unchecked") List<String> absoluteParts = new ArrayList<String>(Arrays.asList(absolutePath.split("/", -1)));
         String[] relativeParts = relativePath.split("/");
         for (String relativePart : relativeParts) {
             if (relativePart.equals(".")) {
@@ -64,6 +64,7 @@ public String value() throws Exception {
                 absoluteParts.add(relativePart);
             }
         }
+        absoluteParts.removeIf(String::isEmpty);
         return "/" + String.join("/", absoluteParts);
     }
 }
diff --git a/clarpse/src/main/java/com/clarity/TrimmedString.java b/clarpse/src/main/java/com/clarity/TrimmedString.java
index 6a857e1..571baf8 100644
--- a/clarpse/src/main/java/com/clarity/TrimmedString.java
+++ b/clarpse/src/main/java/com/clarity/TrimmedString.java
@@ -11,16 +11,17 @@ public TrimmedString(String untrimmedString, String trimValue) {
     }
 
     public String value() throws Exception {
-
-        if (untrimmedString == null || trimValue == null || untrimmedString.length() < trimValue.length()) {
+        if (untrimmedString == null || trimValue == null) {
             throw new Exception("Invalid Input found!");
         }
         String result = untrimmedString;
-        if (untrimmedString.startsWith(trimValue)) {
+
+        while (result.startsWith(trimValue)) {
             result = result.substring(trimValue.length());
         }
-        if (result.endsWith(trimValue)) {
-            result = result.substring(0, result.length() - (1 + trimValue.length()));
+
+        while (result.endsWith(trimValue)) {
+            result = result.substring(0, result.length() - (trimValue.length()));
         }
         return result;
     }
diff --git a/clarpse/src/main/java/com/clarity/compiler/ClarpseGoCompiler.java b/clarpse/src/main/java/com/clarity/compiler/ClarpseGoCompiler.java
index c653add..31a8f3c 100644
--- a/clarpse/src/main/java/com/clarity/compiler/ClarpseGoCompiler.java
+++ b/clarpse/src/main/java/com/clarity/compiler/ClarpseGoCompiler.java
@@ -5,13 +5,13 @@
 import com.clarity.antlr.golang.GolangLexer;
 import com.clarity.antlr.golang.GolangParser;
 import com.clarity.antlr.golang.GolangParser.SourceFileContext;
-import com.clarity.invocation.ComponentInvocation;
-import com.clarity.invocation.TypeImplementation;
 import com.clarity.listener.GoLangTreeListener;
+import com.clarity.reference.ComponentReference;
+import com.clarity.reference.TypeImplementationReference;
 import com.clarity.sourcemodel.Component;
 import com.clarity.sourcemodel.OOPSourceCodeModel;
-import com.clarity.sourcemodel.OOPSourceModelConstants.ComponentInvocations;
 import com.clarity.sourcemodel.OOPSourceModelConstants.ComponentType;
+import com.clarity.sourcemodel.OOPSourceModelConstants.TypeReferences;
 import edu.emory.mathcs.backport.java.util.Collections;
 import org.antlr.v4.runtime.ANTLRInputStream;
 import org.antlr.v4.runtime.BailErrorStrategy;
@@ -22,7 +22,6 @@
 import org.antlr.v4.runtime.tree.ParseTreeWalker;
 
 import java.util.ArrayList;
-import java.util.Comparator;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -44,14 +43,14 @@ private void resolveInterfaces(OOPSourceCodeModel srcModel) throws Exception {
         for (Component baseCmp : baseComponents) {
             List<String> implementedInterfaces = implementedInterfacesGatherer.getImplementedInterfaces(baseCmp);
             for (String implementedInterface : implementedInterfaces) {
-                baseCmp.insertComponentInvocation(new TypeImplementation(implementedInterface));
+                baseCmp.insertComponentRef(new TypeImplementationReference(implementedInterface));
             }
         }
     }
 
     private List<String> getProjectFileSymbols(List<RawFile> files) throws Exception {
 
-        List<String> projectFileTypes = new ArrayList<String>();
+        List<String> projectFileTypes = new ArrayList<>();
         String smallestCodeBaseContaininingDir = files.get(0).name();
 
         for (int i = 1; i < files.size(); i++) {
@@ -65,13 +64,10 @@ private void resolveInterfaces(OOPSourceCodeModel srcModel) throws Exception {
 
         for (RawFile file : files) {
             String modFileName = "";
-            if (file.name().contains("src/")) {
-                modFileName = (file.name().substring(file.name().indexOf("src/") + 4));
-            } else {
-                modFileName = file.name().replaceAll(smallestCodeBaseContaininingDir, "");
-                if (modFileName.startsWith("/")) {
-                    modFileName = modFileName.substring(1);
-                }
+
+            modFileName = file.name().replaceAll(smallestCodeBaseContaininingDir, "");
+            if (modFileName.startsWith("/")) {
+                modFileName = modFileName.substring(1);
             }
 
             if (modFileName.contains("/")) {
@@ -106,7 +102,7 @@ public OOPSourceCodeModel compile(SourceFiles rawData) throws Exception {
              * Update cyclomatic complexities of all structs. We do this right now after the source
              * code model has been built as opposed to at parse time because methods for any given
              * struct in Go can be located anywhere in the project, making their parsing order
-             * nondeterministic.
+             * non-deterministic.
              */
             updateStructCyclomaticComplexities(srcModel);
         }
@@ -162,7 +158,7 @@ private void compileFiles(List<RawFile> files, OOPSourceCodeModel srcModel, List
     private Map<String, List<String>> interfaceMethodSpecsPairs;
 
     ImplementedInterfaces(OOPSourceCodeModel srcModel) throws Exception {
-        this.model = srcModel;
+        model = srcModel;
         Set<Component> allInterfaceComponents = srcModel.components()
                 .filter(s -> (s.componentType() == ComponentType.INTERFACE)).collect(Collectors.toSet());
         interfaceMethodSpecsPairs = new HashMap<>();
@@ -178,15 +174,15 @@ private void compileFiles(List<RawFile> files, OOPSourceCodeModel srcModel, List
      * Retrieves a list of Strings corresponding to the the interfaces implemented
      * by the given base {@linkplain Component}.
      */
-    public List<String> getImplementedInterfaces(Component baseComponent) {
+    List<String> getImplementedInterfaces(Component baseComponent) {
 
         // holds all the implemented interfaces for the given component
-        List<String> implementedInterfaces = new ArrayList<String>();
+        List<String> implementedInterfaces = new ArrayList<>();
 
         if (baseComponent.componentType().isBaseComponent()
                 && baseComponent.componentType() != ComponentType.INTERFACE) {
             // generate a list of method signatures for the given base component.
-            List<String> baseComponentMethodSignatures = new ArrayList<String>();
+            List<String> baseComponentMethodSignatures = new ArrayList<>();
             for (String baseComponentChild : baseComponent.children()) {
                 Optional<Component> childCmp = model.getComponent(baseComponentChild);
                 if (childCmp.isPresent() && childCmp.get().componentType().isMethodComponent()) {
@@ -197,7 +193,7 @@ private void compileFiles(List<RawFile> files, OOPSourceCodeModel srcModel, List
             // check to see if the current component satisfies any of the collected
             // interfaces
             if (!baseComponentMethodSignatures.isEmpty()) {
-                for (Entry<String, List<String>> potentiallyImplementedInterface : this.interfaceMethodSpecsPairs
+                for (Entry<String, List<String>> potentiallyImplementedInterface : interfaceMethodSpecsPairs
                         .entrySet()) {
 
                     if (baseComponentMethodSignatures.containsAll(potentiallyImplementedInterface.getValue())) {
@@ -220,9 +216,9 @@ private void compileFiles(List<RawFile> files, OOPSourceCodeModel srcModel, List
             throw new Exception("Cannot retrieve method specs for a non-interface component!");
         }
 
-        ArrayList<String> methodSpecs = new ArrayList<String>();
+        ArrayList<String> methodSpecs = new ArrayList<>();
 
-        for (ComponentInvocation extend : interfaceComponent.componentInvocations(ComponentInvocations.EXTENSION)) {
+        for (ComponentReference extend : interfaceComponent.references(TypeReferences.EXTENSION)) {
             Optional<Component> cmp = model.getComponent(extend.invokedComponent());
             if (cmp.isPresent() && cmp.get().componentType() == ComponentType.INTERFACE
                     && !cmp.get().equals(interfaceComponent)) {
@@ -243,8 +239,8 @@ private String generateMethodSignature(Component methodComponent) {
         for (String methodParam : methodComponent.children()) {
             Optional<Component> methodParamCmp = model.getComponent(methodParam);
             if (methodParamCmp.isPresent()
-                    && methodParamCmp.get().componentInvocations(ComponentInvocations.DECLARATION).size() > 0) {
-                signature += methodParamCmp.get().componentInvocations(ComponentInvocations.DECLARATION).get(0)
+                    && methodParamCmp.get().references(TypeReferences.SIMPLE).size() > 0) {
+                signature += methodParamCmp.get().references(TypeReferences.SIMPLE).get(0)
                         .invokedComponent() + ",";
             }
         }
@@ -257,9 +253,3 @@ private String generateMethodSignature(Component methodComponent) {
     }
 }
 
-class LengthComp implements Comparator<String> {
-    @Override
-    public int compare(String o1, String o2) {
-        return Integer.compare(o2.length(), o1.length());
-    }
-}
diff --git a/clarpse/src/main/java/com/clarity/compiler/ClarpseJSCompiler.java b/clarpse/src/main/java/com/clarity/compiler/ClarpseJSCompiler.java
index e56f273..0938bae 100644
--- a/clarpse/src/main/java/com/clarity/compiler/ClarpseJSCompiler.java
+++ b/clarpse/src/main/java/com/clarity/compiler/ClarpseJSCompiler.java
@@ -1,6 +1,6 @@
 package com.clarity.compiler;
 
-import com.clarity.CommonDir;
+import com.clarity.listener.JavaScriptExportsListener;
 import com.clarity.listener.JavaScriptListener;
 import com.clarity.sourcemodel.OOPSourceCodeModel;
 import com.google.javascript.jscomp.Compiler;
@@ -10,57 +10,53 @@
 import com.google.javascript.jscomp.SourceFile;
 import com.google.javascript.jscomp.parsing.Config.JsDocParsing;
 import com.google.javascript.rhino.Node;
-import edu.emory.mathcs.backport.java.util.Collections;
 
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 public class ClarpseJSCompiler implements ClarpseCompiler {
 
-    @SuppressWarnings("deprecation")
     private OOPSourceCodeModel compileFiles(List<RawFile> files, List<String> projectFileTypes) {
         OOPSourceCodeModel model = new OOPSourceCodeModel();
-        for (RawFile file : files) {
+        final Map<String, JavaScriptExportsListener.JSExport> exportsMap = new HashMap<>();
+        Compiler compiler = new Compiler();
+        CompilerOptions options = new CompilerOptions();
+        options.setIdeMode(true);
+        options.setParseJsDocDocumentation(JsDocParsing.INCLUDE_DESCRIPTIONS_WITH_WHITESPACE);
+        compiler.initOptions(options);
+        // Generate exports map on initial pass
+        files.forEach(file -> {
             try {
-                Compiler compiler = new Compiler();
-                CompilerOptions options = new CompilerOptions();
-                options.setIdeMode(true);
-                options.setParseJsDocDocumentation(JsDocParsing.INCLUDE_DESCRIPTIONS_WITH_WHITESPACE);
-                compiler.initOptions(options);
                 Node root = new JsAst(SourceFile.fromCode(file.name(), file.content())).getAstRoot(compiler);
-                JavaScriptListener jsListener = new JavaScriptListener(model, file, projectFileTypes);
-                NodeTraversal.traverseEs6(compiler, root, jsListener);
+                NodeTraversal.Callback jsListener = new JavaScriptExportsListener(file, projectFileTypes, exportsMap);
+                NodeTraversal.traverse(compiler, root, jsListener);
             } catch (Exception e) {
                 e.printStackTrace();
             }
-        }
+        });
+        // Parse JS files with populated export map
+        files.forEach(file -> {
+            try {
+                Node root = new JsAst(SourceFile.fromCode(file.name(), file.content())).getAstRoot(compiler);
+                NodeTraversal.Callback jsListener = new JavaScriptListener(model, file, projectFileTypes, files, exportsMap);
+                NodeTraversal.traverse(compiler, root, jsListener);
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        });
         return model;
     }
 
     private List<String> getProjectFileTypes(List<RawFile> files) throws Exception {
-        List<String> projectFileTypes = new ArrayList<String>();
-        String smallestCodeBaseContaininingDir = "";
-
-        for (int i = 1; i < files.size(); i++) {
-            smallestCodeBaseContaininingDir = new CommonDir(smallestCodeBaseContaininingDir, files.get(i).name())
-                    .value();
-        }
-
-        if (smallestCodeBaseContaininingDir.startsWith("/")) {
-            smallestCodeBaseContaininingDir.substring(1);
-        }
-
+        List<String> projectFileTypes = new ArrayList<>();
         for (RawFile file : files) {
-            String modFileName = "";
-            if (file.name().contains("src/")) {
-                modFileName = (file.name().substring(file.name().indexOf("src/") + 4));
-            } else {
-                modFileName = file.name().replaceAll(smallestCodeBaseContaininingDir, "");
-                if (modFileName.startsWith("/")) {
-                    modFileName = modFileName.substring(1);
-                }
+            String modFileName = file.name();
+            if (file.name().startsWith("/")) {
+                modFileName = file.name().substring(1);
             }
-
             if (modFileName.contains("/")) {
                 projectFileTypes.add(modFileName.substring(0, modFileName.lastIndexOf("/")));
             }
@@ -70,7 +66,6 @@ private OOPSourceCodeModel compileFiles(List<RawFile> files, List<String> projec
 
     @Override
     public OOPSourceCodeModel compile(SourceFiles rawData) throws Exception {
-
         OOPSourceCodeModel srcModel = new OOPSourceCodeModel();
         final List<RawFile> files = rawData.getFiles();
         System.out.println(files.size());
diff --git a/clarpse/src/main/java/com/clarity/compiler/Lang.java b/clarpse/src/main/java/com/clarity/compiler/Lang.java
index 8890c6f..803d46d 100644
--- a/clarpse/src/main/java/com/clarity/compiler/Lang.java
+++ b/clarpse/src/main/java/com/clarity/compiler/Lang.java
@@ -28,9 +28,7 @@
     public static List<Lang> supportedLanguages() {
         List<Lang> langs = new ArrayList<>();
         for (Map.Entry<String, Lang> entry : namesMap.entrySet()) {
-            if (entry.getValue() != JAVASCRIPT) {
-                langs.add(entry.getValue());
-            }
+            langs.add(entry.getValue());
         }
         return langs;
     }
diff --git a/clarpse/src/main/java/com/clarity/compiler/LengthComp.java b/clarpse/src/main/java/com/clarity/compiler/LengthComp.java
new file mode 100644
index 0000000..73f45e4
--- /dev/null
+++ b/clarpse/src/main/java/com/clarity/compiler/LengthComp.java
@@ -0,0 +1,10 @@
+package com.clarity.compiler;
+
+import java.util.Comparator;
+
+public class LengthComp implements Comparator<String> {
+    @Override
+    public int compare(String o1, String o2) {
+        return Integer.compare(o2.length(), o1.length());
+    }
+}
diff --git a/clarpse/src/main/java/com/clarity/invocation/AnnotationInvocation.java b/clarpse/src/main/java/com/clarity/invocation/AnnotationInvocation.java
deleted file mode 100644
index 000ef2b..0000000
--- a/clarpse/src/main/java/com/clarity/invocation/AnnotationInvocation.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package com.clarity.invocation;
-
-import java.io.Serializable;
-import java.util.AbstractMap.SimpleEntry;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-
-public class AnnotationInvocation extends ComponentInvocation implements Serializable {
-
-    private static final long serialVersionUID = 4146299386492074733L;
-    @SuppressWarnings("unused")
-    private final String type = "annotation";
-    private List<Entry<String, HashMap<String, String>>> annotations = new ArrayList<Map.Entry<String, HashMap<String, String>>>();
-
-    public List<Entry<String, HashMap<String, String>>> annotations() {
-        return annotations;
-    }
-
-    public AnnotationInvocation(final String invocationComponentName,
-            final SimpleEntry<String, HashMap<String, String>> annotation) {
-        super(invocationComponentName);
-        annotations.add(annotation);
-    }
-
-    public AnnotationInvocation() {
-        super();
-    }
-
-    public AnnotationInvocation(String invokedComponent, List<Entry<String, HashMap<String, String>>> annotations2) {
-        super(invokedComponent);
-        annotations = annotations2;
-    }
-
-    @Override
-    public boolean empty() {
-        return (super.empty() && annotations.isEmpty());
-    }
-
-    @Override
-    public Object clone() {
-        return new AnnotationInvocation(invokedComponent(), annotations);
-    }
-}
diff --git a/clarpse/src/main/java/com/clarity/invocation/ComponentInvocation.java b/clarpse/src/main/java/com/clarity/invocation/ComponentInvocation.java
deleted file mode 100644
index 1c1f5f9..0000000
--- a/clarpse/src/main/java/com/clarity/invocation/ComponentInvocation.java
+++ /dev/null
@@ -1,59 +0,0 @@
-package com.clarity.invocation;
-
-import com.clarity.Emptyable;
-import com.fasterxml.jackson.annotation.JsonSubTypes;
-import com.fasterxml.jackson.annotation.JsonSubTypes.Type;
-import com.fasterxml.jackson.annotation.JsonTypeInfo;
-
-import java.io.Serializable;
-
-/**
- * Represents an invocation of another component in the code base.
- */
-@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "type")
-@JsonSubTypes({ @Type(value = AnnotationInvocation.class, name = "annotation"),
-        @Type(value = EmptyInvocation.class, name = "empty"), @Type(value = ThrownException.class, name = "exception"),
-        @Type(value = TypeDeclaration.class, name = "declaration"),
-        @Type(value = TypeExtension.class, name = "extension"),
-        @Type(value = TypeImplementation.class, name = "implementation"),
-        @Type(value = DocMention.class, name = "doc_mention"),
-        @Type(value = TypeParameter.class, name = "typeparameter") })
-public abstract class ComponentInvocation implements Emptyable, Serializable, Cloneable {
-
-    private static final long serialVersionUID = -242718695900611890L;
-    private String invokedComponent = "";
-
-    public ComponentInvocation(final String invocationComponentName, final int lineNum) {
-        invokedComponent = invocationComponentName;
-    }
-
-    public ComponentInvocation(final ComponentInvocation invocation) {
-        invokedComponent = invocation.invokedComponent();
-    }
-
-    public ComponentInvocation() {
-    }
-
-    @Override
-    public String toString() {
-        return this.getClass().getSimpleName() + ":" + this.invokedComponent;
-    }
-
-    public ComponentInvocation(String invokedComponent2) {
-        invokedComponent = invokedComponent2;
-    }
-
-    public String invokedComponent() {
-        return invokedComponent;
-    }
-
-    @Override
-    public boolean empty() {
-        return invokedComponent.isEmpty();
-    }
-
-    @Override
-    public Object clone() throws CloneNotSupportedException {
-        return super.clone();
-    }
-}
diff --git a/clarpse/src/main/java/com/clarity/invocation/DocMention.java b/clarpse/src/main/java/com/clarity/invocation/DocMention.java
deleted file mode 100644
index 191816e..0000000
--- a/clarpse/src/main/java/com/clarity/invocation/DocMention.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package com.clarity.invocation;
-
-import java.io.Serializable;
-
-public class DocMention extends ComponentInvocation implements Serializable {
-
-    private static final long serialVersionUID = 7807962152246261233L;
-    public final String type = "implementation";
-
-    public DocMention() {
-        super();
-    }
-
-    public DocMention(String invokedComponent) {
-        super(invokedComponent);
-    }
-
-    @Override
-    public Object clone() {
-        return new DocMention(invokedComponent());
-    }
-
-}
diff --git a/clarpse/src/main/java/com/clarity/invocation/EmptyInvocation.java b/clarpse/src/main/java/com/clarity/invocation/EmptyInvocation.java
deleted file mode 100644
index 46c8db9..0000000
--- a/clarpse/src/main/java/com/clarity/invocation/EmptyInvocation.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package com.clarity.invocation;
-
-import java.io.Serializable;
-
-public class EmptyInvocation extends ComponentInvocation implements Serializable {
-
-    private static final long serialVersionUID = -3058881761749807208L;
-    public final String type = "empty";
-
-    public EmptyInvocation(String invocationComponentName) {
-        super(invocationComponentName);
-    }
-
-    @Override
-    public boolean empty() {
-        return true;
-    }
-
-    public EmptyInvocation() {
-        super();
-    }
-
-    @Override
-    public Object clone() {
-        return new EmptyInvocation(invokedComponent());
-    }
-}
diff --git a/clarpse/src/main/java/com/clarity/invocation/InvalidInvocation.java b/clarpse/src/main/java/com/clarity/invocation/InvalidInvocation.java
deleted file mode 100644
index b052de6..0000000
--- a/clarpse/src/main/java/com/clarity/invocation/InvalidInvocation.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package com.clarity.invocation;
-
-import java.io.Serializable;
-
-public class InvalidInvocation extends ComponentInvocation implements Serializable {
-
-    private static final long serialVersionUID = -3058881761749807208L;
-    public final String type = "empty";
-
-    public InvalidInvocation(String invocationComponentName) {
-        super(invocationComponentName);
-    }
-
-    @Override
-    public boolean empty() {
-        return true;
-    }
-
-    public InvalidInvocation() {
-        super();
-    }
-
-    @Override
-    public Object clone() {
-        return new InvalidInvocation(invokedComponent());
-    }
-}
diff --git a/clarpse/src/main/java/com/clarity/invocation/ThrownException.java b/clarpse/src/main/java/com/clarity/invocation/ThrownException.java
deleted file mode 100644
index 6e0015b..0000000
--- a/clarpse/src/main/java/com/clarity/invocation/ThrownException.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package com.clarity.invocation;
-
-import java.io.Serializable;
-
-public class ThrownException extends ComponentInvocation implements Serializable {
-
-    private static final long serialVersionUID = 3346563314076095662L;
-    public final String type = "exception";
-
-    public ThrownException(String invocationComponentName) {
-        super(invocationComponentName);
-    }
-
-    public ThrownException() {
-        super();
-    }
-
-    @Override
-    public Object clone() {
-        return new ThrownException(invokedComponent());
-    }
-
-}
diff --git a/clarpse/src/main/java/com/clarity/invocation/TypeDeclaration.java b/clarpse/src/main/java/com/clarity/invocation/TypeDeclaration.java
deleted file mode 100644
index da7ae94..0000000
--- a/clarpse/src/main/java/com/clarity/invocation/TypeDeclaration.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package com.clarity.invocation;
-
-import java.io.Serializable;
-
-public class TypeDeclaration extends ComponentInvocation implements Serializable {
-
-    private static final long serialVersionUID = 7304258760520469246L;
-    public final String type = "declaration";
-
-    public TypeDeclaration(final String invocationComponentName) {
-        super(invocationComponentName);
-    }
-
-    public TypeDeclaration() {
-        super();
-    }
-
-    @Override
-    public Object clone() {
-        return new TypeDeclaration(invokedComponent());
-    }
-}
diff --git a/clarpse/src/main/java/com/clarity/invocation/TypeExtension.java b/clarpse/src/main/java/com/clarity/invocation/TypeExtension.java
deleted file mode 100644
index 04f6c6b..0000000
--- a/clarpse/src/main/java/com/clarity/invocation/TypeExtension.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package com.clarity.invocation;
-
-import java.io.Serializable;
-
-public final class TypeExtension extends ComponentInvocation implements Serializable {
-
-    private static final long serialVersionUID = 6641497827060470449L;
-    public final String type = "extension";
-
-    public TypeExtension() {
-        super();
-    }
-
-    public TypeExtension(String invokedComponent) {
-        super(invokedComponent);
-    }
-
-    @Override
-    public Object clone() {
-        return new TypeExtension(invokedComponent());
-    }
-}
diff --git a/clarpse/src/main/java/com/clarity/invocation/TypeImplementation.java b/clarpse/src/main/java/com/clarity/invocation/TypeImplementation.java
deleted file mode 100644
index 984064e..0000000
--- a/clarpse/src/main/java/com/clarity/invocation/TypeImplementation.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package com.clarity.invocation;
-
-import java.io.Serializable;
-
-public class TypeImplementation extends ComponentInvocation implements Serializable {
-
-    private static final long serialVersionUID = 7807962152246261233L;
-    public final String type = "implementation";
-
-    public TypeImplementation() {
-        super();
-    }
-
-    public TypeImplementation(String invokedComponent) {
-        super(invokedComponent);
-    }
-
-    @Override
-    public Object clone() {
-        return new TypeImplementation(invokedComponent());
-    }
-
-}
diff --git a/clarpse/src/main/java/com/clarity/invocation/TypeInstantiation.java b/clarpse/src/main/java/com/clarity/invocation/TypeInstantiation.java
deleted file mode 100644
index 27d6930..0000000
--- a/clarpse/src/main/java/com/clarity/invocation/TypeInstantiation.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package com.clarity.invocation;
-
-import java.io.Serializable;
-
-public class TypeInstantiation extends ComponentInvocation implements Serializable {
-
-    private static final long serialVersionUID = 7253490170234016131L;
-    public final String type = "instantiation";
-
-    public TypeInstantiation() {
-        super();
-    }
-
-    public TypeInstantiation(String invokedComponent) {
-        super(invokedComponent);
-    }
-
-    @Override
-    public Object clone() {
-        return new TypeInstantiation(invokedComponent());
-    }
-
-}
diff --git a/clarpse/src/main/java/com/clarity/invocation/TypeParameter.java b/clarpse/src/main/java/com/clarity/invocation/TypeParameter.java
deleted file mode 100644
index 51e04d0..0000000
--- a/clarpse/src/main/java/com/clarity/invocation/TypeParameter.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package com.clarity.invocation;
-
-import java.io.Serializable;
-
-public class TypeParameter extends ComponentInvocation implements Serializable {
-
-    private static final long serialVersionUID = -6321838812633289752L;
-    public final String type = "typeparameter";
-
-    public TypeParameter() {
-        super();
-    }
-
-    public TypeParameter(String invokedComponent) {
-        super(invokedComponent);
-    }
-
-    @Override
-    public Object clone() {
-        return new TypeParameter(invokedComponent());
-    }
-}
\ No newline at end of file
diff --git a/clarpse/src/main/java/com/clarity/listener/GoLangTreeListener.java b/clarpse/src/main/java/com/clarity/listener/GoLangTreeListener.java
index b7c51d2..48b06dd 100644
--- a/clarpse/src/main/java/com/clarity/listener/GoLangTreeListener.java
+++ b/clarpse/src/main/java/com/clarity/listener/GoLangTreeListener.java
@@ -20,9 +20,9 @@
 import com.clarity.antlr.golang.GolangParser.TypeSpecContext;
 import com.clarity.antlr.golang.GolangParser.VarSpecContext;
 import com.clarity.compiler.RawFile;
-import com.clarity.invocation.ComponentInvocation;
-import com.clarity.invocation.TypeDeclaration;
-import com.clarity.invocation.TypeExtension;
+import com.clarity.reference.ComponentReference;
+import com.clarity.reference.SimpleTypeReference;
+import com.clarity.reference.TypeExtensionReference;
 import com.clarity.sourcemodel.Component;
 import com.clarity.sourcemodel.OOPSourceCodeModel;
 import com.clarity.sourcemodel.OOPSourceModelConstants.ComponentType;
@@ -42,6 +42,7 @@
 import java.util.Optional;
 import java.util.Stack;
 
+@SuppressWarnings("unchecked")
 public class GoLangTreeListener extends GolangBaseListener {
 
     private final Stack<Component> componentStack = new Stack<Component>();
@@ -68,9 +69,7 @@ public GoLangTreeListener(final OOPSourceCodeModel srcModel, List<String> projec
     }
 
     private void completeComponent(Component completedComponent) {
-
-
-        // update cyclomatic complexity if component is a method or class
+        // update cyclomatic complexity if component is a method
         if (completedComponent.componentType().isMethodComponent()
                 && !ParseUtil.componentStackContainsInterface(componentStack)) {
             completedComponent.setCyclo(currCyclomaticComplexity);
@@ -83,24 +82,15 @@ private void completeComponent(Component completedComponent) {
                 udpateStructChild(completedComponent, entry.getValue());
             }
         });
-
         if (completedComponent.componentType().isMethodComponent()
                 && srcModel.containsComponent(completedComponent.parentUniqueName())) {
             Component parentCmp = srcModel.getComponent(completedComponent.parentUniqueName()).get();
-            final Iterator<ComponentInvocation> invocationIterator = completedComponent.invocations().iterator();
+            final Iterator<ComponentReference> invocationIterator = completedComponent.references().iterator();
             while (invocationIterator.hasNext()) {
-                parentCmp.insertComponentInvocation(invocationIterator.next());
+                parentCmp.insertComponentRef(invocationIterator.next());
             }
         }
-
-        // include the processed component's invocations into its parent
-        // components
-        for (final Component parentCmp : componentStack) {
-            final Iterator<ComponentInvocation> invocationIterator = completedComponent.invocations().iterator();
-            while (invocationIterator.hasNext()) {
-                parentCmp.insertComponentInvocation(invocationIterator.next());
-                }
-            }
+        ParseUtil.copyRefsToParents(completedComponent, componentStack);
         srcModel.insertComponent(completedComponent);
     }
 
@@ -110,22 +100,6 @@ private void popAndCompleteComponent() {
         }
     }
 
-    /**
-     * Generates appropriate name for the component. Uses the current stack of
-     * parents components as prefixes to the name.
-     */
-    private String generateComponentName(final String identifier) {
-        String componentName = "";
-
-        if (!componentStack.isEmpty()) {
-            final Component completedCmp = componentStack.peek();
-            componentName = completedCmp.componentName() + "." + identifier;
-        } else {
-            componentName = identifier;
-        }
-        return componentName;
-    }
-
     /**
      * Creates a new component based on the given ParseRuleContext.
      */
@@ -134,8 +108,6 @@ private Component createComponent(ComponentType componentType, int line, ParserR
         newCmp.setPackageName(currentPkg);
         newCmp.setComponentType(componentType);
         newCmp.setSourceFilePath(file.name());
-        newCmp.setLine(line);
-        newCmp.setCode(ParseUtil.originalText(ctx));
         return newCmp;
     }
 
@@ -169,9 +141,6 @@ public final void enterPackageClause(PackageClauseContext ctx) {
     public final void enterImportSpec(ImportSpecContext ctx) {
         String fullImportName = ctx.importPath().getText().replaceAll("\"", "");
         for (String s : projectFileTypes) {
-            if (this.file.name().contains("app_only_env")) {
-                System.out.println("");
-            }
             if (s.endsWith(fullImportName) || fullImportName.endsWith(s)) {
                 fullImportName = s;
                 break;
@@ -208,7 +177,7 @@ public final void enterStructType(StructTypeContext ctx) {
                         Arrays.asList(file.content().split("\n")));
                 cmp.setComment(comments);
                 cmp.setName(lastParsedTypeIdentifier);
-                cmp.setComponentName(generateComponentName(lastParsedTypeIdentifier));
+                cmp.setComponentName(ParseUtil.generateComponentName(lastParsedTypeIdentifier, componentStack));
                 cmp.setImports(currentImports);
                 ParseUtil.pointParentsToGivenChild(cmp, componentStack);
                 cmp.insertAccessModifier(visibility(cmp.name()));
@@ -226,7 +195,7 @@ public final void enterInterfaceType(InterfaceTypeContext ctx) {
                         Arrays.asList(file.content().split("\n")));
                 cmp.setComment(comments);
                 cmp.setName(lastParsedTypeIdentifier);
-                cmp.setComponentName(generateComponentName(lastParsedTypeIdentifier));
+                cmp.setComponentName(ParseUtil.generateComponentName(lastParsedTypeIdentifier, componentStack));
                 cmp.setImports(currentImports);
                 ParseUtil.pointParentsToGivenChild(cmp, componentStack);
                 cmp.insertAccessModifier(visibility(cmp.name()));
@@ -254,7 +223,7 @@ public final void enterMethodSpec(MethodSpecContext ctx) {
                 processResult(ctx.signature().result(), cmp);
             }
             cmp.setName(cmp.codeFragment());
-            cmp.setComponentName(generateComponentName(cmp.name()));
+            cmp.setComponentName(ParseUtil.generateComponentName(cmp.name(), componentStack));
             ParseUtil.pointParentsToGivenChild(cmp, componentStack);
             componentStack.push(cmp);
             processParameters(ctx.signature().parameters(), cmp);
@@ -322,7 +291,7 @@ public final void enterMethodDecl(MethodDeclContext ctx) {
                 processResult(ctx.function().signature().result(), cmp);
             }
             cmp.setName(cmp.codeFragment());
-            cmp.setComponentName(generateComponentName(cmp.name()));
+            cmp.setComponentName(ParseUtil.generateComponentName(cmp.name(), componentStack));
             currCyclomaticComplexity = 1 + countLogicalBinaryOperators(ctx);
             componentStack.push(cmp);
             processParameters(ctx.function().signature().parameters(), cmp);
@@ -336,7 +305,12 @@ public final void enterFunctionDecl(FunctionDeclContext ctx) {
 
     @Override
     public final void enterExpression(ExpressionContext ctx) {
+        String origText = ParseUtil.originalText(ctx);
+        if (origText != null) {
+        currCyclomaticComplexity += StringUtils.countMatches(origText, " && ");
+        currCyclomaticComplexity += StringUtils.countMatches(origText, " || ");
         exitExpression(ctx);
+        }
     }
 
     private void setCodeFragmentFromParameters(ParametersContext ctx, Component currMethodCmp) {
@@ -392,20 +366,20 @@ private void processParameters(ParametersContext ctx, Component currMethodCmp) {
                     for (String methodArgName : argumentNames) {
                         Component cmp = createComponent(ComponentType.METHOD_PARAMETER_COMPONENT, ctx.getStart().getLine(), ctx);
                         cmp.setName(methodArgName);
-                        cmp.setComponentName(generateComponentName(cmp.name()));
+                        cmp.setComponentName(ParseUtil.generateComponentName(cmp.name(), componentStack));
                         if (!componentStack.isEmpty()) {
                             final Component completedCmp = componentStack.peek();
                             cmp.setPackageName(completedCmp.packageName());
                         }
                         ParseUtil.pointParentsToGivenChild(cmp, componentStack);
                         for (int h = 0; h < types.length; h++) {
-                            cmp.insertComponentInvocation(new TypeDeclaration(types[h]));
+                            cmp.insertComponentRef(new SimpleTypeReference(types[h]));
                             paramCmps.add(cmp);
                         }
                     }
                 }
             }
-            paramCmps.forEach(item -> completeComponent(item));
+            paramCmps.forEach(this::completeComponent);
         }
     }
 
@@ -462,7 +436,6 @@ public final void enterReceiver(ReceiverContext ctx) {
     @Override
     public final void enterTypeName(TypeNameContext ctx) {
         String resolvedType = resolveType(ctx.getText());
-        //System.out.println(resolvedType);
         if (!componentStack.isEmpty() && componentStack.peek().componentType().isMethodComponent()) {
             Component cmp = componentStack.pop();
             if (inResultContext) {
@@ -484,9 +457,7 @@ public final void enterTypeName(TypeNameContext ctx) {
             if (inReceiverContext) {
                 if (srcModel.containsComponent(resolvedType)) {
                     Optional<Component> structCmp = srcModel.getComponent(resolvedType);
-                    if (structCmp.isPresent()) {
-                        udpateStructChild(structCmp.get(), cmp);
-                    }
+                    structCmp.ifPresent(component -> udpateStructChild(component, cmp));
                 } else {
                     structWaitingList.add(new AbstractMap.SimpleEntry<String, Component>(resolvedType, cmp));
                 }
@@ -497,12 +468,12 @@ public final void enterTypeName(TypeNameContext ctx) {
                 for (TerminalNode identifier : tmpContext.identifierList().IDENTIFIER()) {
                     Component localVarCmp = createComponent(ComponentType.LOCAL, ctx.getStart().getLine(), ctx);
                     localVarCmp.setName(identifier.getText());
-                    localVarCmp.setComponentName(generateComponentName(identifier.getText()));
-                    localVarCmp.insertComponentInvocation(new TypeDeclaration(resolvedType));
+                    localVarCmp.setComponentName(ParseUtil.generateComponentName(identifier.getText(), componentStack));
+                    localVarCmp.insertComponentRef(new SimpleTypeReference(resolvedType));
+                    ParseUtil.pointParentsToGivenChild(localVarCmp, componentStack);
                     completeComponent(localVarCmp);
                 }
-                }
-
+            }
         }
     }
 
@@ -529,7 +500,7 @@ private void udpateStructChild(Component structCmp, Component structChildCmp) {
             }
         }
         childrenToBeRemoved.forEach(item -> structChildCmp.children().remove(item));
-        childrenToBeAdded.forEach(item -> structChildCmp.insertChildComponent(item));
+        childrenToBeAdded.forEach(structChildCmp::insertChildComponent);
         structCmp.insertChildComponent(structChildCmp.uniqueName());
     }
 
@@ -644,7 +615,7 @@ public final void enterFieldDecl(FieldDeclContext ctx) {
                     cmp.setName(token.getText());
                     cmp.setComment(
                             ParseUtil.goLangComments(ctx.getStart().getLine(), Arrays.asList(file.content().split("\n"))));
-                    cmp.setComponentName(generateComponentName(token.getText()));
+                    cmp.setComponentName(ParseUtil.generateComponentName(token.getText(), componentStack));
                     if (ctx.type().getText().contains("func")) {
                         String line = file.content().split("\n")[ctx.type().start.getLine() - 1];
                         if (line.trim().endsWith("}")) {
@@ -661,11 +632,11 @@ public final void enterFieldDecl(FieldDeclContext ctx) {
                     ParseUtil.pointParentsToGivenChild(cmp, componentStack);
                     String[] types = getChildContextText(ctx.type()).split(",");
                     for (String type : types) {
-                        cmp.insertComponentInvocation(new TypeDeclaration(resolveType(type)));
+                        cmp.insertComponentRef(new SimpleTypeReference(resolveType(type)));
                     }
                     fieldVars.add(cmp);
                 }
-                fieldVars.forEach(item -> completeComponent(item));
+                fieldVars.forEach(this::completeComponent);
             } else if (ctx.anonymousField() != null) {
                 String[] types = getChildContextText(ctx.anonymousField()).split(",");
                 for (String type : types) {
@@ -683,7 +654,7 @@ private void insertExtensionIntoStackBaseComponent(String extendsComponent) {
             Component stackCmp = componentStack.pop();
             tmp.add(stackCmp);
             if (stackCmp.componentType().isBaseComponent()) {
-                stackCmp.insertComponentInvocation(new TypeExtension(resolveType(extendsComponent)));
+                stackCmp.insertComponentRef(new TypeExtensionReference(resolveType(extendsComponent)));
                 break;
             }
         }
@@ -693,7 +664,9 @@ private void insertExtensionIntoStackBaseComponent(String extendsComponent) {
     /**
      * Tries to return the full, unique type name of the given type.
      */
-    private String resolveType(final String type) {
+    private String resolveType(String type) {
+
+        type = type.replace("*", "");
 
         if (currentImportsMap.containsKey(type)) {
             return currentImportsMap.get(type).replaceAll("/", ".");
@@ -701,9 +674,9 @@ private String resolveType(final String type) {
 
         final Iterator<?> it = currentImportsMap.entrySet().iterator();
         while (it.hasNext()) {
-            @SuppressWarnings("rawtypes") final Map.Entry pair = (Map.Entry) it.next();
-            if (type.startsWith((String) pair.getKey())) {
-                return (((String) pair.getValue()).replaceAll("/", ".")) + "." + type.replace(pair.getKey() + ".", "");
+            @SuppressWarnings("rawtypes") final Map.Entry<String, String> pair = (Map.Entry<String, String>) it.next();
+            if (type.startsWith(pair.getKey())) {
+                return ((pair.getValue()).replaceAll("/", ".")) + "." + type.replace(pair.getKey() + ".", "");
             }
         }
         if (type.contains(".")) {
@@ -724,8 +697,6 @@ private boolean baseType(String type) {
                 || type.equals("complex64") || type.equals("complex128") || type.equals("bool"));
     }
 
-
-
     @Override
     public final void enterTypeSpec(TypeSpecContext ctx) {
         lastParsedTypeIdentifier = ctx.IDENTIFIER().getText();
@@ -740,7 +711,6 @@ private boolean componentStackContainsMethod() {
         return false;
     }
 
-
     class LetterProvider {
         private int count = -1;
         private String[] letters = new String[]{"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"};
diff --git a/clarpse/src/main/java/com/clarity/listener/JavaScriptExportsListener.java b/clarpse/src/main/java/com/clarity/listener/JavaScriptExportsListener.java
new file mode 100644
index 0000000..1df4ca0
--- /dev/null
+++ b/clarpse/src/main/java/com/clarity/listener/JavaScriptExportsListener.java
@@ -0,0 +1,135 @@
+package com.clarity.listener;
+
+import com.clarity.TrimmedString;
+import com.clarity.compiler.RawFile;
+import com.google.common.io.Files;
+import com.google.javascript.jscomp.NodeTraversal;
+import com.google.javascript.jscomp.NodeTraversal.Callback;
+import com.google.javascript.rhino.Node;
+
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Listener for JavaScript ES6+ source files, based on google's closure
+ * compiler.
+ */
+public class JavaScriptExportsListener implements Callback {
+
+    private final Map<String, JSExport> exportsMap;
+    private RawFile file;
+    private List<String> projectFileTypes;
+    private String currPackage = "";
+    private String currProjectFileType = "";
+
+    public JavaScriptExportsListener(final RawFile file, List<String> projectFileTypes,
+                                     Map<String, JSExport> exportsMap) throws Exception {
+        this.file = file;
+        this.projectFileTypes = projectFileTypes;
+        this.exportsMap = exportsMap;
+        System.out.println("\nParsing New JS File: " + file.name() + "\n");
+        // Determine current file's file type
+        if (file.name().contains("/")) {
+            String modFileName = file.name().substring(0, file.name().lastIndexOf("/"));
+            for (String s : projectFileTypes) {
+                if (modFileName.endsWith(s)) {
+                    currPackage = new TrimmedString(s, "/").value().replaceAll("/", ".");
+                    currProjectFileType = s;
+                    break;
+                }
+            }
+        }
+    }
+
+    @Override
+    public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) {
+        try {
+            return shouldTraverse(n, parent);
+        } catch (Exception e) {
+            e.printStackTrace();
+            return true;
+        }
+    }
+
+    @Override
+    public void visit(NodeTraversal nodeTraversal, Node node, Node node1) {
+    }
+
+    private boolean shouldTraverse(Node n, Node parent) throws Exception {
+        if (n.isExport()) {
+            // Handle 'default export ... ' type exports
+            if (n.getBooleanProp(Node.EXPORT_DEFAULT)) {
+                String pkgPrefix = "";
+                if (!currProjectFileType.isEmpty()) {
+                    pkgPrefix = currPackage + ".";
+                }
+                String childOneStr = Files.getNameWithoutExtension(file.name());
+                if (n.getChildAtIndex(0).getFirstChild() != null && !n.getChildAtIndex(0).getFirstChild().isEmpty()) {
+                    if (n.getChildAtIndex(0).getFirstChild() != null) {
+                        childOneStr = n.getChildAtIndex(0).getFirstChild().getString();
+                    }
+                }
+                exportsMap.put(pkgPrefix + childOneStr,
+                        new JSExport(pkgPrefix + childOneStr,
+                                pkgPrefix + childOneStr, currProjectFileType)
+                );
+            }
+            // Handle exports that do not use 'export default ...' syntax
+            for (Node exportNode : n.children()) {
+                if (exportNode.isExportSpecs()) {
+                    for (Node exportSpecsChildNode : exportNode.children()) {
+                        if (exportSpecsChildNode.isExportSpec()) {
+                            processExportSpec(exportSpecsChildNode);
+                        }
+                    }
+                } else if (exportNode.isExportSpec()) {
+                    processExportSpec(exportNode);
+                }
+            }
+        }
+        return true;
+    }
+
+    private void processExportSpec(Node exportSpec) {
+        String pkgPrefix = "";
+        if (!currProjectFileType.isEmpty()) {
+            pkgPrefix = currPackage + ".";
+        }
+        if (exportSpec.hasTwoChildren()) {
+            String childOneStr = exportSpec.getChildAtIndex(0).getString();
+            String childTwoStr = exportSpec.getChildAtIndex(1).getString();
+            if (childTwoStr.equals("default")) {
+                childTwoStr = childOneStr;
+            }
+            exportsMap.put(pkgPrefix + childTwoStr,
+                    new JSExport(pkgPrefix + childOneStr,
+                            pkgPrefix + childTwoStr, currProjectFileType)
+            );
+        }
+    }
+
+    public class JSExport {
+
+        private String exportedPkgAlias;
+        private final String exportedPkg;
+        private final String fileType;
+
+        JSExport(String exportedPkg, String exportedPkgAlias, String fileType) {
+            this.exportedPkg = exportedPkg;
+            this.exportedPkgAlias = exportedPkgAlias;
+            this.fileType = fileType;
+        }
+
+        String fileType() {
+            return fileType;
+        }
+
+        String exportedPkgAlias() {
+            return exportedPkgAlias;
+        }
+
+        String exportedPkg() {
+            return exportedPkg;
+        }
+    }
+}
diff --git a/clarpse/src/main/java/com/clarity/listener/JavaScriptListener.java b/clarpse/src/main/java/com/clarity/listener/JavaScriptListener.java
index 7a103af..3c506cb 100644
--- a/clarpse/src/main/java/com/clarity/listener/JavaScriptListener.java
+++ b/clarpse/src/main/java/com/clarity/listener/JavaScriptListener.java
@@ -1,20 +1,10 @@
 package com.clarity.listener;
 
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Stack;
-
 import com.clarity.ResolvedRelativePath;
 import com.clarity.TrimmedString;
 import com.clarity.compiler.RawFile;
-import com.clarity.invocation.ComponentInvocation;
-import com.clarity.invocation.TypeDeclaration;
-import com.clarity.invocation.TypeExtension;
-import com.clarity.invocation.TypeImplementation;
-import com.clarity.invocation.TypeInstantiation;
+import com.clarity.reference.SimpleTypeReference;
+import com.clarity.reference.TypeExtensionReference;
 import com.clarity.sourcemodel.Component;
 import com.clarity.sourcemodel.OOPSourceCodeModel;
 import com.clarity.sourcemodel.OOPSourceModelConstants.ComponentType;
@@ -24,25 +14,41 @@
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Stack;
+import java.util.stream.Collectors;
+
+import static com.clarity.sourcemodel.OOPSourceModelConstants.ComponentType.CONSTRUCTOR_PARAMETER_COMPONENT;
+import static com.clarity.sourcemodel.OOPSourceModelConstants.ComponentType.METHOD_PARAMETER_COMPONENT;
+
 /**
  * Listener for JavaScript ES6+ source files, based on google's closure
  * compiler.
  */
 public class JavaScriptListener implements Callback {
 
-    private final Stack<Component> componentStack = new Stack<Component>();
+    private final Stack<Component> componentStack = new Stack<>();
+    private final List<RawFile> files;
+    private final Map<String, JavaScriptExportsListener.JSExport> exportsMap;
     private OOPSourceCodeModel srcModel;
     private RawFile file;
     private List<String> projectFileTypes;
     private String currPackage = "";
     private String currProjectFileType = "";
-    private final Map<String, String> currentImportsMap = new HashMap<String, String>();
+    private final Map<String, String> currentImportsMap = new HashMap<>();
+    private int currCyclomaticComplexity = 0;
 
-    public JavaScriptListener(final OOPSourceCodeModel srcModel, final RawFile file, List<String> projectFileTypes)
-            throws Exception {
+    public JavaScriptListener(final OOPSourceCodeModel srcModel, final RawFile file, List<String> projectFileTypes,
+                              List<RawFile> files, Map<String, JavaScriptExportsListener.JSExport> exportsMap) throws Exception {
         this.srcModel = srcModel;
         this.file = file;
         this.projectFileTypes = projectFileTypes;
+        this.files = files;
+        this.exportsMap = exportsMap;
         System.out.println("\nParsing New JS File: " + file.name() + "\n");
 
         if (file.name().contains("/")) {
@@ -62,7 +68,7 @@ public void visit(NodeTraversal t, Node n, Node parent) {
 
         String fileName = null;
         try {
-            fileName = new TrimmedString(this.file.name(), "/").value();
+            fileName = new TrimmedString(file.name(), "/").value();
             String baseCmpName = null;
 
             if (n.isClass()) {
@@ -105,99 +111,124 @@ public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent)
         }
     }
 
-    public boolean shouldTraverse(Node n, Node parent) throws Exception {
+    /**
+     * Returns the package name represented by the given import source path.
+     * E.g. getImportPackage("/proj/module/A.js") -> "proj.module"
+     * This method handles relative and absolute paths provided for the import source path.
+     */
+    private String getImportPackage(String importSourcePath) throws Exception {
+        String importSourceType = null;
+        if (importSourcePath.startsWith("/")) {
+            // absolute import path provided..
+            if (importSourcePath.endsWith(".js") && importSourcePath.contains("/")) {
+                importSourceType = importSourcePath.substring(0, importSourcePath.lastIndexOf("/"));
+            }
+        } else {
+            // relative import path provided...
+            importSourceType = new TrimmedString(
+                    new ResolvedRelativePath(currProjectFileType, importSourcePath).value(), "/").value();
+        }
+        for (String fileTypes : projectFileTypes) {
+            if (importSourceType.startsWith(fileTypes)) {
+                importSourceType = new TrimmedString(fileTypes, "/").value().replaceAll("/", ".");
+                break;
+            }
+        }
+        return importSourceType.replaceAll("/", ".");
+    }
 
+    private boolean shouldTraverse(Node n, Node parent) throws Exception {
         if (n.isImport()) {
-            String origin = n.getChildAtIndex(2).getString();
-            String modOrigin = null;
-            if (origin.startsWith("/")) {
-                // absolute import path provided..
-                if (origin.contains(".")) {
-                    modOrigin = origin.substring(0, origin.lastIndexOf("/"));
-                }
-            } else {
-                // relative import path provided...
-                modOrigin = new ResolvedRelativePath(currProjectFileType, origin).value();
+            // Represents the module name of the import statement.
+            String moduleName = n.getLastChild().getString();
+            // Add file ending to module if it does not exist
+            if (!moduleName.matches("^.*\\.[a-z]+$")) {
+                moduleName += ".js";
             }
-            for (String s : projectFileTypes) {
-                if (modOrigin.endsWith(s)) {
-                    origin = new TrimmedString(s, "/").value().replaceAll("/", ".");
-                    break;
-                }
+            // Get package represented by the moduleName path
+            String importSourcePackage = getImportPackage(moduleName);
+            // Update imports map..
+            if (n.getFirstChild().isName()) {
+                processDefaultImport(n.getFirstChild().getString(),
+                        new TrimmedString(importSourcePackage + "." + n.getFirstChild().getString(), ".").value());
             }
-
-            Node importSpecsNode = n.getChildAtIndex(1);
-            for (int i = 0; i < importSpecsNode.getChildCount(); i++) {
-                Node importSpec = importSpecsNode.getChildAtIndex(i);
-                if (importSpec.hasOneChild()) {
-                    String childOneStr = importSpec.getChildAtIndex(0).getString();
-                    currentImportsMap.put(childOneStr, origin + "." + childOneStr);
-                } else if (importSpec.hasTwoChildren()) {
-                    String childOneStr = importSpec.getChildAtIndex(0).getString();
-                    String childTwoStr = importSpec.getChildAtIndex(1).getString();
-                    currentImportsMap.put(childOneStr, origin + "." + childTwoStr);
+            for (Node importNode : n.children()) {
+                if (importNode.isImportSpecs()) {
+                    for (Node importSpecsChildNode : importNode.children()) {
+                        if (importSpecsChildNode.isImportSpec()) {
+                            processImportSpec(importSpecsChildNode, importSourcePackage);
+                        }
+                    }
+                } else if (importNode.isImportSpec()) {
+                    processImportSpec(importNode, importSourcePackage);
                 }
             }
         }
-
         Component cmp = null;
         if (n.isClass()) {
             processClass(cmp, n);
         } else if (n.isMemberFunctionDef()) {
             processMemberFunctionDef(cmp, n);
         } else if (n.isGetterDef()) {
+            currCyclomaticComplexity = 1;
             String cmpName = "get_" + n.getString();
             System.out.println("Found getter definition: " + cmpName);
             cmp = createComponent(ComponentType.METHOD, n);
-            cmp.setComponentName(generateComponentName(cmpName));
+            cmp.setComponentName(ParseUtil.generateComponentName(cmpName, componentStack));
             cmp.setName(cmpName);
-            pointParentsToGivenChild(cmp);
+            updateParentChildrenData(cmp);
             if (n.isStaticMember()) {
                 cmp.insertAccessModifier("static");
             }
             cmp.insertAccessModifier("public");
             componentStack.push(cmp);
         } else if (n.isSetterDef()) {
+            currCyclomaticComplexity = 1;
             String cmpName = "set_" + n.getString();
             System.out.println("Found setter definition: " + cmpName);
             cmp = createComponent(ComponentType.METHOD, n);
-            cmp.setComponentName(generateComponentName(cmpName));
+            cmp.setComponentName(ParseUtil.generateComponentName(cmpName, componentStack));
             cmp.setName(cmpName);
             cmp.setPackageName(currPackage);
             cmp.insertAccessModifier("public");
             if (n.isStaticMember()) {
                 cmp.insertAccessModifier("static");
             }
-            pointParentsToGivenChild(cmp);
+            updateParentChildrenData(cmp);
             componentStack.push(cmp);
-        } else if (n.isParamList()) {
-            List<Component> generatedParamComponents = new ArrayList<Component>();
-            // determine if the top of the component stack is a method
-            // or a constructor...
-            boolean isConstructor = true;
-            if (componentStack.peek().componentType() != ComponentType.CONSTRUCTOR) {
-                isConstructor = false;
+        } else if (n.isParamList() && !componentStack.isEmpty() && componentStack.peek().componentType().isMethodComponent()) {
+            List<Component> generatedParamComponents = new ArrayList<>();
+            // determine type of param component to create based on type of current component at the top of stack
+            ComponentType paramComponentType = METHOD_PARAMETER_COMPONENT;
+            if (componentStack.peek().componentType() == ComponentType.CONSTRUCTOR) {
+                paramComponentType = CONSTRUCTOR_PARAMETER_COMPONENT;
             }
             for (Node param : n.children()) {
-                String paramName = param.getString();
-                System.out.println("Found Parameter: " + paramName);
-                if (isConstructor) {
-                    cmp = createComponent(ComponentType.CONSTRUCTOR_PARAMETER_COMPONENT, n);
+                String paramName = null;
+                if (param.isString() || param.isName()) {
+                    paramName = param.getString();
+                } else if (param.isDefaultValue()) {
+                    paramName = param.getFirstChild().getString();
                 } else {
-                    cmp = createComponent(ComponentType.METHOD_PARAMETER_COMPONENT, n);
+                    throw new Exception("Unrecognized function param type! " + param.toString());
                 }
-                cmp.setComponentName(generateComponentName(paramName));
+                cmp = createComponent(paramComponentType, n);
+                cmp.setComponentName(ParseUtil.generateComponentName(paramName, componentStack));
                 cmp.setName(paramName);
                 cmp.setPackageName(currPackage);
-                pointParentsToGivenChild(cmp);
+                updateParentChildrenData(cmp);
                 generatedParamComponents.add(cmp);
             }
+            // Set parent method code Fragment using param list
+            Component parentMethod = componentStack.peek();
+            parentMethod.setCodeFragment(parentMethod.name() + generateCodeFragment(generatedParamComponents));
+            // Complete method param components
             for (Component paramCmp : generatedParamComponents) {
                 componentStack.push(paramCmp);
                 completeComponent();
             }
         } else if (n.isAssign() && n.getFirstChild().hasChildren() && n.getFirstChild().getFirstChild().isThis()
-                && newestMethodComponent().componentType() == ComponentType.CONSTRUCTOR) {
+                && ParseUtil.newestMethodComponent(componentStack).componentType() == ComponentType.CONSTRUCTOR) {
             String fieldVarname = n.getFirstChild().getSecondChild().getString();
             System.out.println("Found field variable: " + fieldVarname);
             cmp = createComponent(ComponentType.FIELD, n);
@@ -206,53 +237,99 @@ public boolean shouldTraverse(Node n, Node parent) throws Exception {
             cmp.setPackageName(currPackage);
             cmp.insertAccessModifier("private");
             processVariableAssignment(cmp, n.getSecondChild());
-            try {
-                pointParentsToGivenChild(cmp);
-            } catch (Exception e) {
-                e.printStackTrace();
-                // don't add this component to the stack..
-                return true;
-            }
+            updateParentChildrenData(cmp);
             componentStack.push(cmp);
             completeComponent();
-
         } else if (!componentStack.isEmpty() && (n.isVar() || n.isLet())
-                && (newestMethodComponent().componentType() == ComponentType.METHOD
-                        || newestMethodComponent().componentType() == ComponentType.CONSTRUCTOR)) {
+                && (ParseUtil.newestMethodComponent(componentStack).componentType() == ComponentType.METHOD
+                || ParseUtil.newestMethodComponent(componentStack).componentType() == ComponentType.CONSTRUCTOR)) {
             String localVarName = n.getFirstChild().getString();
             System.out.println("Found local variable: " + localVarName);
             cmp = createComponent(ComponentType.LOCAL, n);
-            cmp.setComponentName(generateComponentName(localVarName));
+            cmp.setComponentName(ParseUtil.generateComponentName(localVarName, componentStack));
             cmp.setName(localVarName);
             cmp.setPackageName(currPackage);
             processVariableAssignment(cmp, n.getFirstChild().getFirstChild());
-            pointParentsToGivenChild(cmp);
+            updateParentChildrenData(cmp);
             componentStack.push(cmp);
             completeComponent();
-        } else if (!componentStack.isEmpty() && n.isNew()) {
-            processVariableAssignment(newestMethodComponent(), n);
-        } else if (n.isName() && !n.getString().isEmpty()
-                && (NodeUtil.isImportedName(n) || Character.isUpperCase(n.getString().codePointAt(0)))
-                && !componentStack.isEmpty()) {
-            Component latestCmp = componentStack.pop();
-            latestCmp.insertComponentInvocation(new TypeDeclaration(resolveType(n.getString())));
-            componentStack.push(latestCmp);
         } else if (n.isGetProp() && n.getFirstChild().isName() && !n.getFirstChild().getString().isEmpty()
                 && (NodeUtil.isImportedName(n.getFirstChild())
-                        || Character.isUpperCase(n.getFirstChild().getString().codePointAt(0)))
+                || Character.isUpperCase(n.getFirstChild().getString().codePointAt(0)))
                 && !componentStack.isEmpty()) {
             Component latestCmp = componentStack.pop();
-            latestCmp.insertComponentInvocation(new TypeDeclaration(resolveType(n.getFirstChild().getString())));
+            latestCmp.insertComponentRef(new SimpleTypeReference(resolveType(n.getFirstChild().getString())));
             componentStack.push(latestCmp);
+        } else if (n.isCase() || n.isSwitch() || n.isIf() || n.isAnd() || n.isOr() || n.isHook()) {
+            currCyclomaticComplexity += 1;
         }
         return true;
     }
 
+    private void processDefaultImport(String pkgClass, String fullPkg) throws Exception {
+        updateImportsMap(pkgClass, fullPkg, true);
+    }
+
+    private void processImportSpec(Node importSpec, String origin) throws Exception {
+        String importPrefix = "";
+        if (!origin.isEmpty()) {
+            importPrefix = new TrimmedString(origin, ".").value() + ".";
+        }
+        if (importSpec.hasOneChild()) {
+            String childOneStr = importSpec.getChildAtIndex(0).getString();
+            String fullPkg = importPrefix + childOneStr;
+            updateImportsMap(childOneStr, fullPkg, false);
+        } else if (importSpec.hasTwoChildren()) {
+            String childOneStr = importSpec.getChildAtIndex(0).getString();
+            String childTwoStr = importSpec.getChildAtIndex(1).getString();
+            String fullPkg = importPrefix + childOneStr;
+            updateImportsMap(childTwoStr, fullPkg, false);
+        }
+    }
+
+    private void updateImportsMap(String importComponent, String importPkg, boolean defaultExport) throws Exception {
+        boolean foundLocalMatch = false;
+        if (!defaultExport) {
+            if (exportsMap.containsKey(importPkg)) {
+                JavaScriptExportsListener.JSExport jsExport = exportsMap.get(importPkg);
+                if (jsExport.exportedPkgAlias() != null && jsExport.exportedPkgAlias().equals(importPkg)) {
+                    importPkg = jsExport.exportedPkg();
+                }
+            }
+        } else {
+            String searchBasePkg = new TrimmedString(importPkg.replace(importComponent, ""), ".").value();
+            for (JavaScriptExportsListener.JSExport value : exportsMap.values()) {
+                String potentialExportPkg = value.exportedPkgAlias();
+                if (value.exportedPkgAlias() == null) {
+                    potentialExportPkg = value.exportedPkg();
+                }
+                if (value.fileType().replace("/", ".").equals(searchBasePkg)) {
+                    currentImportsMap.put(importComponent, potentialExportPkg);
+                    return;
+                }
+            }
+        }
+        currentImportsMap.put(importComponent, importPkg);
+    }
+
+    private String generateCodeFragment(List<Component> components) {
+        String codeFragment = "(";
+        for (Component cmp : components) {
+            codeFragment += cmp.name() + ", ";
+        }
+        codeFragment = codeFragment.trim();
+        if (codeFragment.endsWith(",")) {
+            codeFragment = codeFragment.substring(0, codeFragment.length() - 1);
+        }
+        codeFragment += ")";
+        return codeFragment;
+    }
+
     private void processClass(Component cmp, Node n) throws Exception {
         cmp = createComponent(ComponentType.CLASS, n);
         String name = "";
         if (n.getParent().isExport() && n.getParent().getBooleanProp(Node.EXPORT_DEFAULT)) {
-            String fileName = new TrimmedString(this.file.name(), "/").value();
+            String fileName = new TrimmedString(file.name(), "/").value();
             if (fileName.contains("/")) {
                 name = fileName.substring(fileName.lastIndexOf("/") + 1, fileName.lastIndexOf("."));
             } else {
@@ -262,59 +339,59 @@ private void processClass(Component cmp, Node n) throws Exception {
             name = n.getFirstChild().getString();
         }
         name = name.replaceAll("/", ".");
-        cmp.setComponentName(generateComponentName(name));
+        cmp.setComponentName(ParseUtil.generateComponentName(name, componentStack));
         cmp.setName(name);
         cmp.setPackageName(currPackage);
-        pointParentsToGivenChild(cmp);
+        updateParentChildrenData(cmp);
         if (n.getSecondChild().isName()) {
             // this class extends another class
             System.out.println("this class extends " + n.getSecondChild().getString());
-            cmp.insertComponentInvocation(new TypeExtension(n.getSecondChild().getString()));
+            cmp.insertComponentRef(new TypeExtensionReference(resolveType(n.getSecondChild().getString())));
         }
         componentStack.push(cmp);
-
     }
 
     private void processMemberFunctionDef(Component cmp, Node n) throws Exception {
+        currCyclomaticComplexity = 1;
         if (n.getString() != null && n.getString().equals("constructor")) {
             System.out.println("Found constructor");
             cmp = createComponent(ComponentType.CONSTRUCTOR, n);
-            cmp.setComponentName(generateComponentName("constructor"));
+            cmp.setComponentName(ParseUtil.generateComponentName("constructor", componentStack));
             cmp.setName("constructor");
             cmp.setPackageName(currPackage);
-            pointParentsToGivenChild(cmp);
+            updateParentChildrenData(cmp);
             componentStack.push(cmp);
         } else {
             System.out.println("Found instance method: " + n.getString());
             cmp = createComponent(ComponentType.METHOD, n);
-            cmp.setComponentName(generateComponentName(n.getString()));
+            cmp.setComponentName(ParseUtil.generateComponentName(n.getString(), componentStack));
             cmp.setName(n.getString());
             cmp.setPackageName(currPackage);
             if (n.isStaticMember()) {
                 cmp.insertAccessModifier("static");
             }
             cmp.insertAccessModifier("public");
-            pointParentsToGivenChild(cmp);
+            updateParentChildrenData(cmp);
             componentStack.push(cmp);
         }
-
     }
 
     private void processVariableAssignment(Component cmp, Node assignmentNode) {
-        if (NodeUtil.isLiteralValue(assignmentNode, false)) {
-            cmp.setCodeFragment(cmp.name() + " : " + NodeUtil.getStringValue(assignmentNode));
-            cmp.setCodeFragment(declarationSnippet(assignmentNode.getToken()));
-        } else if (assignmentNode.hasChildren() && assignmentNode.isNew()
+        if (assignmentNode != null && NodeUtil.isLiteralValue(assignmentNode, false)) {
+            cmp.setCodeFragment(cmp.name() + " : " + declarationSnippet(assignmentNode.getToken()));
+        } else if (assignmentNode != null && assignmentNode.hasChildren() && assignmentNode.isNew()
                 && (assignmentNode.getFirstChild().isName() || assignmentNode.getFirstChild().isGetProp())) {
             String invokedType;
             if (assignmentNode.getFirstChild().isGetProp()) {
                 invokedType = assignmentNode.getFirstChild().getFirstChild().getString();
-                cmp.insertComponentInvocation(new TypeDeclaration(invokedType));
+                cmp.insertComponentRef(new SimpleTypeReference(resolveType(invokedType)));
             } else {
                 invokedType = assignmentNode.getFirstChild().getString();
-                cmp.insertComponentInvocation(new TypeInstantiation(invokedType));
+                cmp.insertComponentRef(new SimpleTypeReference(resolveType(invokedType)));
             }
-            cmp.setCodeFragment(invokedType);
+            cmp.setCodeFragment(cmp.name() + " : " + invokedType);
+        } else {
+            cmp.setCodeFragment(cmp.name());
         }
     }
 
@@ -322,45 +399,25 @@ private void completeComponent() {
         if (!componentStack.isEmpty()) {
             final Component completedCmp = componentStack.pop();
             System.out.println("Completing component: " + completedCmp.uniqueName());
-            // bubble up the completing component's invocations to it's parent components
-            // that are currently on the stack
-            for (final Component parentCmp : componentStack) {
-                final Iterator<ComponentInvocation> invocationIterator = completedCmp.invocations().iterator();
-                while (invocationIterator.hasNext()) {
-                    ComponentInvocation invocation = invocationIterator.next();
-                    if (!(invocation instanceof TypeExtension || invocation instanceof TypeImplementation)) {
-                        // if the invocation is not a class extension or implementation,
-                        // bubble it up!
-                        parentCmp.insertComponentInvocation(invocation);
-                    }
-                }
+            ParseUtil.copyRefsToParents(completedCmp, componentStack);
+            // update cyclomatic complexity if component is a method
+            if (completedCmp.componentType().isMethodComponent()
+                    && !ParseUtil.componentStackContainsInterface(componentStack)) {
+                completedCmp.setCyclo(currCyclomaticComplexity);
+            } else if (completedCmp.componentType() == ComponentType.CLASS) {
+                completedCmp.setCyclo(ParseUtil.calculateClassCyclo(completedCmp, srcModel));
+                completedCmp.setImports(currentImportsMap.values().stream()
+                        .collect(Collectors.toList()));
             }
             srcModel.insertComponent(completedCmp);
         }
     }
 
-    /**
-     * Generates appropriate name for the component. Uses the current stack of
-     * parents components as prefixes to the name.
-     */
-    private String generateComponentName(final String identifier) {
-        String componentName = "";
-
-        if (!componentStack.isEmpty()) {
-            final Component completedCmp = componentStack.peek();
-            componentName = completedCmp.componentName() + "." + identifier;
-        } else {
-            componentName = identifier;
-        }
-        return componentName;
-    }
-
     private String generateComponentName(final String identifier, ComponentType componentType) throws Exception {
-
         if (componentType == ComponentType.FIELD) {
-            return newestBaseComponent().componentName() + "." + identifier;
+            return ParseUtil.newestBaseComponent(componentStack).componentName() + "." + identifier;
         } else {
-            return generateComponentName(identifier);
+            return ParseUtil.generateComponentName(identifier, componentStack);
         }
     }
 
@@ -381,10 +438,13 @@ private Component createComponent(ComponentType componentType, Node n) {
         return newCmp;
     }
 
-    private void pointParentsToGivenChild(Component childCmp) throws Exception {
-
+    /**
+     * Updates the list of children to include the given child component for parent components of the given
+     * component if they exist.
+     */
+    private void updateParentChildrenData(Component childCmp) throws Exception {
         if (childCmp.componentType() == ComponentType.FIELD) {
-            newestBaseComponent().insertChildComponent(childCmp.componentName());
+            ParseUtil.newestBaseComponent(componentStack).insertChildComponent(childCmp.componentName());
         } else {
             if (!componentStack.isEmpty()) {
                 final String parentName = childCmp.parentUniqueName();
@@ -397,64 +457,26 @@ private void pointParentsToGivenChild(Component childCmp) throws Exception {
         }
     }
 
-    /**
-     * Retrieves the most recently inserted base component on the stack.
-     */
-    private Component newestBaseComponent() throws Exception {
-
-        Component latestBaseCmp = null;
-        for (Component cmp : componentStack) {
-            if (cmp.componentType().isBaseComponent()) {
-                latestBaseCmp = cmp;
-            }
-        }
-
-        if (latestBaseCmp != null) {
-            return latestBaseCmp;
-        } else {
-            throw new Exception("There are no base components on the stack right now!");
-        }
-    }
-
-    /**
-     * Retrieves the most recently inserted base component on the stack.
-     */
-    private Component newestMethodComponent() throws Exception {
-
-        Component latestMethodCmp = null;
-        for (Component cmp : componentStack) {
-            if (cmp.componentType().isMethodComponent()) {
-                latestMethodCmp = cmp;
-            }
-        }
-
-        if (latestMethodCmp != null) {
-            return latestMethodCmp;
-        } else {
-            throw new Exception("There are no method components on the stack right now!");
-        }
-    }
-
-    static String declarationSnippet(Token token) {
+    private static String declarationSnippet(Token token) {
         switch (token) {
-        case TRUE:
-        case FALSE:
-            return "Boolean";
-        case STRING:
-        case STRING_TYPE:
-        case STRING_KEY:
-            return "String";
-        case NUMBER:
-            return "Number";
-        case ARRAYLIT:
-        case ARRAY_PATTERN:
-        case ARRAY_TYPE:
-            return "Array";
-        case OBJECTLIT:
-        case OBJECT_PATTERN:
-            return "Object";
-        default:
-            break;
+            case TRUE:
+            case FALSE:
+                return "Boolean";
+            case STRING:
+            case STRING_TYPE:
+            case STRING_KEY:
+                return "String";
+            case NUMBER:
+                return "Number";
+            case ARRAYLIT:
+            case ARRAY_PATTERN:
+            case ARRAY_TYPE:
+                return "Array";
+            case OBJECTLIT:
+            case OBJECT_PATTERN:
+                return "Object";
+            default:
+                break;
         }
         return null;
     }
@@ -467,15 +489,13 @@ private String resolveType(final String type) {
         if (currentImportsMap.containsKey(type)) {
             return currentImportsMap.get(type).replaceAll("/", ".");
         }
-
         final Iterator<?> it = currentImportsMap.entrySet().iterator();
         while (it.hasNext()) {
-            @SuppressWarnings("rawtypes")
             final Map.Entry pair = (Map.Entry) it.next();
             if (type.startsWith((String) pair.getKey())) {
                 return (((String) pair.getValue()).replaceAll("/", "."));
             }
         }
-        return currPackage + "." + type;
+        return type;
     }
 }
diff --git a/clarpse/src/main/java/com/clarity/listener/JavaTreeListener.java b/clarpse/src/main/java/com/clarity/listener/JavaTreeListener.java
index f4d45fc..7eb2b7e 100644
--- a/clarpse/src/main/java/com/clarity/listener/JavaTreeListener.java
+++ b/clarpse/src/main/java/com/clarity/listener/JavaTreeListener.java
@@ -1,14 +1,9 @@
 package com.clarity.listener;
 
-import com.clarity.ClarpseUtil;
 import com.clarity.compiler.RawFile;
-import com.clarity.invocation.AnnotationInvocation;
-import com.clarity.invocation.ComponentInvocation;
-import com.clarity.invocation.DocMention;
-import com.clarity.invocation.ThrownException;
-import com.clarity.invocation.TypeDeclaration;
-import com.clarity.invocation.TypeExtension;
-import com.clarity.invocation.TypeImplementation;
+import com.clarity.reference.SimpleTypeReference;
+import com.clarity.reference.TypeExtensionReference;
+import com.clarity.reference.TypeImplementationReference;
 import com.clarity.sourcemodel.Component;
 import com.clarity.sourcemodel.OOPSourceCodeModel;
 import com.clarity.sourcemodel.OOPSourceModelConstants;
@@ -26,13 +21,8 @@
 import com.github.javaparser.ast.body.MethodDeclaration;
 import com.github.javaparser.ast.body.Parameter;
 import com.github.javaparser.ast.body.VariableDeclarator;
-import com.github.javaparser.ast.expr.AnnotationExpr;
 import com.github.javaparser.ast.expr.ClassExpr;
 import com.github.javaparser.ast.expr.Expression;
-import com.github.javaparser.ast.expr.MarkerAnnotationExpr;
-import com.github.javaparser.ast.expr.MemberValuePair;
-import com.github.javaparser.ast.expr.NormalAnnotationExpr;
-import com.github.javaparser.ast.expr.SingleMemberAnnotationExpr;
 import com.github.javaparser.ast.expr.VariableDeclarationExpr;
 import com.github.javaparser.ast.stmt.CatchClause;
 import com.github.javaparser.ast.stmt.ForStmt;
@@ -53,15 +43,11 @@
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.nio.charset.StandardCharsets;
-import java.util.AbstractMap.SimpleEntry;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.EnumSet;
 import java.util.HashMap;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.Optional;
 import java.util.Stack;
 
 /**
@@ -109,67 +95,20 @@ public void populateModel() throws IOException {
 
     private void completeComponent() {
         if (!componentStack.isEmpty()) {
-
             final Component completedCmp = componentStack.pop();
-
             // update cyclomatic complexity if component is a method or class
             if (completedCmp.componentType().isMethodComponent()
                     && !ParseUtil.componentStackContainsInterface(componentStack)) {
                 completedCmp.setCyclo(currCyclomaticComplexity);
             } else if (completedCmp.componentType() == ComponentType.CLASS
                     || completedCmp.componentType() == ComponentType.ENUM) {
-                // class component complexity is a weighted average of its method children complexities.
-                int childCount = 0;
-                int complexityTotal = 0;
-                for (String childrenName : completedCmp.children()) {
-                    Optional<Component> child = srcModel.getComponent(childrenName);
-                    if (child.isPresent() && child.get().componentType().isMethodComponent()) {
-                        childCount += 1;
-                        complexityTotal += child.get().cyclo();
-                    }
-                }
-                if (childCount != 0 && complexityTotal != 0) {
-                    completedCmp.setCyclo(complexityTotal / childCount);
-                }
-            }
-
-            // include the processed component's invocations into its parent
-            // components
-            for (final Component parentCmp : componentStack) {
-
-                final Iterator<ComponentInvocation> invocationIterator = completedCmp.invocations().iterator();
-                while (invocationIterator.hasNext()) {
-
-                    // We do not want to bubble up type implementations and
-                    // extensions to the parent component because a child class for example
-                    // could extend its containing class component. Without this check
-                    // this would cause the parent class to have a type extension to itself
-                    // which will cause problems down the line.
-                    ComponentInvocation invocation = invocationIterator.next();
-                    if (!(invocation instanceof TypeExtension || invocation instanceof TypeImplementation)) {
-                        parentCmp.insertComponentInvocation(invocation);
-                    }
-                }
+                completedCmp.setCyclo(ParseUtil.calculateClassCyclo(completedCmp, srcModel));
             }
+            ParseUtil.copyRefsToParents(completedCmp, componentStack);
             srcModel.insertComponent(completedCmp);
         }
     }
 
-    /**
-     * Generates appropriate name for the component. Uses the current stack of
-     * parents components as prefixes to the name.
-     */
-    private String generateComponentName(final String identifier) {
-        String componentName;
-        if (!componentStack.isEmpty()) {
-            final Component completedCmp = componentStack.peek();
-            componentName = completedCmp.componentName() + "." + identifier;
-        } else {
-            componentName = identifier;
-        }
-        return componentName;
-    }
-
     /**
      * Creates a new component based on the given ParseRuleContext.
      */
@@ -177,15 +116,9 @@ private Component createComponent(Node node, ComponentType componentType) {
         final Component newCmp = new Component();
         newCmp.setPackageName(currentPkg);
         newCmp.setComponentType(componentType);
-        if (componentType.isVariableComponent()) {
-            newCmp.setLine(node.getRange().get().end.line);
-        } else {
-            newCmp.setLine(node.getBegin().get().line);
-        }
         if (node.getComment().isPresent()) {
             newCmp.setComment(node.getComment().toString());
         }
-        newCmp.setCode(String.join("\n", Arrays.copyOfRange(lines, node.getRange().get().begin.line - 1, node.getRange().get().end.line)));
         newCmp.setSourceFilePath(file.name());
         return newCmp;
     }
@@ -249,33 +182,26 @@ public final void visit(ClassOrInterfaceDeclaration ctx, Object arg) {
             }
 
             cmp.setAccessModifiers(resolveJavaParserModifiers(ctx.getModifiers()));
-            cmp.setComponentName(generateComponentName(ctx.getNameAsString()));
+            cmp.setComponentName(ParseUtil.generateComponentName(ctx.getNameAsString(), componentStack));
             cmp.setName(ctx.getNameAsString());
             cmp.setImports(currentImports);
             if (ctx.getComment().isPresent()) {
-                for (String docMention : ClarpseUtil.extractDocTypeMentions(ctx.getComment().get().toString())) {
-                    cmp.insertComponentInvocation(new DocMention(resolveType(docMention)));
-                }
                 cmp.setComment(ctx.getComment().get().toString());
             }
             ParseUtil.pointParentsToGivenChild(cmp, componentStack);
 
             if (ctx.getExtendedTypes() != null) {
                 for (final ClassOrInterfaceType outerType : ctx.getExtendedTypes()) {
-                    cmp.insertComponentInvocation(new TypeExtension(resolveType(outerType.getNameAsString())));
+                    cmp.insertComponentRef(new TypeExtensionReference(resolveType(outerType.getNameAsString())));
                 }
             }
 
             if (ctx.getImplementedTypes() != null) {
                 for (final ClassOrInterfaceType outerType : ctx.getImplementedTypes()) {
-                    cmp.insertComponentInvocation(new TypeImplementation(resolveType(outerType.getNameAsString())));
+                    cmp.insertComponentRef(new TypeImplementationReference(resolveType(outerType.getNameAsString())));
                 }
             }
 
-            for (final AnnotationExpr annot : ctx.getAnnotations()) {
-                populateAnnotation(cmp, annot);
-            }
-
             componentStack.push(cmp);
             for (final Node node : ctx.getChildNodes()) {
                 if (node instanceof FieldDeclaration || node instanceof Statement || node instanceof Expression
@@ -314,7 +240,7 @@ public final void visit(EnumDeclaration ctx, Object arg) {
 
         if (!ParseUtil.componentStackContainsMethod(componentStack)) {
             final Component enumCmp = createComponent(ctx, OOPSourceModelConstants.ComponentType.ENUM);
-            enumCmp.setComponentName(generateComponentName(ctx.getNameAsString()));
+            enumCmp.setComponentName(ParseUtil.generateComponentName(ctx.getNameAsString(), componentStack));
             enumCmp.setImports(currentImports);
             enumCmp.setName(ctx.getNameAsString());
             enumCmp.setAccessModifiers(resolveJavaParserModifiers(ctx.getModifiers()));
@@ -322,9 +248,6 @@ public final void visit(EnumDeclaration ctx, Object arg) {
             if (ctx.getComment().isPresent()) {
                 enumCmp.setComment(ctx.getComment().get().toString());
             }
-            for (final AnnotationExpr annot : ctx.getAnnotations()) {
-                populateAnnotation(enumCmp, annot);
-            }
             componentStack.push(enumCmp);
             for (final Node node : ctx.getChildNodes()) {
                 if (node instanceof FieldDeclaration || node instanceof MethodDeclaration
@@ -355,11 +278,8 @@ public final void visit(final EnumConstantDeclaration ctx, Object arg) {
 
         final Component enumConstCmp = createComponent(ctx, OOPSourceModelConstants.ComponentType.ENUM_CONSTANT);
         enumConstCmp.setName(ctx.getNameAsString());
-        enumConstCmp.setComponentName(generateComponentName(ctx.getNameAsString()));
+        enumConstCmp.setComponentName(ParseUtil.generateComponentName(ctx.getNameAsString(), componentStack));
         ParseUtil.pointParentsToGivenChild(enumConstCmp, componentStack);
-        for (final AnnotationExpr annot : ctx.getAnnotations()) {
-            populateAnnotation(enumConstCmp, annot);
-        }
         if (ctx.getComment().isPresent()) {
             enumConstCmp.setComment(ctx.getComment().get().toString());
         }
@@ -386,13 +306,10 @@ public final void visit(final MethodDeclaration ctx, Object arg) {
             if (ctx.getComment().isPresent()) {
                 currMethodCmp.setComment(ctx.getComment().get().toString());
             }
-            for (final AnnotationExpr annot : ctx.getAnnotations()) {
-                populateAnnotation(currMethodCmp, annot);
-            }
 
             for (final ReferenceType stmt : ctx.getThrownExceptions()) {
-                currMethodCmp.insertComponentInvocation(
-                        new ThrownException(resolveType(stmt.getMetaModel().getTypeName())));
+                currMethodCmp.insertComponentRef(
+                        new SimpleTypeReference(resolveType(stmt.getMetaModel().getTypeName())));
             }
             final String methodSignature = currMethodCmp.name() + formalParametersString;
             String codeFragment = currMethodCmp.name() + formalParametersString;
@@ -400,7 +317,7 @@ public final void visit(final MethodDeclaration ctx, Object arg) {
                 codeFragment += " : " + ctx.getType().toString();
             }
             currMethodCmp.setCodeFragment(codeFragment);
-            currMethodCmp.setComponentName(generateComponentName(methodSignature));
+            currMethodCmp.setComponentName(ParseUtil.generateComponentName(methodSignature, componentStack));
             ParseUtil.pointParentsToGivenChild(currMethodCmp, componentStack);
             componentStack.push(currMethodCmp);
             if (ctx.getParameters() != null) {
@@ -409,13 +326,10 @@ public final void visit(final MethodDeclaration ctx, Object arg) {
                             OOPSourceModelConstants.ComponentType.METHOD_PARAMETER_COMPONENT);
                     methodParamCmp.setName(param.getNameAsString());
                     methodParamCmp.setCodeFragment(param.getType().asString());
-                    for (final AnnotationExpr annot : param.getAnnotations()) {
-                        populateAnnotation(methodParamCmp, annot);
-                    }
-                    methodParamCmp.setComponentName(generateComponentName(param.getNameAsString()));
+                    methodParamCmp.setComponentName(ParseUtil.generateComponentName(param.getNameAsString(), componentStack));
                     methodParamCmp.setAccessModifiers(resolveJavaParserModifiers(param.getModifiers()));
-                    methodParamCmp.insertComponentInvocation(
-                            new TypeDeclaration(resolveType(param.getType().asString())));
+                    methodParamCmp.insertComponentRef(
+                            new SimpleTypeReference(resolveType(param.getType().asString())));
                     ParseUtil.pointParentsToGivenChild(methodParamCmp, componentStack);
                     componentStack.push(methodParamCmp);
                     completeComponent();
@@ -462,19 +376,15 @@ public final void visit(final ConstructorDeclaration ctx, Object arg) {
             }
             formalParametersString += ")";
 
-            for (final AnnotationExpr annot : ctx.getAnnotations()) {
-                populateAnnotation(currMethodCmp, annot);
-            }
-
             for (final ReferenceType stmt : ctx.getThrownExceptions()) {
-                currMethodCmp.insertComponentInvocation(
-                        new ThrownException(resolveType(stmt.getMetaModel().getTypeName())));
+                currMethodCmp.insertComponentRef(
+                        new SimpleTypeReference(resolveType(stmt.getMetaModel().getTypeName())));
             }
 
             final String methodSignature = currMethodCmp.name() + formalParametersString;
             String codeFragment = currMethodCmp.name() + formalParametersString;
             currMethodCmp.setCodeFragment(codeFragment);
-            currMethodCmp.setComponentName(generateComponentName(methodSignature));
+            currMethodCmp.setComponentName(ParseUtil.generateComponentName(methodSignature, componentStack));
             ParseUtil.pointParentsToGivenChild(currMethodCmp, componentStack);
             componentStack.push(currMethodCmp);
             if (ctx.getParameters() != null) {
@@ -483,13 +393,10 @@ public final void visit(final ConstructorDeclaration ctx, Object arg) {
                             OOPSourceModelConstants.ComponentType.CONSTRUCTOR_PARAMETER_COMPONENT);
                     methodParamCmp.setCodeFragment(param.getType().asString());
                     methodParamCmp.setName(param.getNameAsString());
-                    for (final AnnotationExpr annot : param.getAnnotations()) {
-                        populateAnnotation(methodParamCmp, annot);
-                    }
-                    methodParamCmp.setComponentName(generateComponentName(param.getNameAsString()));
+                    methodParamCmp.setComponentName(ParseUtil.generateComponentName(param.getNameAsString(), componentStack));
                     methodParamCmp.setAccessModifiers(resolveJavaParserModifiers(param.getModifiers()));
-                    methodParamCmp.insertComponentInvocation(
-                            new TypeDeclaration(resolveType(param.getType().asString())));
+                    methodParamCmp.insertComponentRef(
+                            new SimpleTypeReference(resolveType(param.getType().asString())));
                     ParseUtil.pointParentsToGivenChild(methodParamCmp, componentStack);
                     componentStack.push(methodParamCmp);
                     completeComponent();
@@ -560,16 +467,13 @@ public final void visit(SwitchStmt ctx, Object arg) {
     public final void visit(VariableDeclarationExpr ctx, Object arg) {
         try {
             final Component cmp = createComponent(ctx, OOPSourceModelConstants.ComponentType.LOCAL);
-            for (final AnnotationExpr annot : ctx.getAnnotations()) {
-                populateAnnotation(cmp, annot);
-            }
 
             cmp.setAccessModifiers(resolveJavaParserModifiers(ctx.getModifiers()));
             final List<Component> vars = new ArrayList<>();
             for (final VariableDeclarator copy : ctx.getVariables()) {
                 final Component tmp = new Component(cmp);
                 tmp.setName(copy.getNameAsString());
-                tmp.setComponentName(generateComponentName(copy.getNameAsString()));
+                tmp.setComponentName(ParseUtil.generateComponentName(copy.getNameAsString(), componentStack));
                 ParseUtil.pointParentsToGivenChild(tmp, componentStack);
                 vars.add(tmp);
             }
@@ -604,9 +508,6 @@ public final void visit(FieldDeclaration ctx, Object arg) {
                 } else {
                     cmp = createComponent(ctx, OOPSourceModelConstants.ComponentType.FIELD);
                 }
-                for (final AnnotationExpr annot : ctx.getAnnotations()) {
-                    populateAnnotation(cmp, annot);
-                }
                 if (ctx.getComment().isPresent()) {
                     cmp.setComment(ctx.getComment().get().toString());
                 }
@@ -616,7 +517,7 @@ public final void visit(FieldDeclaration ctx, Object arg) {
                     final Component tmp = new Component(cmp);
                     tmp.setName(copy.getNameAsString());
                     tmp.setCodeFragment(tmp.name() + " : " + copy.getType().toString());
-                    tmp.setComponentName(generateComponentName(copy.getNameAsString()));
+                    tmp.setComponentName(ParseUtil.generateComponentName(copy.getNameAsString(), componentStack));
                     ParseUtil.pointParentsToGivenChild(tmp, componentStack);
                     vars.add(tmp);
                 }
@@ -636,44 +537,12 @@ public final void visit(FieldDeclaration ctx, Object arg) {
         }
     }
 
-    private void populateAnnotation(Component cmp, AnnotationExpr annotation) {
-
-        if (annotation != null) {
-            String typeName = "";
-            final HashMap<String, String> elementValuePairs = new HashMap<>();
-            if (annotation instanceof NormalAnnotationExpr) {
-                final NormalAnnotationExpr expr = (NormalAnnotationExpr) annotation;
-                typeName = resolveAnnotationType(expr.asNormalAnnotationExpr().getNameAsString());
-                for (final MemberValuePair evctx : expr.getPairs()) {
-                    elementValuePairs.put(evctx.getNameAsString(), evctx.getValue().toString());
-                }
-            } else if (annotation instanceof MarkerAnnotationExpr) {
-                final MarkerAnnotationExpr expr = (MarkerAnnotationExpr) annotation;
-                typeName = resolveAnnotationType(expr.asMarkerAnnotationExpr().getChildNodes().get(0).toString());
-            } else if (annotation instanceof SingleMemberAnnotationExpr) {
-                final SingleMemberAnnotationExpr expr = (SingleMemberAnnotationExpr) annotation;
-                typeName = resolveAnnotationType(expr.asSingleMemberAnnotationExpr().getNameAsString());
-                elementValuePairs.put("", expr.getMemberValue().toString());
-            }
-            cmp.insertComponentInvocation(new AnnotationInvocation(typeName,
-                    new SimpleEntry<>(typeName, elementValuePairs)));
-        }
-    }
-
-    private String resolveAnnotationType(String annotationType) {
-        if (OOPSourceModelConstants.getJavaPredefinedAnnotations().containsKey(annotationType)) {
-            return annotationType;
-        } else {
-            return resolveType(annotationType);
-        }
-    }
-
     @Override
     public final void visit(ClassOrInterfaceType ctx, Object arg) {
 
         if (!componentStack.isEmpty()) {
             final Component currCmp = componentStack.peek();
-            currCmp.insertComponentInvocation(new TypeDeclaration(resolveType(ctx.asClassOrInterfaceType().getNameAsString())));
+            currCmp.insertComponentRef(new SimpleTypeReference(resolveType(ctx.asClassOrInterfaceType().getNameAsString())));
             List<Type> typeArguments = new ArrayList<>();
             if (ctx.getTypeArguments().isPresent()) {
                 typeArguments.addAll(ctx.getTypeArguments().get());
@@ -682,10 +551,10 @@ public final void visit(ClassOrInterfaceType ctx, Object arg) {
                         if (((ClassOrInterfaceType) typeArg).getTypeArguments().isPresent()) {
                             visit(((ClassOrInterfaceType) typeArg), arg);
                         } else {
-                            currCmp.insertComponentInvocation(new TypeDeclaration(resolveType(typeArg.asClassOrInterfaceType().getNameAsString())));
+                            currCmp.insertComponentRef(new SimpleTypeReference(resolveType(typeArg.asClassOrInterfaceType().getNameAsString())));
                         }
                     } else {
-                        currCmp.insertComponentInvocation(new TypeDeclaration(resolveType(typeArg.asString())));
+                        currCmp.insertComponentRef(new SimpleTypeReference(resolveType(typeArg.asString())));
                     }
                 }
             }
@@ -696,7 +565,7 @@ public final void visit(ClassOrInterfaceType ctx, Object arg) {
     public final void visit(PrimitiveType ctx, Object arg) {
         if (!componentStack.isEmpty()) {
             final Component currCmp = componentStack.pop();
-            currCmp.insertComponentInvocation(new TypeDeclaration(resolveType(ctx.asString())));
+            currCmp.insertComponentRef(new SimpleTypeReference(resolveType(ctx.asString())));
             componentStack.push(currCmp);
         }
     }
diff --git a/clarpse/src/main/java/com/clarity/listener/ParseUtil.java b/clarpse/src/main/java/com/clarity/listener/ParseUtil.java
index db60664..cb9af86 100644
--- a/clarpse/src/main/java/com/clarity/listener/ParseUtil.java
+++ b/clarpse/src/main/java/com/clarity/listener/ParseUtil.java
@@ -1,19 +1,25 @@
 package com.clarity.listener;
 
+import com.clarity.reference.ComponentReference;
+import com.clarity.reference.TypeExtensionReference;
+import com.clarity.reference.TypeImplementationReference;
 import com.clarity.sourcemodel.Component;
+import com.clarity.sourcemodel.OOPSourceCodeModel;
 import com.clarity.sourcemodel.OOPSourceModelConstants;
 import org.antlr.v4.runtime.ParserRuleContext;
 import org.antlr.v4.runtime.misc.Interval;
 
+import java.util.Iterator;
 import java.util.List;
+import java.util.Optional;
 import java.util.Stack;
 
 /**
  * Contains utility operations shared amongst Clarpse Compilers.
  */
-public class ParseUtil {
+class ParseUtil {
 
-    public static String goLangComments(int componentStartLine, List<String> sourceFile) {
+    static String goLangComments(int componentStartLine, List<String> sourceFile) {
         String comment = "";
         int i = componentStartLine - 2;
         String currLine = sourceFile.get(i).trim();
@@ -28,11 +34,101 @@ public static String goLangComments(int componentStartLine, List<String> sourceF
         return comment.trim();
     }
 
-    public static String originalText(ParserRuleContext ctx) {
+    static void copyRefsToParents(Component originalCompoennt, Stack<Component> componentStack) {
+        // bubble up the completing component's invocations to it's parent components
+        // that are currently on the stack
+        for (final Component parentCmp : componentStack) {
+            final Iterator<ComponentReference> invocationIterator = originalCompoennt.references().iterator();
+            while (invocationIterator.hasNext()) {
+                ComponentReference invocation = invocationIterator.next();
+                // We do not want to bubble up type implementations and
+                // extensions to the parent component because a child class for example
+                // could extend its containing class component. Without this check
+                // this would cause the parent class to have a type extension to itself
+                // which will cause problems down the line.
+                if (!(originalCompoennt.componentType() == OOPSourceModelConstants.ComponentType.FIELD
+                        && parentCmp.componentType() == OOPSourceModelConstants.ComponentType.CONSTRUCTOR)
+                        && !(invocation instanceof TypeExtensionReference || invocation instanceof TypeImplementationReference)) {
+                    parentCmp.insertComponentRef(invocation);
+                }
+            }
+        }
+    }
+
+    /**
+     * Retrieves the most recently inserted base component on the stack.
+     */
+    static Component newestBaseComponent(Stack<Component> componentStack) throws Exception {
+        Component latestBaseCmp = null;
+        for (Component cmp : componentStack) {
+            if (cmp.componentType().isBaseComponent()) {
+                latestBaseCmp = cmp;
+            }
+        }
+        if (latestBaseCmp != null) {
+            return latestBaseCmp;
+        } else {
+            throw new Exception("There are no base components on the stack right now!");
+        }
+    }
+
+    /**
+     * Retrieves the most recently inserted base component on the stack.
+     */
+    static Component newestMethodComponent(Stack<Component> componentStack) throws Exception {
+        Component latestMethodCmp = null;
+        for (Component cmp : componentStack) {
+            if (cmp.componentType().isMethodComponent()) {
+                latestMethodCmp = cmp;
+            }
+        }
+
+        if (latestMethodCmp != null) {
+            return latestMethodCmp;
+        } else {
+            throw new Exception("There are no method components on the stack right now!");
+        }
+    }
+
+    /**
+     * Generates appropriate name for the component. Uses the current stack of
+     * parents components as prefixes to the name.
+     */
+    static String generateComponentName(final String identifier, Stack<Component> componentStack) {
+        String componentName = "";
+
+        if (!componentStack.isEmpty()) {
+            final Component completedCmp = componentStack.peek();
+            componentName = completedCmp.componentName() + "." + identifier;
+        } else {
+            componentName = identifier;
+        }
+        return componentName;
+    }
+
+    // class component cyclo complexity is a weighted average of its method children complexities.
+    static int calculateClassCyclo(Component component, OOPSourceCodeModel srcModel) {
+        int childCount = 0;
+        int complexityTotal = 0;
+        for (String childrenName : component.children()) {
+            Optional<Component> child = srcModel.getComponent(childrenName);
+            if (child.isPresent() && child.get().componentType().isMethodComponent()) {
+                childCount += 1;
+                complexityTotal += child.get().cyclo();
+            }
+        }
+        if (childCount != 0 && complexityTotal != 0) {
+            return (complexityTotal / childCount);
+        } else {
+            return 0;
+        }
+    }
+
+    static String originalText(ParserRuleContext ctx) {
         return ctx.getStart().getInputStream().getText(Interval.of(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex()));
     }
 
-    public static void pointParentsToGivenChild(Component childCmp, Stack<? extends Component> componentStack) {
+    static void pointParentsToGivenChild(Component childCmp, Stack<? extends Component> componentStack) {
 
         if (!componentStack.isEmpty()) {
             final String parentName = childCmp.parentUniqueName();
@@ -45,12 +141,12 @@ public static void pointParentsToGivenChild(Component childCmp, Stack<? extends
     }
 
 
-    public static boolean componentStackContainsMethod(Stack<? extends Component> componentStack) {
+    static boolean componentStackContainsMethod(Stack<? extends Component> componentStack) {
         return componentStackContainsComponentType(componentStack, OOPSourceModelConstants.ComponentType.METHOD,
                 OOPSourceModelConstants.ComponentType.CONSTRUCTOR);
     }
 
-    public static boolean componentStackContainsInterface(Stack<? extends Component> componentStack) {
+    static boolean componentStackContainsInterface(Stack<? extends Component> componentStack) {
         return componentStackContainsComponentType(componentStack, OOPSourceModelConstants.ComponentType.INTERFACE);
     }
 
diff --git a/clarpse/src/main/java/com/clarity/reference/ComponentReference.java b/clarpse/src/main/java/com/clarity/reference/ComponentReference.java
new file mode 100644
index 0000000..f96a6cc
--- /dev/null
+++ b/clarpse/src/main/java/com/clarity/reference/ComponentReference.java
@@ -0,0 +1,50 @@
+package com.clarity.reference;
+
+import com.fasterxml.jackson.annotation.JsonSubTypes;
+import com.fasterxml.jackson.annotation.JsonSubTypes.Type;
+import com.fasterxml.jackson.annotation.JsonTypeInfo;
+
+import java.io.Serializable;
+
+/**
+ * Represents a reference to another component in the code base.
+ */
+@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "type")
+@JsonSubTypes({
+        @Type(value = SimpleTypeReference.class, name = "declaration"),
+        @Type(value = TypeExtensionReference.class, name = "extension"),
+        @Type(value = TypeImplementationReference.class, name = "implementation")})
+public abstract class ComponentReference implements Serializable, Cloneable {
+
+    private static final long serialVersionUID = -242718695900611890L;
+    private String invokedComponent = "";
+
+    public ComponentReference(final String invocationComponentName, final int lineNum) {
+        invokedComponent = invocationComponentName;
+    }
+
+    public ComponentReference(final ComponentReference invocation) {
+        invokedComponent = invocation.invokedComponent();
+    }
+
+    public ComponentReference() {
+    }
+
+    @Override
+    public String toString() {
+        return this.getClass().getSimpleName() + ":" + this.invokedComponent;
+    }
+
+    public ComponentReference(String invokedComponent2) {
+        invokedComponent = invokedComponent2;
+    }
+
+    public String invokedComponent() {
+        return invokedComponent;
+    }
+
+    @Override
+    public Object clone() throws CloneNotSupportedException {
+        return super.clone();
+    }
+}
diff --git a/clarpse/src/main/java/com/clarity/reference/SimpleTypeReference.java b/clarpse/src/main/java/com/clarity/reference/SimpleTypeReference.java
new file mode 100644
index 0000000..cc3b68c
--- /dev/null
+++ b/clarpse/src/main/java/com/clarity/reference/SimpleTypeReference.java
@@ -0,0 +1,22 @@
+package com.clarity.reference;
+
+import java.io.Serializable;
+
+public class SimpleTypeReference extends ComponentReference implements Serializable {
+
+    private static final long serialVersionUID = 7304258760520469246L;
+    public final String type = "declaration";
+
+    public SimpleTypeReference(final String invocationComponentName) {
+        super(invocationComponentName);
+    }
+
+    public SimpleTypeReference() {
+        super();
+    }
+
+    @Override
+    public Object clone() {
+        return new SimpleTypeReference(invokedComponent());
+    }
+}
diff --git a/clarpse/src/main/java/com/clarity/reference/TypeExtensionReference.java b/clarpse/src/main/java/com/clarity/reference/TypeExtensionReference.java
new file mode 100644
index 0000000..a76c52c
--- /dev/null
+++ b/clarpse/src/main/java/com/clarity/reference/TypeExtensionReference.java
@@ -0,0 +1,22 @@
+package com.clarity.reference;
+
+import java.io.Serializable;
+
+public final class TypeExtensionReference extends ComponentReference implements Serializable {
+
+    private static final long serialVersionUID = 6641497827060470449L;
+    public final String type = "extension";
+
+    public TypeExtensionReference() {
+        super();
+    }
+
+    public TypeExtensionReference(String invokedComponent) {
+        super(invokedComponent);
+    }
+
+    @Override
+    public Object clone() {
+        return new TypeExtensionReference(invokedComponent());
+    }
+}
diff --git a/clarpse/src/main/java/com/clarity/reference/TypeImplementationReference.java b/clarpse/src/main/java/com/clarity/reference/TypeImplementationReference.java
new file mode 100644
index 0000000..9f1e0f9
--- /dev/null
+++ b/clarpse/src/main/java/com/clarity/reference/TypeImplementationReference.java
@@ -0,0 +1,23 @@
+package com.clarity.reference;
+
+import java.io.Serializable;
+
+public class TypeImplementationReference extends ComponentReference implements Serializable {
+
+    private static final long serialVersionUID = 7807962152246261233L;
+    public final String type = "implementation";
+
+    public TypeImplementationReference() {
+        super();
+    }
+
+    public TypeImplementationReference(String invokedComponent) {
+        super(invokedComponent);
+    }
+
+    @Override
+    public Object clone() {
+        return new TypeImplementationReference(invokedComponent());
+    }
+
+}
diff --git a/clarpse/src/main/java/com/clarity/sourcemodel/Component.java b/clarpse/src/main/java/com/clarity/sourcemodel/Component.java
index 0f9892c..399f9c6 100644
--- a/clarpse/src/main/java/com/clarity/sourcemodel/Component.java
+++ b/clarpse/src/main/java/com/clarity/sourcemodel/Component.java
@@ -1,7 +1,7 @@
 package com.clarity.sourcemodel;
 
-import com.clarity.invocation.ComponentInvocation;
-import com.clarity.sourcemodel.OOPSourceModelConstants.ComponentInvocations;
+import com.clarity.reference.ComponentReference;
+import com.clarity.sourcemodel.OOPSourceModelConstants.TypeReferences;
 import com.clarity.sourcemodel.OOPSourceModelConstants.ComponentType;
 import com.fasterxml.jackson.annotation.JsonInclude;
 import com.fasterxml.jackson.annotation.JsonInclude.Include;
@@ -29,13 +29,11 @@
      */
     private String value;
     private String packageName;
-    private String code;
     private int cyclo;
     /**
      * Short name.
      */
     private String name;
-    private int line;
     private Component parent;
     private String comment = "";
     /**
@@ -48,7 +46,7 @@
     private Set<String> modifiers = new LinkedHashSet<String>();
     private ComponentType type;
     @JsonInclude(Include.NON_EMPTY)
-    private Set<ComponentInvocation> invocations = new LinkedHashSet<ComponentInvocation>();
+    private Set<ComponentReference> references = new LinkedHashSet<ComponentReference>();
     /**
      * Formed by chaining parent components' names separated by a period.
      * <p>
@@ -73,11 +71,9 @@ public Component(final Component component) throws Exception {
         parent = component.parent();
         sourceFile = component.sourceFile();
         comment = component.comment();
-        line = component.line();
-        code = component.code();
         children.addAll(component.children);
-        for (ComponentInvocation inv : component.invocations()) {
-            invocations.add((ComponentInvocation) inv.clone());
+        for (ComponentReference ref : component.references()) {
+            references.add((ComponentReference) ref.clone());
         }
     }
 
@@ -117,15 +113,6 @@ public String name() {
         return name;
     }
 
-    public String code() {
-        return code;
-    }
-
-    public void setCode(String code) {
-        this.code = code;
-    }
-
-
     public void insertChildComponent(final String childComponentName) {
         if (!children.contains(childComponentName)) {
             children.add(childComponentName);
@@ -140,25 +127,17 @@ public String codeFragment() {
         return codeFragment;
     }
 
-    public Set<ComponentInvocation> invocations() {
-        return invocations;
+    public Set<ComponentReference> references() {
+        return references;
     }
 
-    public void insertComponentInvocation(final ComponentInvocation ref) {
-        for (final ComponentInvocation invocation : invocations) {
-            if (invocation.invokedComponent().equals(ref.invokedComponent()) && invocation.getClass().isInstance(ref)) {
+    public void insertComponentRef(final ComponentReference ref) {
+        for (final ComponentReference reference : references) {
+            if (reference.invokedComponent().equals(ref.invokedComponent()) && reference.getClass().isInstance(ref)) {
                 return;
             }
         }
-        invocations.add(ref);
-    }
-
-    public int line() {
-        return line;
-    }
-
-    public void setLine(int line) {
-        this.line = line;
+        references.add(ref);
     }
 
     public List<String> imports() {
@@ -173,11 +152,11 @@ public void setCodeFragment(final String componentDeclarationTypeFragment) {
         codeFragment = componentDeclarationTypeFragment;
     }
 
-    public void setExternalTypeReferences(final Set<ComponentInvocation> externalReferences) {
-        invocations = externalReferences;
+    public void setExternalTypeReferences(final Set<ComponentReference> externalReferences) {
+        references = externalReferences;
     }
 
-    public void setImports(final ArrayList<String> currentImports) {
+    public void setImports(final List<String> currentImports) {
         imports = currentImports;
     }
 
@@ -247,24 +226,20 @@ public String parentUniqueName() {
         }
     }
 
-    public void insertComponentInvocations(final ArrayList<ComponentInvocation> externalClassTypeReferenceList) {
-        for (final ComponentInvocation typeRef : externalClassTypeReferenceList) {
-            insertComponentInvocation(typeRef);
+    public void insertComponentReferences(final List<ComponentReference> externalClassTypeReferenceList) {
+        for (final ComponentReference typeRef : externalClassTypeReferenceList) {
+            insertComponentRef(typeRef);
         }
     }
 
-    public List<ComponentInvocation> componentInvocations(final ComponentInvocations type) {
-        final List<ComponentInvocation> tmpInvocations = new ArrayList<ComponentInvocation>();
-        for (final ComponentInvocation compInvocation : invocations) {
-            if (type.getMatchingClass().isAssignableFrom(compInvocation.getClass())) {
-                tmpInvocations.add(compInvocation);
+    public List<ComponentReference> references(final TypeReferences type) {
+        final List<ComponentReference> tmpReferences = new ArrayList<ComponentReference>();
+        for (final ComponentReference compReference : references) {
+            if (type.getMatchingClass().isAssignableFrom(compReference.getClass())) {
+                tmpReferences.add(compReference);
             }
         }
-        return tmpInvocations;
-    }
-
-    public Set<ComponentInvocation> componentInvocations() {
-        return invocations;
+        return tmpReferences;
     }
 
     public void setName(final String name) {
diff --git a/clarpse/src/main/java/com/clarity/sourcemodel/OOPSourceModelConstants.java b/clarpse/src/main/java/com/clarity/sourcemodel/OOPSourceModelConstants.java
index e7107a5..02b1552 100644
--- a/clarpse/src/main/java/com/clarity/sourcemodel/OOPSourceModelConstants.java
+++ b/clarpse/src/main/java/com/clarity/sourcemodel/OOPSourceModelConstants.java
@@ -4,14 +4,10 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import com.clarity.invocation.AnnotationInvocation;
-import com.clarity.invocation.ComponentInvocation;
-import com.clarity.invocation.DocMention;
-import com.clarity.invocation.ThrownException;
-import com.clarity.invocation.TypeDeclaration;
-import com.clarity.invocation.TypeExtension;
-import com.clarity.invocation.TypeImplementation;
-import com.clarity.invocation.TypeInstantiation;
+import com.clarity.reference.ComponentReference;
+import com.clarity.reference.SimpleTypeReference;
+import com.clarity.reference.TypeExtensionReference;
+import com.clarity.reference.TypeImplementationReference;
 
 public final class OOPSourceModelConstants {
 
@@ -231,20 +227,19 @@ public String getUMLClassDigramSymbol() {
         }
     }
 
-    public enum ComponentInvocations {
+    public enum TypeReferences {
 
-        DOC_MENTION(DocMention.class), ANNOTATION(AnnotationInvocation.class), EXCEPTION(
-                ThrownException.class), DECLARATION(TypeDeclaration.class), INSTANTIATION(
-                        TypeInstantiation.class), EXTENSION(
-                                TypeExtension.class), IMPLEMENTATION(TypeImplementation.class);
+        SIMPLE(SimpleTypeReference.class),
+        EXTENSION(TypeExtensionReference.class),
+        IMPLEMENTATION(TypeImplementationReference.class);
 
-        public Class<? extends ComponentInvocation> getMatchingClass() {
+        public Class<? extends ComponentReference> getMatchingClass() {
             return matchingClass;
         }
 
-        private Class<? extends ComponentInvocation> matchingClass = null;
+        private Class<? extends ComponentReference> matchingClass = null;
 
-        ComponentInvocations(final Class<? extends ComponentInvocation> matchingClass) {
+        TypeReferences(final Class<? extends ComponentReference> matchingClass) {
             this.matchingClass = matchingClass;
         }
     }
diff --git a/clarpse/src/test/java/com/clarity/test/TrimmedStringTest.java b/clarpse/src/test/java/com/clarity/test/TrimmedStringTest.java
new file mode 100644
index 0000000..bdba6a1
--- /dev/null
+++ b/clarpse/src/test/java/com/clarity/test/TrimmedStringTest.java
@@ -0,0 +1,19 @@
+package com.clarity.test;
+
+import com.clarity.TrimmedString;
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+
+public class TrimmedStringTest {
+
+    @Test
+    public void SimpleTrimmedStringTest() throws Exception {
+        assertTrue(new TrimmedString("//test//", "/").value().equalsIgnoreCase("test"));
+    }
+
+    @Test
+    public void SpaceTrimmedStringTest() throws Exception {
+        assertTrue(new TrimmedString(" test  ", " ").value().equalsIgnoreCase("test"));
+    }
+}
diff --git a/clarpse/src/test/java/com/clarity/test/UtilsTest.java b/clarpse/src/test/java/com/clarity/test/UtilsTest.java
index 9e30dc5..bb5c339 100644
--- a/clarpse/src/test/java/com/clarity/test/UtilsTest.java
+++ b/clarpse/src/test/java/com/clarity/test/UtilsTest.java
@@ -1,7 +1,7 @@
 package com.clarity.test;
 
 import com.clarity.ResolvedRelativePath;
-import com.clarity.invocation.TypeDeclaration;
+import com.clarity.reference.SimpleTypeReference;
 import com.clarity.sourcemodel.Component;
 import com.clarity.sourcemodel.OOPSourceModelConstants;
 import org.junit.Test;
@@ -54,8 +54,8 @@ public void cloneComponentInvocationCopyTest() throws Exception {
         aField.setComponentType(OOPSourceModelConstants.ComponentType.FIELD);
         aField.setName("aField");
         Component bField = new Component(aField);
-        bField.insertComponentInvocation(new TypeDeclaration("com.test.classB"));
-        assert (aField.invocations().size() == 0);
+        bField.insertComponentRef(new SimpleTypeReference("com.test.classB"));
+        assert (aField.references().size() == 0);
     }
 
     @Test
@@ -65,8 +65,8 @@ public void cloneComponentInvocationTest() throws Exception {
         aField.setComponentName("classA.aField");
         aField.setComponentType(OOPSourceModelConstants.ComponentType.FIELD);
         aField.setName("aField");
-        aField.insertComponentInvocation(new TypeDeclaration("com.test.classB"));
+        aField.insertComponentRef(new SimpleTypeReference("com.test.classB"));
         Component bField = new Component(aField);
-        assert (bField.invocations().size() == 1);
+        assert (bField.references().size() == 1);
     }
 }
diff --git a/clarpse/src/test/java/com/clarity/test/go/AccessModifiersTest.java b/clarpse/src/test/java/com/clarity/test/go/AccessModifiersTest.java
new file mode 100644
index 0000000..eab8eb1
--- /dev/null
+++ b/clarpse/src/test/java/com/clarity/test/go/AccessModifiersTest.java
@@ -0,0 +1,77 @@
+package com.clarity.test.go;
+
+import com.clarity.compiler.ClarpseProject;
+import com.clarity.compiler.Lang;
+import com.clarity.compiler.RawFile;
+import com.clarity.compiler.SourceFiles;
+import com.clarity.sourcemodel.OOPSourceCodeModel;
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+
+public class AccessModifiersTest {
+
+    @Test
+    public void testParseGoStructPrivateVisibility() throws Exception {
+
+        final String code = "package main\n import \"fmt\"\n /*test*/ type person struct {} type Teacher struct{}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person").get().modifiers().contains("private"));
+    }
+
+    @Test
+    public void testGoStructFieldVarPrivateVisibility() throws Exception {
+        final String code = "package main\nimport \"test/math\"\ntype person struct {mathObj math.Person}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person.mathObj").get().modifiers().contains("private"));
+    }
+
+    @Test
+    public void testParseGoStructPublicVisibility() throws Exception {
+
+        final String code = "package main\n import \"fmt\"\n /*test*/ \n type person struct {} type Teacher struct{}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.Teacher").get().modifiers().contains("public"));
+    }
+
+    @Test
+    public void testGoStructFieldVarPublicVisibility() throws Exception {
+        final String code = "package main\nimport \"test/math\"\ntype person struct {MathObj math.Person}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person.MathObj").get().modifiers().contains("public"));
+    }
+
+    @Test
+    public void testParseGoInterfacePublicVisibility() throws Exception {
+
+        final String code = "package main\n import \"fmt\"\n /*test*/ type Person interface {} type Teacher struct{}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.Person").get().modifiers().contains("public"));
+    }
+
+    @Test
+    public void testParseGoInterfacePrivateVisibility() throws Exception {
+
+        final String code = "package main\n import \"fmt\"\n /*test*/ type person interface {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person").get().modifiers().contains("private"));
+    }
+}
diff --git a/clarpse/src/test/java/com/clarity/test/go/ChildComponentsTest.java b/clarpse/src/test/java/com/clarity/test/go/ChildComponentsTest.java
new file mode 100644
index 0000000..2f344ed
--- /dev/null
+++ b/clarpse/src/test/java/com/clarity/test/go/ChildComponentsTest.java
@@ -0,0 +1,92 @@
+package com.clarity.test.go;
+
+import com.clarity.compiler.ClarpseProject;
+import com.clarity.compiler.Lang;
+import com.clarity.compiler.RawFile;
+import com.clarity.compiler.SourceFiles;
+import com.clarity.sourcemodel.OOPSourceCodeModel;
+import com.clarity.sourcemodel.OOPSourceModelConstants;
+import org.junit.Test;
+
+import static junit.framework.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public class ChildComponentsTest {
+
+    @Test
+    public void testGoStructMethodSingleParamComponentIsChildOfMethod() throws Exception {
+        final String code = "package main\ntype person struct {} \n func (p person) lol(x int) {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person.lol(int)").get().children().get(0).equals("main.person.lol(int).x"));
+    }
+
+    @Test
+    public void testInterfaceAnonymousTypeMethodParamsIsChildOfMethod() throws Exception {
+
+        final String code = "package main \n type plain interface \n{ testMethodv2(x value, h int) (value, uintptr) {} }";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/plain.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.plain.testMethodv2(value, int) : (value, uintptr)").get().children().size() == 2);
+        assertTrue(generatedSourceModel.getComponent("main.plain.testMethodv2(value, int) : (value, uintptr).x")
+                .get().componentType() == OOPSourceModelConstants.ComponentType.METHOD_PARAMETER_COMPONENT);
+    }
+
+    @Test
+    public void testGoStructMethodIsChildofStruct() throws Exception {
+        final String code = "package main\ntype person struct {} \n func (p person) x() int {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person").get().children().contains("main.person.x() : (int)"));
+    }
+
+    @Test
+    public void testParseGoStructMethodWithUnnamedParameters() throws Exception {
+        final String code = "package main\ntype person struct {} \n func (p person) x(string) () {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person.x(string)").get().children().size() == 1);
+    }
+
+    @Test
+    public void testGoStructFIeldVarIsChildOfStruct() throws Exception {
+        final String code = "package main\nimport \"test/math\"\ntype person struct {mathObj math.Person}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person").get().children().get(0).equals("main.person.mathObj"));
+    }
+
+    @Test
+    public void testGoStructLocalVarIsChildOfMethod() throws Exception {
+        final String code = "package main\ntype person struct {} \n func (p person) x() {\nvar b, c int = 1, 2\n}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person.x()").get().children().size() == 2);
+        assertTrue(generatedSourceModel.getComponent("main.person.x()").get().children().contains(
+                "main.person.x().b"));
+        assertTrue(generatedSourceModel.getComponent("main.person.x()").get().children().contains(
+                "main.person.x().c"));
+    }
+
+    @Test
+    public void testInterfaceMethodSpecComponentIsChildOfParentInterface() throws Exception {
+        final String code = "package main\ntype person interface { \n//test\n testMethod() int}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person").get().children().get(0).equals("main.person.testMethod() : (int)"));
+    }
+}
diff --git a/clarpse/src/test/java/com/clarity/test/go/CodeFragmentTest.java b/clarpse/src/test/java/com/clarity/test/go/CodeFragmentTest.java
new file mode 100644
index 0000000..5c81166
--- /dev/null
+++ b/clarpse/src/test/java/com/clarity/test/go/CodeFragmentTest.java
@@ -0,0 +1,287 @@
+package com.clarity.test.go;
+
+import com.clarity.compiler.ClarpseProject;
+import com.clarity.compiler.Lang;
+import com.clarity.compiler.RawFile;
+import com.clarity.compiler.SourceFiles;
+import com.clarity.sourcemodel.OOPSourceCodeModel;
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+
+public class CodeFragmentTest {
+
+    @Test
+    public void testInterfaceMethodSpecCodeFragment() throws Exception {
+        final String code = "package main\ntype person interface { testMethod() int}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person.testMethod() : (int)").get().codeFragment().equals("testMethod() : (int)"));
+    }
+
+    @Test
+    public void testGoReturnStructMethodComplexCodeFragment() throws Exception {
+        final String code = "package main\ntype Person struct {}";
+        final String codeB = "package main\n import tester \"main\" \n func (p main.Person) x(args []value, x,y map[value]value, v, u value) (j,i []value, map[value]value.test)  {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/cherry.go", code));
+        rawData.insertFile(new RawFile("/src/com/cakes/test.go", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        System.out.println(generatedSourceModel.getComponent("main.Person.x([]value, map[value]value, map[value]value, value, value) : ([]value, []value, map[value]value.test)").get().codeFragment());
+        assertTrue(generatedSourceModel.getComponent("main.Person.x([]value, map[value]value, map[value]value, value, value) : ([]value, []value, map[value]value.test)").get().codeFragment().equals("x([]value, map[value]value, map[value]value, value, value) : ([]value, []value, map[value]value.test)"));
+        assertTrue(generatedSourceModel.getComponent("main.Person.x([]value, map[value]value, map[value]value, value, value) : ([]value, []value, map[value]value.test).u")
+                .get().parentUniqueName().equals("main.Person.x([]value, map[value]value, map[value]value, value, value) : ([]value, []value, map[value]value.test)"));
+        assertTrue(generatedSourceModel.getComponent("main.Person.x([]value, map[value]value, map[value]value, value, value) : ([]value, []value, map[value]value.test)")
+                .get().parentUniqueName().equals("main.Person"));
+    }
+
+    @Test
+    public void testInterfaceComplexMethodSpecParamsExist() throws Exception {
+        final String code = "package go\n import \"game/org\" \n type person interface { testMethod() org.Cake}";
+        final String codeB = "package org\n type Cake struct {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("src/github/go/person.go", code));
+        rawData.insertFile(new RawFile("src/github/game/org/cakes.go", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("go.person.testMethod() : (org.Cake)").get().codeFragment()
+                .equals("testMethod() : (org.Cake)"));
+    }
+
+    @Test
+    public void fieldVarCodeFragment() throws Exception {
+
+        final String code = "package main\n import\"fmt\"\n type person struct {SuggestFor []value}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person.SuggestFor").get().codeFragment()
+                .equals("SuggestFor : []value"));
+    }
+
+    @Test
+    public void structMethodCodeFragment() throws Exception {
+
+        final String code = "package main\n import\"fmt\"\n type Command struct {} func (c *Command) SetHelpCommand(cmd *Command) {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        System.out.println(generatedSourceModel.getComponent("main.Command.SetHelpCommand(*Command)")
+                .get().codeFragment());
+        assertTrue(generatedSourceModel.getComponent("main.Command.SetHelpCommand(*Command)")
+                .get().codeFragment().equals("SetHelpCommand(*Command)"));
+    }
+
+
+    @Test
+    public void fieldVarCodeFragmentWithComment() throws Exception {
+
+        final String code = "package main\n import\"fmt\"\n type person struct {usageFunc func(*Command) error" +
+                " // Usage can be defined by application\n}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person.usageFunc").get().codeFragment()
+                .equals("usageFunc : func(*Command) error"));
+    }
+
+    @Test
+    public void fieldVarFuncTypeCodeFragment() throws Exception {
+
+        final String code = "package main\n type person struct { PersistentPreRun func(cmd *Command, args []value) }";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        System.out.println(generatedSourceModel.getComponent("main.person.PersistentPreRun").get()
+                .codeFragment());
+        assertTrue(generatedSourceModel.getComponent("main.person.PersistentPreRun").get()
+                .codeFragment().equals("PersistentPreRun : func(cmd *Command, args []value)"));
+    }
+
+    @Test
+    public void fieldVarFuncTypeCodeFragmentWithComment() throws Exception {
+
+        final String code = "package main\n type person struct { PersistentPreRun func(cmd *Command, args []value)//test \n}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        System.out.println(generatedSourceModel.getComponent("main.person.PersistentPreRun")
+                .get().codeFragment());
+        assertTrue(generatedSourceModel.getComponent("main.person.PersistentPreRun").get()
+                .codeFragment().equals("PersistentPreRun : func(cmd *Command, args []value)"));
+    }
+
+    @Test
+    public void testInterfaceAnonymousTypeMethods() throws Exception {
+        final String code = "package main \n type plain interface \n{ testMethodv2() (value, uintptr) {} }";
+        final String codeB = "package main\n type Person struct {}";
+
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/plain.go", code));
+        rawData.insertFile(new RawFile("/src/main/test.go", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.plain.testMethodv2() : (value, uintptr)").get().codeFragment().equals("testMethodv2() : (value, uintptr)"));
+    }
+
+    @Test
+    public void fieldVarFuncTypeCodeFragmentv2() throws Exception {
+
+        final String code = "package main\n type person struct { globNormFunc func(f *flag.FlagSet, name value)" +
+                " flag.NormalizedName }";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        System.out.println(generatedSourceModel.getComponent("main.person.globNormFunc").get()
+                .codeFragment());
+        assertTrue(generatedSourceModel.getComponent("main.person.globNormFunc").get().codeFragment()
+                .equals("globNormFunc : func(f *flag.FlagSet, name value) flag.NormalizedName"));
+    }
+
+    @Test
+    public void testGoStructMethodCodeFragment() throws Exception {
+        final String code = "package main\ntype Person struct {}";
+        final String codeB = "package main\n import tester \"main\" \n func (p tester.Person) x() int {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/cherry.go", code));
+        rawData.insertFile(new RawFile("/src/com/cakes/test.go", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        System.out.println(generatedSourceModel.getComponent("main.Person.x() : (int)").get().codeFragment());
+        assertTrue(generatedSourceModel.getComponent("main.Person.x() : (int)").get().codeFragment()
+                .equals("x() : (int)"));
+    }
+
+    @Test
+    public void testGoStructMethodSpecCodeFragment() throws Exception {
+        final String code = "package main\ntype Person interface {  Get(key interface{}) (value interface{}, ok bool) }";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/cherry.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        System.out.println(generatedSourceModel.getComponent("main.Person.Get(interface{}) : (interface{}, bool)").get().codeFragment());
+        assertTrue(generatedSourceModel.getComponent("main.Person.Get(interface{}) : (interface{}, bool)")
+                .get().codeFragment().equals("Get(interface{}) : (interface{}, bool)"));
+    }
+
+    @Test
+    public void testGoStructMethodWithFuncAsParamCodeFragment() throws Exception {
+        final String code = "package main\ntype Person struct {  func (c *Person) SetGlobalNormalizationFunc(n func(f " +
+                "*flag.FlagSet, name value)) {} }";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/cherry.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        System.out.println(generatedSourceModel.getComponent("main.Person.SetGlobalNormalizationFunc(func(f *flag.FlagSet, name value))").get().codeFragment());
+        assertTrue(generatedSourceModel.getComponent("main.Person.SetGlobalNormalizationFunc(func(f *flag.FlagSet, name value))").get().codeFragment()
+                .equals("SetGlobalNormalizationFunc(func(f *flag.FlagSet, name value))"));
+    }
+
+    @Test
+    public void testGoInterfaceMethodWithFuncAsParamCodeFragment() throws Exception {
+        final String code = "package main\ntype Person interface {  func SetGlobalNormalizationFunc(n func(f *flag.FlagSet, name value)) }";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/cherry.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        System.out.println(generatedSourceModel.getComponent("main.Person.SetGlobalNormalizationFunc(func(f *flag.FlagSet, name value))").get().codeFragment());
+        assertTrue(generatedSourceModel.getComponent("main.Person.SetGlobalNormalizationFunc(func(f *flag.FlagSet, name value))").get().codeFragment()
+                .equals("SetGlobalNormalizationFunc(func(f *flag.FlagSet, name value))"));
+
+        assertTrue(generatedSourceModel.getComponent("main.Person.SetGlobalNormalizationFunc(func(f *flag.FlagSet, name value))").get().parentUniqueName()
+                .equals("main.Person"));
+    }
+
+    @Test
+    public void testGoStructMethodWithFuncAsReturnCodeFragment() throws Exception {
+        final String code = "package main\ntype Person struct {  func (c *Person) SetGlobalNormalizationFunc(n int) (func(f *flag.FlagSet, name value)) {} }";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/cherry.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.Person.SetGlobalNormalizationFunc(int) : (func(f *flag.FlagSet, name value))").get().codeFragment().equals(
+                "SetGlobalNormalizationFunc(int) : (func(f *flag.FlagSet, name value))"));
+    }
+
+    @Test
+    public void testGoStructMethodWithFuncAsPartOfReturnCodeFragment() throws Exception {
+        final String code = "package main\ntype Person struct {  func (c *Person) SetGlobalNormalizationFunc(n int) (x int, func(f *flag.FlagSet, name value)) {} }";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/cherry.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.Person.SetGlobalNormalizationFunc(int) : (int, func(f *flag.FlagSet, name value))").get().codeFragment().equals(
+                "SetGlobalNormalizationFunc(int) : (int, func(f *flag.FlagSet, name value))"));
+    }
+
+    @Test
+    public void testGoStructMethodMultipleDeclarationReturnCodeFragment() throws Exception {
+        final String code = "package main\ntype Person struct {}";
+        final String codeB = "package main\n import tester \"main\" \n func (p tester.Person) x() (x,y int) {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/cherry.go", code));
+        rawData.insertFile(new RawFile("/src/com/cakes/test.go", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.Person.x() : (int, int)").get().codeFragment().equals("x() : (int, int)"));
+    }
+
+    @Test
+    public void testGoStructMethodMultipleIndividualDeclarationReturnCodeFragment() throws Exception {
+        final String code = "package main\ntype Person struct {}";
+        final String codeB = "package main\n import tester \"main\" \n func (p tester.Person) x() (x uint8,y int) {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/cherry.go", code));
+        rawData.insertFile(new RawFile("/src/com/cakes/test.go", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        System.out.println(generatedSourceModel.getComponent("main.Person.x() : (uint8, int)").get().codeFragment());
+        assertTrue(generatedSourceModel.getComponent("main.Person.x() : (uint8, int)").get().codeFragment().equals("x() : (uint8, int)"));
+    }
+
+    @Test
+    public void testGoStructMethodMultipleComplexDeclarationReturnCodeFragment() throws Exception {
+        final String code = "package main\ntype Person struct {}";
+        final String codeB = "package main\n import tester \"main\" \n func (p tester.Person) x() (x,z uint8, y int) {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/cherry.go", code));
+        rawData.insertFile(new RawFile("/src/com/cakes/test.go", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.Person.x() : (uint8, uint8, int)").get().codeFragment().equals("x() : (uint8, uint8, int)"));
+    }
+
+    @Test
+    public void testGoStructMethodMultipleReturnCodeFragment() throws Exception {
+        final String code = "package main\ntype Person struct {}";
+        final String codeB = "package main\n import tester \"main\" \n func (p tester.Person) x() (value, int) {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/cherry.go", code));
+        rawData.insertFile(new RawFile("/src/com/cakes/test.go", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.Person.x() : (value, int)").get().codeFragment().equals("x() : (value, int)"));
+    }
+
+    @Test
+    public void testGoNoReturnStructMethodCodeFragmentIsNull() throws Exception {
+        final String code = "package main\ntype Person struct {}";
+        final String codeB = "package main\n import tester \"main\" \n func (p main.Person) x() {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/cherry.go", code));
+        rawData.insertFile(new RawFile("/src/com/cakes/test.go", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        System.out.println(generatedSourceModel.getComponent("main.Person.x()").get().codeFragment());
+        assertTrue(generatedSourceModel.getComponent("main.Person.x()").get().codeFragment().equals("x()"));
+    }
+}
diff --git a/clarpse/src/test/java/com/clarity/test/go/CommentsParsingTest.java b/clarpse/src/test/java/com/clarity/test/go/CommentsParsingTest.java
new file mode 100644
index 0000000..463d44a
--- /dev/null
+++ b/clarpse/src/test/java/com/clarity/test/go/CommentsParsingTest.java
@@ -0,0 +1,103 @@
+package com.clarity.test.go;
+
+import com.clarity.compiler.ClarpseProject;
+import com.clarity.compiler.Lang;
+import com.clarity.compiler.RawFile;
+import com.clarity.compiler.SourceFiles;
+import com.clarity.sourcemodel.OOPSourceCodeModel;
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+
+public class CommentsParsingTest {
+
+    @Test
+    public void testParsedSingleLineStructDoc() throws Exception {
+        final String code = "package main\n //test struct doc\n type person struct {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person").get().comment().equals("test struct doc"));
+    }
+
+    @Test
+    public void testParsMultiLineStructDoc() throws Exception {
+        final String code = "package main\n //test struct\n// doc\n type person struct {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person").get().comment().equals("test struct doc"));
+    }
+
+    @Test
+    public void testParseMultiLineInterfaceDoc() throws Exception {
+        final String code = "package main\n //test interface\n// doc\n type person interface {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person").get().comment().equals("test interface doc"));
+    }
+
+    @Test
+    public void testGoStructMethodComment() throws Exception {
+        final String code = "package main\ntype person struct {}\n\n //test \n //test\n\nfunc (p person) x() int {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person.x() : (int)").get().comment().equals("test test"));
+    }
+
+    @Test
+    public void testGoStructMethodDocComment() throws Exception {
+        final String code = "package main\ntype person struct {}\n\n //test \n //test\n\nfunc (p person) x() int {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person.x() : (int)").get().comment().equals("test test"));
+    }
+
+    @Test
+    public void testParseSingleLineStructDocSeparatedByEmptyLines() throws Exception {
+        final String code = "package main\n//test struct doc\n\n\n\ntype person struct {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person").get().comment().equals("test struct doc"));
+    }
+
+    @Test
+    public void testParseMultiLineStructDocAfterAnotherStruct() throws Exception {
+        final String code = "package main\n type animal struct {}\n//test struct\n// doc\n type person struct {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person").get().comment().equals("test struct doc"));
+    }
+
+    @Test
+    public void testParseMultiLineStructDocSeparatedByEmptyLines() throws Exception {
+        final String code = "package main\n//test struct\n// doc\n\n\ntype person struct {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person").get().comment().equals("test struct doc"));
+    }
+
+    @Test
+    public void testParseMultiLineStructDocForInterfaceMethodSpece() throws Exception {
+        final String code = "package main\ntype person interface { \n//test\n testMethod() int}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person.testMethod() : (int)").get().comment().equals("test"));
+    }
+}
diff --git a/clarpse/src/test/java/com/clarity/test/go/ComponentReferenceTest.java b/clarpse/src/test/java/com/clarity/test/go/ComponentReferenceTest.java
new file mode 100644
index 0000000..0c0e75c
--- /dev/null
+++ b/clarpse/src/test/java/com/clarity/test/go/ComponentReferenceTest.java
@@ -0,0 +1,335 @@
+package com.clarity.test.go;
+
+import com.clarity.compiler.ClarpseProject;
+import com.clarity.compiler.Lang;
+import com.clarity.compiler.RawFile;
+import com.clarity.compiler.SourceFiles;
+import com.clarity.sourcemodel.OOPSourceCodeModel;
+import com.clarity.sourcemodel.OOPSourceModelConstants;
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+
+public class ComponentReferenceTest {
+
+    @Test
+    public void testResolveTypesComplex() throws Exception {
+        final String code = "package main\n import \"html/template\"\n import temp \"text/template\"\n type berry struct {\n person template.Person}";
+        final String codeB = "package template\n type Person struct {}";
+        final String codeC = "package template\n type Person struct {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/github/com/main/person.go", code));
+        rawData.insertFile(new RawFile("/github/com/html/template/person.go", codeB));
+        rawData.insertFile(new RawFile("/github/com/text/template/person.go", codeC));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.berry.person")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0).invokedComponent()
+                .equals("html.template.Person"));
+    }
+
+    @Test
+    public void testTwoGoStructsReferenceEachOther() throws Exception {
+        final String code = "package test \n type person struct {teacher Teacher} \n type Teacher struct{}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("src/github/test/person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("test.person.teacher")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0).invokedComponent()
+                .equals("test.Teacher"));
+    }
+
+    @Test
+    public void localVarComponentReference() throws Exception {
+        final String code = "package main \n type plain struct \n{} \n func (t plain) testMethodv2 () {\n var i int  = 2;\n}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/plain.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.plain.testMethodv2().i")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0).invokedComponent().equals("int"));
+    }
+
+    @Test
+    public void testInterfaceAnonymousTypeMethodParamDeclaration() throws Exception {
+        final String code = "package main \n type plain interface \n{ testMethodv2(x string, h int) (string, uintptr) {} }";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/plain.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.plain.testMethodv2(string, int) : (string, uintptr).x")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).size() == 1);
+        assertTrue(generatedSourceModel.getComponent("main.plain.testMethodv2(string, int) : (string, uintptr).x")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0).invokedComponent().equals("string"));
+        assertTrue(generatedSourceModel.getComponent("main.plain.testMethodv2(string, int) : (string, uintptr).h")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0).invokedComponent().equals("int"));
+        assertTrue(generatedSourceModel.getComponent("main.plain.testMethodv2(string, int) : (string, uintptr).x")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).size() == 1);
+    }
+
+    @Test
+    public void testParseGoStructImplementsInterface() throws Exception {
+        final String codeA = "package main\n import \"github\"\n type person struct {}\n func (p person) someMethod() {}";
+        final String codeB = "package github\n \n type anInterface interface { someMethod();}";
+
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/person.go", codeA));
+        rawData.insertFile(new RawFile("/src/lol/github/aninterface.go", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person")
+                .get().references(OOPSourceModelConstants.TypeReferences.IMPLEMENTATION).get(0).invokedComponent()
+                .equals("lol.github.anInterface"));
+    }
+
+    @Test
+    public void testParseGoInterfaceDoesNotImplementItself() throws Exception {
+        final String codeA = "package main\n import \"github\"\n type person struct {}\n func (p person) someMethod() {}";
+        final String codeB = "package github\n \n type anInterface interface { someMethod();}";
+
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/person.go", codeA));
+        rawData.insertFile(new RawFile("/src/lol/github/aninterface.go", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("lol.github.anInterface")
+                .get().references(OOPSourceModelConstants.TypeReferences.IMPLEMENTATION).size() == 0);
+    }
+
+    @Test
+    public void testParseGoStructImplementsInterfaceComplex() throws Exception {
+        final String codeA = "package main\n type person struct {}\n func (p person) someMethod() {}\n"
+                + "func (p* person) methodA() {}\n func (p person) methodB(int, y int, z string) (f,d string) {}";
+        final String codeB = "package github\n \n type anInterface interface { aSecondInterface \n someMethod();}";
+        final String codeC = "package github\n \n type aSecondInterface interface { methodA();\n methodB(x,y int, z string) (f string, d string);";
+
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/person.go", codeA));
+        rawData.insertFile(new RawFile("/src/lol/github/aninterface.go", codeB));
+        rawData.insertFile(new RawFile("/src/lol/github/aSecondinterface.go", codeC));
+
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person")
+                .get().references(OOPSourceModelConstants.TypeReferences.IMPLEMENTATION).size() == 2);
+        assertTrue(generatedSourceModel.getComponent("main.person")
+                .get().references(OOPSourceModelConstants.TypeReferences.IMPLEMENTATION).get(0).invokedComponent()
+                .equals("lol.github.anInterface"));
+        assertTrue(generatedSourceModel.getComponent("main.person")
+                .get().references(OOPSourceModelConstants.TypeReferences.IMPLEMENTATION).get(1).invokedComponent()
+                .equals("lol.github.aSecondInterface"));
+    }
+
+    @Test
+    public void testParseGoStructDoesNotImplementSimilarInterfaceByName() throws Exception {
+        final String codeA = "package main\n type person struct {}\n func (p person) someMethods() {}\n"
+                + "func (p* person) methodA() {}\n func (p person) methodB(x int, y int, z string) (f,d string) {}";
+        final String codeB = "package github\n \n type anInterface interface { aSecondInterface \n someMethod();}";
+        final String codeC = "package github\n \n type aSecondInterface interface { methodA();\n methodB(x,y int, z string) (f string, d string);}";
+
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/person.go", codeA));
+        rawData.insertFile(new RawFile("/src/lol/github/aninterface.go", codeB));
+        rawData.insertFile(new RawFile("/src/lol/github/aSecondinterface.go", codeC));
+
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person")
+                .get().references(OOPSourceModelConstants.TypeReferences.IMPLEMENTATION).size() == 1);
+    }
+
+    @Test
+    public void testParseGoStructDoesImplementsTwoSeparateInterfaces() throws Exception {
+        final String codeA = "package main\n type person struct {}\n func (p person) someMethod() {}\n"
+                + "func (p* person) methodA() {}\n func (p person) methodB(x int, y int, z string) (f,d string) {}";
+        final String codeB = "package github\n \n type anInterface interface {  someMethod();}";
+        final String codeC = "package github\n \n type aSecondInterface interface { methodA();\n methodB(x,y int, z string) (f string, d string);";
+
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/person.go", codeA));
+        rawData.insertFile(new RawFile("/src/lol/github/aninterface.go", codeB));
+        rawData.insertFile(new RawFile("/src/lol/github/aSecondinterface.go", codeC));
+
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person")
+                .get().references(OOPSourceModelConstants.TypeReferences.IMPLEMENTATION).size() == 2);
+        assertTrue(generatedSourceModel.getComponent("main.person")
+                .get().references(OOPSourceModelConstants.TypeReferences.IMPLEMENTATION).get(0).invokedComponent()
+                .equals("lol.github.anInterface"));
+        assertTrue(generatedSourceModel.getComponent("main.person")
+                .get().references(OOPSourceModelConstants.TypeReferences.IMPLEMENTATION).get(1).invokedComponent()
+                .equals("lol.github.aSecondInterface"));
+    }
+
+    @Test
+    public void testParseGoStructExtensionThroughAnonymousType() throws Exception {
+        final String code = "package main\n import \"fmt\"\n /*test*/ type person struct {fmt.Math}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person").get().references(OOPSourceModelConstants.TypeReferences.EXTENSION)
+                .get(0).invokedComponent().equals("fmt.Math"));
+    }
+
+    @Test
+    public void testParseGoStructMultipleTypesInFieldVar() throws Exception {
+        final String code = "package main\n import \"fmt\"\n type person struct {aField map[*fmt.Node]bool}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person.aField")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).size() == 2);
+        assertTrue(generatedSourceModel.getComponent("main.person.aField")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0).invokedComponent().equals("fmt.Node"));
+        assertTrue(generatedSourceModel.getComponent("main.person.aField")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(1).invokedComponent().equals("bool"));
+    }
+
+    @Test
+    public void testPackageImportResolveFunction() throws Exception {
+        final String code = "package main\n import \"package/http\"\n type person struct {http.Object}";
+        final String codeB = "package http\n type Object struct{}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("src/custom/package/http/person.go", codeB));
+        rawData.insertFile(new RawFile("/src/custom/main/person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("src.custom.main.person")
+                .get().references(OOPSourceModelConstants.TypeReferences.EXTENSION).get(0).invokedComponent()
+                .equals("src.custom.package.http.Object"));
+    }
+
+    @Test
+    public void testPackageImportResolveStructField() throws Exception {
+        final String code = "package main\n import zed \"package/http\"\n type person struct {x zed.Object}";
+        final String codeB = "package http\n type Object struct{}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("src/custom/package/http/person.go", codeB));
+        rawData.insertFile(new RawFile("/src/custom/main/person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("src.custom.main.person")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0).invokedComponent()
+                .equals("src.custom.package.http.Object"));
+    }
+
+    @Test
+    public void testParseGoStructExtensionThroughAnonymousTypePointer() throws Exception {
+        final String code = "package main\n import \"fmt\"\n /*test*/ type person struct {*fmt.Math}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person").get().references(OOPSourceModelConstants.TypeReferences.EXTENSION)
+                .get(0).invokedComponent().equals("fmt.Math"));
+    }
+
+    @Test
+    public void testInterfaceAnonymousTypeExtends() throws Exception {
+        final String code = "package main \n type plain interface \n{testMethod() int\n Person\n testMethodv2() (string, uintptr) {} }";
+        final String codeB = "package main\n type Person struct {}";
+
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/plain.go", code));
+        rawData.insertFile(new RawFile("/src/main/test.go", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.plain").get().references(OOPSourceModelConstants.TypeReferences.EXTENSION)
+                .get(0).invokedComponent().equals("main.Person"));
+        assertTrue(generatedSourceModel.getComponent("main.plain.testMethodv2() : (string, uintptr)").get().codeFragment().equals("testMethodv2() : (string, uintptr)"));
+    }
+
+    @Test
+    public void testGoStructFieldVarReference() throws Exception {
+        final String code = "package main\nimport \"test/math\"\ntype person struct {mathObj math.Person}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person.mathObj")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0).invokedComponent()
+                .equals("test.math.Person"));
+    }
+
+    @Test
+    public void testGoStructMethodSingleParamComponentReference() throws Exception {
+        final String code = "package main\ntype person struct {} \n func (p person) lol(x int) {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person.lol(int).x")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0).invokedComponent().equals("int"));
+    }
+
+    @Test
+    public void testGoStructMethodTripleParamComponentReference() throws Exception {
+        final String codeB = "package http\ntype httpcakes struct {}";
+        final String code = "package main\nimport \"http\"\ntype person struct {} \n func (p person) lol(x,y int, z *http.httpcakes) {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("src/main/person.go", code));
+        rawData.insertFile(new RawFile("src/github/http/http.go", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person.lol(int, int, *http.httpcakes).x")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0).invokedComponent().equals("int"));
+        assertTrue(generatedSourceModel.getComponent("main.person.lol(int, int, *http.httpcakes).y")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0).invokedComponent().equals("int"));
+        assertTrue(generatedSourceModel.getComponent("main.person.lol(int, int, *http.httpcakes).z")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0).invokedComponent()
+                .equals("github.http.httpcakes"));
+    }
+
+    @Test
+    public void testGoStructMethodSingleParamUniqueNameComplex() throws Exception {
+        final String code = "package main\ntype Person struct {}";
+        final String codeB = "package main\n import tester \"test/main\" \n func (p tester.Person) x(v1,v2 tester.Person) {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/test/main/cherry.go", code));
+        rawData.insertFile(new RawFile("/src/main/test.go", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("test.main.Person.x(tester.Person, tester.Person).v1").get().packageName().equals("test.main"));
+        assertTrue(generatedSourceModel.getComponent("test.main.Person.x(tester.Person, tester.Person).v2")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0).invokedComponent()
+                .equals("test.main.Person"));
+        assertTrue(generatedSourceModel.getComponent("test.main.Person.x(tester.Person, tester.Person)").get().children().size() == 2);
+        assertTrue(generatedSourceModel.getComponent("test.main.Person.x(tester.Person, tester.Person)").get().children().get(0)
+                .equals("test.main.Person.x(tester.Person, tester.Person).v1"));
+    }
+
+    @Test
+    public void simpleReferenceWithAsterisk() throws Exception {
+        final String code = "package main\ntype Person struct {}";
+        final String codeB = "package main\n import tester \"test/main\" \n func (p tester.Person) x(v1,v2 *tester.Person) {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/test/main/cherry.go", code));
+        rawData.insertFile(new RawFile("/src/main/test.go", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("test.main.Person.x(*tester.Person, *tester.Person).v2")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0).invokedComponent()
+                .equals("test.main.Person"));
+    }
+
+
+
+    @Test
+    public void simpleGitHubPkgRef() throws Exception {
+        final String codeB = "package main\n import log \"github.com/sirupsen/logrus\" \n type Person struct {} \n" +
+                "func (p Person)  x(v1 log.Tester) {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("test.go", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.Person.x(log.Tester).v1")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0).invokedComponent()
+                .equals("github.com.sirupsen.logrus.Tester"));
+    }
+
+
+}
diff --git a/clarpse/src/test/java/com/clarity/test/go/ComponentSourceFilePathTest.java b/clarpse/src/test/java/com/clarity/test/go/ComponentSourceFilePathTest.java
new file mode 100644
index 0000000..c8cddc1
--- /dev/null
+++ b/clarpse/src/test/java/com/clarity/test/go/ComponentSourceFilePathTest.java
@@ -0,0 +1,61 @@
+package com.clarity.test.go;
+
+
+import com.clarity.compiler.ClarpseProject;
+import com.clarity.compiler.Lang;
+import com.clarity.compiler.RawFile;
+import com.clarity.compiler.SourceFiles;
+import com.clarity.sourcemodel.Component;
+import com.clarity.sourcemodel.OOPSourceCodeModel;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+
+/**
+ * Ensure components are displaying the correct associated source file path.
+ */
+public class ComponentSourceFilePathTest {
+
+    @Test
+    public void testGoStructHasCorrectSourceFileAttr() throws Exception {
+        final String code = "package main\ntype person struct {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person").get().sourceFile().equals("person.go"));
+    }
+
+    @Test
+    public void testGoStructMethodCorrectSourceFileAttr() throws Exception {
+        final String code = "package main\ntype person struct {} \n func (p person) x() int {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person.x() : (int)").get().sourceFile().equals("person.go"));
+    }
+
+    @Test
+    public void testGoInterfaceMethodSourceFileAttr() throws Exception {
+        final String code = "package main\n type person interface {\n area() float64 \n} type teacher struct{}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person.area() : (float64)")
+                .get().sourceFile().equals("person.go"));
+    }
+
+    @Test
+    public void testGoInterfaceSourceFileAttr() throws Exception {
+        final String code = "package main\n type person interface {\n area() float64 \n} type teacher struct{}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person")
+                .get().sourceFile().equals("person.go"));
+    }
+}
diff --git a/clarpse/src/test/java/com/clarity/test/go/ComponentTypeTest.java b/clarpse/src/test/java/com/clarity/test/go/ComponentTypeTest.java
new file mode 100644
index 0000000..a9eb14f
--- /dev/null
+++ b/clarpse/src/test/java/com/clarity/test/go/ComponentTypeTest.java
@@ -0,0 +1,115 @@
+package com.clarity.test.go;
+
+import com.clarity.ClarpseUtil;
+import com.clarity.compiler.ClarpseProject;
+import com.clarity.compiler.Lang;
+import com.clarity.compiler.RawFile;
+import com.clarity.compiler.SourceFiles;
+import com.clarity.sourcemodel.Component;
+import com.clarity.sourcemodel.OOPSourceCodeModel;
+import com.clarity.sourcemodel.OOPSourceModelConstants;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import java.util.Optional;
+
+import static org.junit.Assert.assertTrue;
+
+/**
+ * Tests to ensure component type attribute of parsed components are accurate.
+ */
+public class ComponentTypeTest {
+    @Test
+    public void testInterfaceAnonymousTypeMethodParamType() throws Exception {
+
+        final String code = "package main \n type plain interface \n{ testMethodv2(x value, h int) (value, uintptr) {} }";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/plain.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.plain.testMethodv2(value, int) : (value, uintptr).x")
+                .get().componentType() == OOPSourceModelConstants.ComponentType.METHOD_PARAMETER_COMPONENT);
+    }
+
+    @Test
+    public void testGoStructMethodSingleParamComponentType() throws Exception {
+        final String code = "package main\ntype person struct {} \n func (p person) lol(x int) {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person.lol(int).x")
+                .get().componentType() == OOPSourceModelConstants.ComponentType.METHOD_PARAMETER_COMPONENT);
+    }
+
+    @Test
+    public void testGoInterfaceComponentType() throws Exception {
+        final String code = "package main\n type person interface {\n area() float64 \n} type teacher struct{}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person").get()
+                .componentType() == OOPSourceModelConstants.ComponentType.INTERFACE);
+    }
+
+    @Test
+    public void testGoStructMethodComponentType() throws Exception {
+        final String code = "package main\ntype person struct {} \n func (p person) x() int {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person.x() : (int)").get()
+                .componentType() == OOPSourceModelConstants.ComponentType.METHOD);
+    }
+
+    @Test
+    public void testGoStructFieldVarComponenType() throws Exception {
+        final String code = "package main\nimport \"test/math\"\ntype person struct {mathObj math.Person}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person.mathObj").get()
+                .componentType() == OOPSourceModelConstants.ComponentType.FIELD);
+    }
+
+    @Test
+    public void testGoStructHasCorrectComponentType() throws Exception {
+        final String code = "package main\ntype person struct {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person").get()
+                .componentType() == OOPSourceModelConstants.ComponentType.STRUCT);
+    }
+
+
+    @Test
+    public void testInterfaceMethodSpecComponentType() throws Exception {
+
+        final String code = "package main\ntype person interface { \n//test\n testMethod() int}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person.testMethod() : (int)").get()
+                .componentType() == OOPSourceModelConstants.ComponentType.METHOD);
+    }
+
+    @Test
+    public void localVarComponentType() throws Exception {
+
+        final String code = "package main \n type plain struct \n{} \n func (t plain) testMethodv2 () {\n var i int  = 2;\n}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/plain.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(
+                generatedSourceModel.getComponent("main.plain.testMethodv2().i").get()
+                        .componentType() == OOPSourceModelConstants.ComponentType.LOCAL);
+    }
+}
diff --git a/clarpse/src/test/java/com/clarity/test/go/CycloTest.java b/clarpse/src/test/java/com/clarity/test/go/CycloTest.java
new file mode 100644
index 0000000..62a95d9
--- /dev/null
+++ b/clarpse/src/test/java/com/clarity/test/go/CycloTest.java
@@ -0,0 +1,140 @@
+package com.clarity.test.go;
+
+import com.clarity.compiler.ClarpseProject;
+import com.clarity.compiler.Lang;
+import com.clarity.compiler.RawFile;
+import com.clarity.compiler.SourceFiles;
+import com.clarity.sourcemodel.OOPSourceCodeModel;
+import org.junit.Assert;
+import org.junit.Test;
+
+import static junit.framework.Assert.assertTrue;
+
+/**
+ * Tests accuracy of Component cyclomatic complexity attribute. See {@link com.clarity.sourcemodel.Component}.
+ */
+public class CycloTest {
+
+    @Test
+    public void testGoInterfaceMethodComplexity() throws Exception {
+        final String code = "package main\n type person interface {\n area() float64 \n} type teacher struct{}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        Assert.assertTrue(generatedSourceModel.getComponent("main.person.area() : (float64)")
+                .get()
+                .cyclo() == 0);
+    }
+
+    @Test
+    public void testGoMethodComplexity() throws Exception {
+        final String code = "package main\ntype person struct {} \n " +
+                "func (p person) x() int {" +
+                "    for i := 0; i < 10; i++ {\n" +
+                "      if 7%2 == 0 && true {\n" +
+                "        // && || \n" +
+                "        fmt.Println(\"7 is even\")\n" +
+                "    } else {\n" +
+                "        fmt.Println(\"7 is odd\")\n" +
+                "    } \n " +
+                "   }" +
+                "}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        Assert.assertTrue(generatedSourceModel.getComponent("main.person.x() : (int)").get().cyclo() == 5);
+    }
+
+    @Test
+    public void testEmptyGoMethodComplexity() throws Exception {
+        final String code = "package main\ntype person struct {} \n " +
+                "func (p person) x() int {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        Assert.assertTrue(generatedSourceModel.getComponent("main.person.x() : (int)").get().cyclo() == 1);
+    }
+
+
+    @Test
+    public void testGoMethodExprSwitchComplexity() throws Exception {
+        final String code = "package main\ntype person struct {} \n func (p person) x() int { " +
+                "switch os := runtime.GOOS; os {\n" +
+                "case \"darwin\":\n" +
+                "fmt.Println(\"OS X.\")\n" +
+                "case \"linux\":\n" +
+                "fmt.Println(\"Linux.\")\n" +
+                "default:\n" +
+                "// freebsd, openbsd,\n" +
+                "// plan9, windows...\n" +
+                "fmt.Printf(\"%s.\", os)\n" +
+                "}" +
+                "}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        Assert.assertTrue(generatedSourceModel.getComponent("main.person.x() : (int)").get().cyclo() == 3);
+    }
+
+    @Test
+    public void testGoMethodTypeSwitchComplexity() throws Exception {
+        final String code = "package main\nimport \"fmt\"\ntype person struct {} \n func (p person) x() int { " +
+                "switch v := i.(type) {\n" +
+                "case int:\n" +
+                "fmt.Printf(\"Twice %v is %v\\n\", v, v*2)\n" +
+                "case string:\n" +
+                "fmt.Printf(\"%q is %v bytes long\\n\", v, len(v))\n" +
+                "default:\n" +
+                "fmt.Printf(\"I don't know about type %T!\\n\", v)\n" +
+                "}" +
+                "}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        Assert.assertTrue(generatedSourceModel.getComponent("main.person.x() : (int)").get().cyclo() == 3);
+    }
+
+    @Test
+    public void testGoStructComplexity() throws Exception {
+        final String code = "package main\nimport \"fmt\"\ntype person struct {} \n " +
+                "func (p person) x() int { " +
+                "switch v := i.(type) {\n" +
+                "case int:\n" +
+                "fmt.Printf(\"Twice %v is %v\\n\", v, v*2)\n" +
+                "case string:\n" +
+                "fmt.Printf(\"%q is %v bytes long\\n\", v, len(v))\n" +
+                "default:\n" +
+                "fmt.Printf(\"I don't know about type %T!\\n\", v)\n" +
+                "} }" +
+                "func (p person) z() int {" +
+                "    if 7%2 == 0 && true {\n" +
+                "        // && || \n" +
+                "        fmt.Println(\"7 is even\")\n" +
+                "    } else {\n" +
+                "        fmt.Println(\"7 is odd\")\n" +
+                "    } " +
+                "}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        Assert.assertTrue(generatedSourceModel.getComponent("main.person").get().cyclo() == 3);
+    }
+
+    @Test
+    public void testGoEmptyStructComplexity() throws Exception {
+        final String code = "package main\nimport \"fmt\"\ntype person struct {} \n " +
+                "}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        Assert.assertTrue(generatedSourceModel.getComponent("main.person").get().cyclo() == 0);
+    }
+
+}
diff --git a/clarpse/src/test/java/com/clarity/test/go/GoLangParseTest.java b/clarpse/src/test/java/com/clarity/test/go/GoLangParseTest.java
index 3ba2d6b..dcaddf1 100644
--- a/clarpse/src/test/java/com/clarity/test/go/GoLangParseTest.java
+++ b/clarpse/src/test/java/com/clarity/test/go/GoLangParseTest.java
@@ -5,8 +5,7 @@
 import com.clarity.compiler.RawFile;
 import com.clarity.compiler.SourceFiles;
 import com.clarity.sourcemodel.OOPSourceCodeModel;
-import com.clarity.sourcemodel.OOPSourceModelConstants.ComponentInvocations;
-import com.clarity.sourcemodel.OOPSourceModelConstants.ComponentType;
+import com.clarity.sourcemodel.OOPSourceModelConstants.TypeReferences;
 import org.junit.Test;
 
 import static org.junit.Assert.assertFalse;
@@ -14,31 +13,8 @@
 
 public class GoLangParseTest {
 
-    @Test
-    public void testPackageGroup() throws Exception {
-
-        final String code = "package main\ntype person struct {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person").get().packageName().equals("main"));
-    }
-
-    @Test
-    public void testShortImportType() throws Exception {
-
-        final String code = "package main\n import\"fmt\"\n type person struct {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person").get().imports().get(0).equals("fmt"));
-    }
-
     @Test
     public void assertNoMethodParameters() throws Exception {
-
         final String code = "package main\n import\"flag\"\n type Command struct {}\n func (c *Command) LocalFlags() *flag.FlagSet {}";
         final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
         rawData.insertFile(new RawFile("person.go", code));
@@ -47,93 +23,8 @@ public void assertNoMethodParameters() throws Exception {
         assertTrue(generatedSourceModel.getComponent("main.Command.LocalFlags() : (*flag.FlagSet)").get().children().size() == 0);
     }
 
-    @Test
-    public void fieldVarCodeFragment() throws Exception {
-
-        final String code = "package main\n import\"fmt\"\n type person struct {SuggestFor []value}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.SuggestFor").get().codeFragment().equals("SuggestFor : []value"));
-    }
-
-    @Test
-    public void structMethodCodeFragment() throws Exception {
-
-        final String code = "package main\n import\"fmt\"\n type Command struct {} func (c *Command) SetHelpCommand(cmd *Command) {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        System.out.println(generatedSourceModel.getComponent("main.Command.SetHelpCommand(*Command)").get().codeFragment());
-        assertTrue(generatedSourceModel.getComponent("main.Command.SetHelpCommand(*Command)").get().codeFragment().equals("SetHelpCommand(*Command)"));
-    }
-
-
-    @Test
-    public void fieldVarCodeFragmentWithComment() throws Exception {
-
-        final String code = "package main\n import\"fmt\"\n type person struct {usageFunc func(*Command) error // Usage can be defined by application\n}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.usageFunc").get().codeFragment().equals("usageFunc : func(*Command) error"));
-    }
-
-    @Test
-    public void fieldVarFuncTypeCodeFragment() throws Exception {
-
-        final String code = "package main\n type person struct { PersistentPreRun func(cmd *Command, args []value) }";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        System.out.println(generatedSourceModel.getComponent("main.person.PersistentPreRun").get().codeFragment());
-        assertTrue(generatedSourceModel.getComponent("main.person.PersistentPreRun").get().codeFragment().equals("PersistentPreRun : func(cmd *Command, args []value)"));
-    }
-
-    @Test
-    public void fieldVarFuncTypeCodeFragmentWithComment() throws Exception {
-
-        final String code = "package main\n type person struct { PersistentPreRun func(cmd *Command, args []value)//test \n}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        System.out.println(generatedSourceModel.getComponent("main.person.PersistentPreRun").get().codeFragment());
-        assertTrue(generatedSourceModel.getComponent("main.person.PersistentPreRun").get().codeFragment().equals("PersistentPreRun : func(cmd *Command, args []value)"));
-    }
-
-    @Test
-    public void fieldVarFuncTypeCodeFragmentv2() throws Exception {
-
-        final String code = "package main\n type person struct { globNormFunc func(f *flag.FlagSet, name value) flag.NormalizedName }";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        System.out.println(generatedSourceModel.getComponent("main.person.globNormFunc").get().codeFragment());
-        assertTrue(generatedSourceModel.getComponent("main.person.globNormFunc").get().codeFragment().equals("globNormFunc : func(f *flag.FlagSet, name value) flag.NormalizedName"));
-    }
-
-    @Test
-    public void lineNumber() throws Exception {
-
-        final String code = "package main\n import\"fmt\"\n type person struct {\nSuggestFor []value}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.SuggestFor").get().line() == 4);
-        assertTrue(generatedSourceModel.getComponent("main.person").get().line() == 3);
-
-    }
-
     @Test
     public void testStructWithinMethodIgnored() throws Exception {
-
         final String code = "package main\n import\"fmt\"\n func SomeFunc(b []byte) error {\n" +
                 "  var inside struct {\n" +
                 "    Foo value`json:\"foo\"`\n" +
@@ -147,61 +38,10 @@ public void testStructWithinMethodIgnored() throws Exception {
         assertTrue(generatedSourceModel.size() == 0);
     }
 
-    @Test
-    public void testLongImportType() throws Exception {
-
-        final String code = "package main\n import m \"fmt\"\n type person struct {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person").get().imports().get(0).equals("fmt"));
-    }
-
-    @Test
-    public void testResolveTypesComplex() throws Exception {
-
-        final String code = "package main\n import \"html/template\"\n import temp \"text/template\"\n type berry struct {\n person template.Person}";
-        final String codeB = "package template\n type Person struct {}";
-        final String codeC = "package template\n type Person struct {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/github/com/main/person.go", code));
-        rawData.insertFile(new RawFile("/github/com/html/template/person.go", codeB));
-        rawData.insertFile(new RawFile("/github/com/text/template/person.go", codeC));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.berry.person")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).get(0).invokedComponent()
-                .equals("html.template.Person"));
-    }
-
-    @Test
-    public void testImportUsesFullUniquePathIfPossible() throws Exception {
-
-        final String code = "package main\n import g \"github\"\n type person struct {}";
-        final String codeB = "package github";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/main/main.go", code));
-        rawData.insertFile(new RawFile("/src/http/cakes/github/person.go", codeB));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person").get().imports().get(0).equals("http.cakes.github"));
-    }
-
-    @Test
-    public void testDotImportType() throws Exception {
 
-        final String code = "package main\n import . \"fmt\"\n type person struct {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person").get().imports().get(0).equals("fmt"));
-    }
 
     @Test
     public void testParseGoStruct() throws Exception {
-
         final String code = "package main\n import \"fmt\"\n /*test*/ type person struct {}";
         final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
         rawData.insertFile(new RawFile("person.go", code));
@@ -212,7 +52,6 @@ public void testParseGoStruct() throws Exception {
 
     @Test
     public void testParseGoStructs() throws Exception {
-
         final String code = "package main\n import \"fmt\"\n /*test*/ type person struct {} type teacher struct{}";
         final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
         rawData.insertFile(new RawFile("person.go", code));
@@ -224,7 +63,6 @@ public void testParseGoStructs() throws Exception {
 
     @Test
     public void testParseGoInterface() throws Exception {
-
         final String code = "package main\n import \"fmt\"\n /*test*/ type person interface {} type teacher struct{}";
         final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
         rawData.insertFile(new RawFile("person.go", code));
@@ -233,93 +71,8 @@ public void testParseGoInterface() throws Exception {
         assertTrue(generatedSourceModel.containsComponent("main.person"));
         assertTrue(generatedSourceModel.containsComponent("main.teacher"));
     }
-
-    @Test
-    public void testParseGoStructPrivateVisibility() throws Exception {
-
-        final String code = "package main\n import \"fmt\"\n /*test*/ type person struct {} type Teacher struct{}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person").get().modifiers().contains("private"));
-    }
-
-    @Test
-    public void testParseGoInterfacePrivateVisibility() throws Exception {
-
-        final String code = "package main\n import \"fmt\"\n /*test*/ type person interface {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person").get().modifiers().contains("private"));
-    }
-
-    @Test
-    public void testTwoGoStructsReferenceEachOther() throws Exception {
-
-        final String code = "package test \n type person struct {teacher Teacher} \n type Teacher struct{}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("src/github/test/person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("github.test.person.teacher")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).get(0).invokedComponent()
-                .equals("github.test.Teacher"));
-    }
-
-    @Test
-    public void testParseGoStructPublicVisibility() throws Exception {
-
-        final String code = "package main\n import \"fmt\"\n /*test*/ \n type person struct {} type Teacher struct{}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.Teacher").get().modifiers().contains("public"));
-    }
-
-    @Test
-    public void testParseGoInterfacePublicVisibility() throws Exception {
-
-        final String code = "package main\n import \"fmt\"\n /*test*/ type person interface {} type Teacher struct{}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.Teacher").get().modifiers().contains("public"));
-    }
-
-    @Test
-    public void testInterfaceAnonymousTypeMethods() throws Exception {
-
-        final String code = "package main \n type plain interface \n{ testMethodv2() (value, uintptr) {} }";
-        final String codeB = "package main\n type Person struct {}";
-
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/main/plain.go", code));
-        rawData.insertFile(new RawFile("/src/main/test.go", codeB));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.plain.testMethodv2() : (value, uintptr)").get().codeFragment().equals("testMethodv2() : (value, uintptr)"));
-    }
-
-    @Test
-    public void testInterfaceAnonymousTypeMethodParamType() throws Exception {
-
-        final String code = "package main \n type plain interface \n{ testMethodv2(x value, h int) (value, uintptr) {} }";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/main/plain.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.plain.testMethodv2(value, int) : (value, uintptr).x")
-                .get().componentType() == ComponentType.METHOD_PARAMETER_COMPONENT);
-    }
-
     @Test
     public void localVarWithoutTypeDoesNotExist() throws Exception {
-
         final String code = "package main \n type plain struct \n{ func (t plain) testMethodv2(x value, h int) (value, uintptr) {\n a:=\"test\"} }";
         final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
         rawData.insertFile(new RawFile("/src/main/plain.go", code));
@@ -330,7 +83,6 @@ public void localVarWithoutTypeDoesNotExist() throws Exception {
 
     @Test
     public void localVarExists() throws Exception {
-
         final String code = "package main \n type plain struct \n{} \n func (t plain) testMethodv2 () {\n var i int  = 2;\n}";
         final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
         rawData.insertFile(new RawFile("/src/main/plain.go", code));
@@ -341,7 +93,6 @@ public void localVarExists() throws Exception {
 
     @Test
     public void localVarName() throws Exception {
-
         final String code = "package main \n type plain struct \n{} \n func (t plain) testMethodv2 () {\n var i int  = 2;\n}";
         final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
         rawData.insertFile(new RawFile("/src/main/plain.go", code));
@@ -352,7 +103,6 @@ public void localVarName() throws Exception {
 
     @Test
     public void localVarUniqueName() throws Exception {
-
         final String code = "package main \n type plain struct \n{} \n func (t plain) testMethodv2 () {\n var i int  = 2;\n}";
         final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
         rawData.insertFile(new RawFile("/src/main/plain.go", code));
@@ -362,843 +112,132 @@ public void localVarUniqueName() throws Exception {
                 .equals("main.plain.testMethodv2().i"));
     }
 
-    @Test
-    public void localVarComponentType() throws Exception {
-
-        final String code = "package main \n type plain struct \n{} \n func (t plain) testMethodv2 () {\n var i int  = 2;\n}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/main/plain.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(
-                generatedSourceModel.getComponent("main.plain.testMethodv2().i").get().componentType() == ComponentType.LOCAL);
-    }
 
     @Test
-    public void localVarComponentInvocation() throws Exception {
-
-        final String code = "package main \n type plain struct \n{} \n func (t plain) testMethodv2 () {\n var i int  = 2;\n}";
+    public void testInterfaceMethodSpecExists() throws Exception {
+        final String code = "package main\ntype person interface { \n//test\n testMethod() int}";
         final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/main/plain.go", code));
+        rawData.insertFile(new RawFile("person.go", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.plain.testMethodv2().i")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).get(0).invokedComponent().equals("int"));
+        assertTrue(generatedSourceModel.containsComponent("main.person.testMethod() : (int)"));
     }
-
     @Test
-    public void testInterfaceAnonymousTypeMethodParamDeclaration() throws Exception {
-
-        final String code = "package main \n type plain interface \n{ testMethodv2(x string, h int) (string, uintptr) {} }";
+    public void testGoStructFieldVarExists() throws Exception {
+        final String code = "package main\nimport \"test/math\"\ntype person struct {mathObj math.Person}";
         final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/main/plain.go", code));
+        rawData.insertFile(new RawFile("person.go", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.plain.testMethodv2(string, int) : (string, uintptr).x")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).size() == 1);
-        assertTrue(generatedSourceModel.getComponent("main.plain.testMethodv2(string, int) : (string, uintptr).x")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).get(0).invokedComponent().equals("string"));
-        assertTrue(generatedSourceModel.getComponent("main.plain.testMethodv2(string, int) : (string, uintptr).h")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).get(0).invokedComponent().equals("int"));
-        assertTrue(generatedSourceModel.getComponent("main.plain.testMethodv2(string, int) : (string, uintptr).x")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).size() == 1);
+        assertTrue(generatedSourceModel.containsComponent("main.person.mathObj"));
     }
 
     @Test
-    public void testInterfaceAnonymousTypeMethodParamsIsChildOfMethod() throws Exception {
-
-        final String code = "package main \n type plain interface \n{ testMethodv2(x value, h int) (value, uintptr) {} }";
+    public void testGoStructFieldVarComponentName() throws Exception {
+        final String code = "package main\nimport \"test/math\"\ntype person struct {mathObj math.Person}";
         final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/main/plain.go", code));
+        rawData.insertFile(new RawFile("person.go", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.plain.testMethodv2(value, int) : (value, uintptr)").get().children().size() == 2);
-        assertTrue(generatedSourceModel.getComponent("main.plain.testMethodv2(value, int) : (value, uintptr).x")
-                .get().componentType() == ComponentType.METHOD_PARAMETER_COMPONENT);
+        assertTrue(generatedSourceModel.getComponent("main.person.mathObj").get().componentName().equals("person.mathObj"));
     }
 
     @Test
-    public void testParseGoStructImplementsInterface() throws Exception {
-
-        final String codeA = "package main\n import \"github\"\n type person struct {}\n func (p person) someMethod() {}";
-        final String codeB = "package github\n \n type anInterface interface { someMethod();}";
-
+    public void testGoStructFieldVarName() throws Exception {
+        final String code = "package main\nimport \"test/math\"\ntype person struct {mathObj math.Person}";
         final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/main/person.go", codeA));
-        rawData.insertFile(new RawFile("/src/lol/github/aninterface.go", codeB));
+        rawData.insertFile(new RawFile("person.go", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person")
-                .get().componentInvocations(ComponentInvocations.IMPLEMENTATION).get(0).invokedComponent()
-                .equals("lol.github.anInterface"));
+        assertTrue(generatedSourceModel.getComponent("main.person.mathObj").get().name().equals("mathObj"));
     }
 
     @Test
-    public void testParseGoInterfaceDoesNotImplementItself() throws Exception {
-
-        final String codeA = "package main\n import \"github\"\n type person struct {}\n func (p person) someMethod() {}";
-        final String codeB = "package github\n \n type anInterface interface { someMethod();}";
-
+    public void testGoStructSideBySideFieldVars() throws Exception {
+        final String code = "package main\nimport \"test/math\"\ntype person struct {mathObj , secondObj math.Person}";
         final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/main/person.go", codeA));
-        rawData.insertFile(new RawFile("/src/lol/github/aninterface.go", codeB));
+        rawData.insertFile(new RawFile("person.go", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("lol.github.anInterface")
-                .get().componentInvocations(ComponentInvocations.IMPLEMENTATION).size() == 0);
+        assertTrue(generatedSourceModel.containsComponent("main.person.mathObj"));
+        assertTrue(generatedSourceModel.containsComponent("main.person.secondObj"));
     }
 
     @Test
-    public void testParseGoStructImplementsInterfaceComplex() throws Exception {
-
-        final String codeA = "package main\n type person struct {}\n func (p person) someMethod() {}\n"
-                + "func (p* person) methodA() {}\n func (p person) methodB(int, y int, z string) (f,d string) {}";
-        final String codeB = "package github\n \n type anInterface interface { aSecondInterface \n someMethod();}";
-        final String codeC = "package github\n \n type aSecondInterface interface { methodA();\n methodB(x,y int, z string) (f string, d string);";
-
+    public void testGoStructSideBySideFieldVarsInvocations() throws Exception {
+        final String code = "package main\nimport \"test/math\"\ntype person struct {mathObj , secondObj math.Person}";
         final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/main/person.go", codeA));
-        rawData.insertFile(new RawFile("/src/lol/github/aninterface.go", codeB));
-        rawData.insertFile(new RawFile("/src/lol/github/aSecondinterface.go", codeC));
-
+        rawData.insertFile(new RawFile("person.go", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person")
-                .get().componentInvocations(ComponentInvocations.IMPLEMENTATION).size() == 2);
-        assertTrue(generatedSourceModel.getComponent("main.person")
-                .get().componentInvocations(ComponentInvocations.IMPLEMENTATION).get(0).invokedComponent()
-                .equals("lol.github.anInterface"));
-        assertTrue(generatedSourceModel.getComponent("main.person")
-                .get().componentInvocations(ComponentInvocations.IMPLEMENTATION).get(1).invokedComponent()
-                .equals("lol.github.aSecondInterface"));
+        assertTrue(generatedSourceModel.containsComponent("main.person.mathObj"));
+        assertTrue(generatedSourceModel.containsComponent("main.person.secondObj"));
     }
 
     @Test
-    public void testParseGoStructDoesNotImplementSimilarInterfaceByName() throws Exception {
-
-        final String codeA = "package main\n type person struct {}\n func (p person) someMethods() {}\n"
-                + "func (p* person) methodA() {}\n func (p person) methodB(x int, y int, z string) (f,d string) {}";
-        final String codeB = "package github\n \n type anInterface interface { aSecondInterface \n someMethod();}";
-        final String codeC = "package github\n \n type aSecondInterface interface { methodA();\n methodB(x,y int, z string) (f string, d string);}";
-
+    public void testGoStructMethodExists() throws Exception {
+        final String code = "package main\ntype person struct {} \n func (p person) x() int {}";
         final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/main/person.go", codeA));
-        rawData.insertFile(new RawFile("/src/lol/github/aninterface.go", codeB));
-        rawData.insertFile(new RawFile("/src/lol/github/aSecondinterface.go", codeC));
-
+        rawData.insertFile(new RawFile("person.go", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person")
-                .get().componentInvocations(ComponentInvocations.IMPLEMENTATION).size() == 1);
+        assertTrue(generatedSourceModel.containsComponent("main.person.x() : (int)"));
     }
 
     @Test
-    public void testParseGoStructDoesImplementsTwoSeparateInterfaces() throws Exception {
-
-        final String codeA = "package main\n type person struct {}\n func (p person) someMethod() {}\n"
-                + "func (p* person) methodA() {}\n func (p person) methodB(x int, y int, z string) (f,d string) {}";
-        final String codeB = "package github\n \n type anInterface interface {  someMethod();}";
-        final String codeC = "package github\n \n type aSecondInterface interface { methodA();\n methodB(x,y int, z string) (f string, d string);";
-
+    public void testGoStructMethodComponentName() throws Exception {
+        final String code = "package main\ntype person struct {} \n func (p person) x() int {}";
         final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/main/person.go", codeA));
-        rawData.insertFile(new RawFile("/src/lol/github/aninterface.go", codeB));
-        rawData.insertFile(new RawFile("/src/lol/github/aSecondinterface.go", codeC));
-
+        rawData.insertFile(new RawFile("person.go", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person")
-                .get().componentInvocations(ComponentInvocations.IMPLEMENTATION).size() == 2);
-        assertTrue(generatedSourceModel.getComponent("main.person")
-                .get().componentInvocations(ComponentInvocations.IMPLEMENTATION).get(0).invokedComponent()
-                .equals("lol.github.anInterface"));
-        assertTrue(generatedSourceModel.getComponent("main.person")
-                .get().componentInvocations(ComponentInvocations.IMPLEMENTATION).get(1).invokedComponent()
-                .equals("lol.github.aSecondInterface"));
+        assertTrue(generatedSourceModel.getComponent("main.person.x() : (int)").get().componentName().equals("person.x() : (int)"));
     }
 
     @Test
-    public void testParseGoStructExtensionThroughAnonymousType() throws Exception {
-
-        final String code = "package main\n import \"fmt\"\n /*test*/ type person struct {fmt.Math}";
+    public void testGoStructMethodName() throws Exception {
+        final String code = "package main\ntype person struct {} \n func (p person) x() int {}";
         final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
         rawData.insertFile(new RawFile("person.go", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person").get().componentInvocations(ComponentInvocations.EXTENSION)
-                .get(0).invokedComponent().equals("fmt.Math"));
+        assertTrue(generatedSourceModel.getComponent("main.person.x() : (int)").get().name().equals("x"));
     }
 
     @Test
-    public void testParseGoStructMultipleTypesInFieldVar() throws Exception {
-
-        final String code = "package main\n import \"fmt\"\n type person struct {aField map[*fmt.Node]bool}";
+    public void testGoStructMethodSingleParamExists() throws Exception {
+        final String code = "package main\ntype person struct {} \n func (p person) lol(x,y int) {}";
         final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
         rawData.insertFile(new RawFile("person.go", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.aField")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).size() == 2);
-        assertTrue(generatedSourceModel.getComponent("main.person.aField")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).get(0).invokedComponent().equals("fmt.Node"));
-        assertTrue(generatedSourceModel.getComponent("main.person.aField")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).get(1).invokedComponent().equals("bool"));
+        assertTrue(generatedSourceModel.containsComponent("main.person.lol(int, int).x"));
+        assertTrue(generatedSourceModel.containsComponent("main.person.lol(int, int).y"));
     }
 
     @Test
-    public void testPackageImportResolveFunction() throws Exception {
-
-        final String code = "package main\n import \"package/http\"\n type person struct {http.Object}";
-        final String codeB = "package http\n type Object struct{}";
+    public void testGoStructMethodExistsInAnotherSourceFile() throws Exception {
+        final String code = "package main\ntype Person struct {}";
+        final String codeB = "package cakes\n import \"main\" \n func (p main.Person) x() int {}";
         final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("src/custom/package/http/person.go", codeB));
-        rawData.insertFile(new RawFile("/src/custom/main/person.go", code));
+        rawData.insertFile(new RawFile("/src/main/person.go", code));
+        rawData.insertFile(new RawFile("/src/com/cakes/test.go", codeB));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("custom.main.person")
-                .get().componentInvocations(ComponentInvocations.EXTENSION).get(0).invokedComponent()
-                .equals("custom.package.http.Object"));
+        assertTrue(generatedSourceModel.containsComponent("main.Person.x() : (int)"));
     }
 
     @Test
-    public void testPackageImportResolveStructField() throws Exception {
-
-        final String code = "package main\n import zed \"package/http\"\n type person struct {x zed.Object}";
-        final String codeB = "package http\n type Object struct{}";
+    public void testGoStructMethodExistsInAnotherSourceFilev2() throws Exception {
+        final String code = "package main\ntype Person struct {}";
+        final String codeB = "package cakes\n import main \"main\" \n func (p main.Person) x() int {}";
         final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("src/custom/package/http/person.go", codeB));
-        rawData.insertFile(new RawFile("/src/custom/main/person.go", code));
+        rawData.insertFile(new RawFile("/src/main/cherry.go", code));
+        rawData.insertFile(new RawFile("/src/com/cakes/test.go", codeB));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("custom.main.person")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).get(0).invokedComponent()
-                .equals("custom.package.http.Object"));
-    }
-
-    @Test
-    public void testParseGoStructExtensionThroughAnonymousTypePointer() throws Exception {
-
-        final String code = "package main\n import \"fmt\"\n /*test*/ type person struct {*fmt.Math}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person").get().componentInvocations(ComponentInvocations.EXTENSION)
-                .get(0).invokedComponent().equals("fmt.Math"));
-    }
-
-    @Test
-    public void testParsedSingleLineStructDoc() throws Exception {
-
-        final String code = "package main\n //test struct doc\n type person struct {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person").get().comment().equals("test struct doc"));
-    }
-
-    @Test
-    public void testParsMultiLineStructDoc() throws Exception {
-
-        final String code = "package main\n //test struct\n// doc\n type person struct {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person").get().comment().equals("test struct doc"));
-    }
-
-    @Test
-    public void testParseMultiLineInterfaceDoc() throws Exception {
-
-        final String code = "package main\n //test interface\n// doc\n type person interface {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person").get().comment().equals("test interface doc"));
-    }
-
-    @Test
-    public void testParseMultiLineStructDocAfterAnotherStruct() throws Exception {
-
-        final String code = "package main\n type animal struct {}\n//test struct\n// doc\n type person struct {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person").get().comment().equals("test struct doc"));
-    }
-
-    @Test
-    public void testParseMultiLineStructDocSeparatedByEmptyLines() throws Exception {
-
-        final String code = "package main\n//test struct\n// doc\n\n\ntype person struct {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person").get().comment().equals("test struct doc"));
-    }
-
-    @Test
-    public void testParseMultiLineStructDocForInterfaceMethodSpece() throws Exception {
-
-        final String code = "package main\ntype person interface { \n//test\n testMethod() int}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.testMethod() : (int)").get().comment().equals("test"));
-    }
-
-    @Test
-    public void testInterfaceMethodSpecExists() throws Exception {
-
-        final String code = "package main\ntype person interface { \n//test\n testMethod() int}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.containsComponent("main.person.testMethod() : (int)"));
-    }
-
-    @Test
-    public void testInterfaceMethodSpecCodeFragment() throws Exception {
-        final String code = "package main\ntype person interface { testMethod() int}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.testMethod() : (int)").get().codeFragment().equals("testMethod() : (int)"));
-    }
-
-    @Test
-    public void testInterfaceComplexMethodSpecParamsExist() throws Exception {
-        final String code = "package go\n import \"org\" \n type person interface { testMethod() org.Cake}";
-        final String codeB = "package org\n type Cake struct {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("src/github/go/person.go", code));
-        rawData.insertFile(new RawFile("src/github/game/org/cakes.go", codeB));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("github.go.person.testMethod() : (org.Cake)").get().codeFragment()
-                .equals("testMethod() : (org.Cake)"));
-    }
-
-    @Test
-    public void testInterfaceMethodSpecComponentType() throws Exception {
-
-        final String code = "package main\ntype person interface { \n//test\n testMethod() int}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.testMethod() : (int)").get().componentType() == ComponentType.METHOD);
-    }
-
-    @Test
-    public void testInterfaceMethodSpecComponentIsChildOfParentInterface() throws Exception {
-
-        final String code = "package main\ntype person interface { \n//test\n testMethod() int}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person").get().children().get(0).equals("main.person.testMethod() : (int)"));
-    }
-
-    @Test
-    public void testInterfaceAnonymousTypeExtends() throws Exception {
-
-        final String code = "package main \n type plain interface \n{testMethod() int\n Person\n testMethodv2() (string, uintptr) {} }";
-        final String codeB = "package main\n type Person struct {}";
-
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/main/plain.go", code));
-        rawData.insertFile(new RawFile("/src/main/test.go", codeB));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.plain").get().componentInvocations(ComponentInvocations.EXTENSION)
-                .get(0).invokedComponent().equals("main.Person"));
-        assertTrue(generatedSourceModel.getComponent("main.plain.testMethodv2() : (string, uintptr)").get().codeFragment().equals("testMethodv2() : (string, uintptr)"));
-    }
-
-    @Test
-    public void testParseSingleLineStructDocSeparatedByEmptyLines() throws Exception {
-
-        final String code = "package main\n//test struct doc\n\n\n\ntype person struct {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person").get().comment().equals("test struct doc"));
-    }
-
-    @Test
-    public void testGoStructHasCorrectSourceFileAttr() throws Exception {
-        final String code = "package main\ntype person struct {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person").get().sourceFile().equals("person.go"));
-    }
-
-    @Test
-    public void testGoStructHasCorrectComponentType() throws Exception {
-        final String code = "package main\ntype person struct {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person").get().componentType() == ComponentType.STRUCT);
-    }
-
-    @Test
-    public void testGoStructFieldVarExists() throws Exception {
-        final String code = "package main\nimport \"test/math\"\ntype person struct {mathObj math.Person}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.containsComponent("main.person.mathObj"));
-    }
-
-    @Test
-    public void testGoStructFieldVarInvocation() throws Exception {
-        final String code = "package main\nimport \"test/math\"\ntype person struct {mathObj math.Person}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.mathObj")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).get(0).invokedComponent()
-                .equals("test.math.Person"));
-    }
-
-    @Test
-    public void testGoStructFieldVarComponentName() throws Exception {
-        final String code = "package main\nimport \"test/math\"\ntype person struct {mathObj math.Person}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.mathObj").get().componentName().equals("person.mathObj"));
-    }
-
-    @Test
-    public void testGoStructFieldVarComponenType() throws Exception {
-        final String code = "package main\nimport \"test/math\"\ntype person struct {mathObj math.Person}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.mathObj").get().componentType() == ComponentType.FIELD);
-    }
-
-    @Test
-    public void testGoStructFieldVarPrivateVisibility() throws Exception {
-        final String code = "package main\nimport \"test/math\"\ntype person struct {mathObj math.Person}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.mathObj").get().modifiers().contains("private"));
-    }
-
-    @Test
-    public void testGoStructFieldVarPublicVisibility() throws Exception {
-        final String code = "package main\nimport \"test/math\"\ntype person struct {MathObj math.Person}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.MathObj").get().modifiers().contains("public"));
-    }
-
-    @Test
-    public void testGoStructFieldVarName() throws Exception {
-        final String code = "package main\nimport \"test/math\"\ntype person struct {mathObj math.Person}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.mathObj").get().name().equals("mathObj"));
-    }
-
-    @Test
-    public void testGoStructSideBySideFieldVars() throws Exception {
-        final String code = "package main\nimport \"test/math\"\ntype person struct {mathObj , secondObj math.Person}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.containsComponent("main.person.mathObj"));
-        assertTrue(generatedSourceModel.containsComponent("main.person.secondObj"));
-    }
-
-    @Test
-    public void testGoStructSideBySideFieldVarsInvocations() throws Exception {
-        final String code = "package main\nimport \"test/math\"\ntype person struct {mathObj , secondObj math.Person}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.containsComponent("main.person.mathObj"));
-        assertTrue(generatedSourceModel.containsComponent("main.person.secondObj"));
-    }
-
-    @Test
-    public void testGoStructFIeldVarIsChildOfStruct() throws Exception {
-        final String code = "package main\nimport \"test/math\"\ntype person struct {mathObj math.Person}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person").get().children().get(0).equals("main.person.mathObj"));
-    }
-
-    @Test
-    public void testGoStructMethodExists() throws Exception {
-        final String code = "package main\ntype person struct {} \n func (p person) x() int {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.containsComponent("main.person.x() : (int)"));
-    }
-
-    @Test
-    public void testParseGoStructMethodWithUnnamedParameters() throws Exception {
-        final String code = "package main\ntype person struct {} \n func (p person) x(string) () {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.x(string)").get().children().size() == 1);
-    }
-
-    @Test
-    public void testGoStructMethodComponentType() throws Exception {
-        final String code = "package main\ntype person struct {} \n func (p person) x() int {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.x() : (int)").get().componentType() == ComponentType.METHOD);
-    }
-
-    @Test
-    public void testGoStructMethodComponentName() throws Exception {
-        final String code = "package main\ntype person struct {} \n func (p person) x() int {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.x() : (int)").get().componentName().equals("person.x() : (int)"));
-    }
-
-    @Test
-    public void testGoStructMethodName() throws Exception {
-        final String code = "package main\ntype person struct {} \n func (p person) x() int {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.x() : (int)").get().name().equals("x"));
-    }
-
-    @Test
-    public void testGoStructMethodComment() throws Exception {
-        final String code = "package main\ntype person struct {}\n\n //test \n //test\n\nfunc (p person) x() int {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.x() : (int)").get().comment().equals("test test"));
-    }
-
-    @Test
-    public void testGoStructMethodDocComment() throws Exception {
-        final String code = "package main\ntype person struct {}\n\n //test \n //test\n\nfunc (p person) x() int {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.x() : (int)").get().comment().equals("test test"));
-    }
-
-    @Test
-    public void testGoStructMethodIsChildofStruct() throws Exception {
-        final String code = "package main\ntype person struct {} \n func (p person) x() int {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person").get().children().contains("main.person.x() : (int)"));
-    }
-
-    @Test
-    public void testMethodCode() throws Exception {
-        final String code = "package main\n import (\n\"math\"\n)\n type person struct {} \n func (p person) x(i uint64) int { math.MaxUint32 \n }";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.x(uint64) : (int)").get().code().equals("func (p person) x(i uint64) int { math.MaxUint32 \n" +
-                " }"));
-    }
-
-    @Test
-    public void testGoStructMethodPackageNameEqualsParentsPackageName() throws Exception {
-        final String code = "package main\ntype person struct {} \n func (p person) x() int {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("src/main/person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person").get().packageName()
-                .equals(generatedSourceModel.getComponent("main.person.x() : (int)").get().packageName()));
-    }
-
-    @Test
-    public void testGoStructMethodSingleParamExists() throws Exception {
-        final String code = "package main\ntype person struct {} \n func (p person) lol(x,y int) {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.containsComponent("main.person.lol(int, int).x"));
-        assertTrue(generatedSourceModel.containsComponent("main.person.lol(int, int).y"));
-    }
-
-    @Test
-    public void testGoStructMethodSingleParamComponentType() throws Exception {
-        final String code = "package main\ntype person struct {} \n func (p person) lol(x int) {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.lol(int).x")
-                .get().componentType() == ComponentType.METHOD_PARAMETER_COMPONENT);
-    }
-
-    @Test
-    public void testGoStructMethodSingleParamComponentIsChildOfMethod() throws Exception {
-        final String code = "package main\ntype person struct {} \n func (p person) lol(x int) {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.lol(int)").get().children().get(0).equals("main.person.lol(int).x"));
-    }
-
-    @Test
-    public void testGoStructMethodSingleParamComponentInvocation() throws Exception {
-        final String code = "package main\ntype person struct {} \n func (p person) lol(x int) {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.lol(int).x")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).get(0).invokedComponent().equals("int"));
-    }
-
-    @Test
-    public void testGoStructMethodTripleParamComponentInvocation() throws Exception {
-        final String codeB = "package http\ntype httpcakes struct {}";
-        final String code = "package main\nimport \"http\"\ntype person struct {} \n func (p person) lol(x,y int, z *http.httpcakes) {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("src/main/person.go", code));
-        rawData.insertFile(new RawFile("src/github/http/http.go", codeB));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.lol(int, int, *http.httpcakes).x")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).get(0).invokedComponent().equals("int"));
-        assertTrue(generatedSourceModel.getComponent("main.person.lol(int, int, *http.httpcakes).y")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).get(0).invokedComponent().equals("int"));
-        assertTrue(generatedSourceModel.getComponent("main.person.lol(int, int, *http.httpcakes).z")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).get(0).invokedComponent()
-                .equals("github.http.httpcakes"));
-    }
-
-    @Test
-    public void testGoStructMethodSingleParamUniqueNameComplex() throws Exception {
-        final String code = "package main\ntype Person struct {}";
-        final String codeB = "package main\n import tester \"test/main\" \n func (p tester.Person) x(v1,v2 tester.Person) {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/test/main/cherry.go", code));
-        rawData.insertFile(new RawFile("/src/main/test.go", codeB));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("test.main.Person.x(tester.Person, tester.Person).v1").get().packageName().equals("test.main"));
-        assertTrue(generatedSourceModel.getComponent("test.main.Person.x(tester.Person, tester.Person).v2")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).get(0).invokedComponent()
-                .equals("test.main.Person"));
-        assertTrue(generatedSourceModel.getComponent("test.main.Person.x(tester.Person, tester.Person)").get().children().size() == 2);
-        assertTrue(generatedSourceModel.getComponent("test.main.Person.x(tester.Person, tester.Person)").get().children().get(0)
-                .equals("test.main.Person.x(tester.Person, tester.Person).v1"));
-    }
-
-    @Test
-    public void testGoStructMethodExistsInAnotherSourceFile() throws Exception {
-        final String code = "package main\ntype Person struct {}";
-        final String codeB = "package cakes\n import \"main\" \n func (p main.Person) x() int {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/main/person.go", code));
-        rawData.insertFile(new RawFile("/src/com/cakes/test.go", codeB));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.containsComponent("main.Person.x() : (int)"));
-    }
-
-    @Test
-    public void testGoStructMethodExistsInAnotherSourceFilev2() throws Exception {
-        final String code = "package main\ntype Person struct {}";
-        final String codeB = "package cakes\n import main \"main\" \n func (p main.Person) x() int {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/main/cherry.go", code));
-        rawData.insertFile(new RawFile("/src/com/cakes/test.go", codeB));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.containsComponent("main.Person.x() : (int)"));
-        assertTrue(generatedSourceModel.containsComponent("main.Person"));
-    }
-
-    @Test
-    public void testGoStructMethodCodeFragment() throws Exception {
-        final String code = "package main\ntype Person struct {}";
-        final String codeB = "package main\n import tester \"main\" \n func (p tester.Person) x() int {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/main/cherry.go", code));
-        rawData.insertFile(new RawFile("/src/com/cakes/test.go", codeB));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        System.out.println(generatedSourceModel.getComponent("main.Person.x() : (int)").get().codeFragment());
-        assertTrue(generatedSourceModel.getComponent("main.Person.x() : (int)").get().codeFragment().equals("x() : (int)"));
-    }
-
-    @Test
-    public void testGoStructMethodSpecCodeFragment() throws Exception {
-        final String code = "package main\ntype Person interface {  Get(key interface{}) (value interface{}, ok bool) }";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/main/cherry.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        System.out.println(generatedSourceModel.getComponent("main.Person.Get(interface{}) : (interface{}, bool)").get().codeFragment());
-        assertTrue(generatedSourceModel.getComponent("main.Person.Get(interface{}) : (interface{}, bool)").get().codeFragment().equals("Get(interface{}) : (interface{}, bool)"));
-    }
-
-    @Test
-    public void testGoStructMethodWithFuncAsParamCodeFragment() throws Exception {
-        final String code = "package main\ntype Person struct {  func (c *Person) SetGlobalNormalizationFunc(n func(f *flag.FlagSet, name value)) {} }";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/main/cherry.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        System.out.println(generatedSourceModel.getComponent("main.Person.SetGlobalNormalizationFunc(func(f *flag.FlagSet, name value))").get().codeFragment());
-        assertTrue(generatedSourceModel.getComponent("main.Person.SetGlobalNormalizationFunc(func(f *flag.FlagSet, name value))").get().codeFragment()
-                .equals("SetGlobalNormalizationFunc(func(f *flag.FlagSet, name value))"));
-    }
-
-    @Test
-    public void testGoInterfaceMethodWithFuncAsParamCodeFragment() throws Exception {
-        final String code = "package main\ntype Person interface {  func SetGlobalNormalizationFunc(n func(f *flag.FlagSet, name value)) }";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/main/cherry.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        System.out.println(generatedSourceModel.getComponent("main.Person.SetGlobalNormalizationFunc(func(f *flag.FlagSet, name value))").get().codeFragment());
-        assertTrue(generatedSourceModel.getComponent("main.Person.SetGlobalNormalizationFunc(func(f *flag.FlagSet, name value))").get().codeFragment()
-                .equals("SetGlobalNormalizationFunc(func(f *flag.FlagSet, name value))"));
-
-        assertTrue(generatedSourceModel.getComponent("main.Person.SetGlobalNormalizationFunc(func(f *flag.FlagSet, name value))").get().parentUniqueName()
-                .equals("main.Person"));
-    }
-
-    @Test
-    public void testGoStructMethodWithFuncAsReturnCodeFragment() throws Exception {
-        final String code = "package main\ntype Person struct {  func (c *Person) SetGlobalNormalizationFunc(n int) (func(f *flag.FlagSet, name value)) {} }";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/main/cherry.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.Person.SetGlobalNormalizationFunc(int) : (func(f *flag.FlagSet, name value))").get().codeFragment().equals(
-                "SetGlobalNormalizationFunc(int) : (func(f *flag.FlagSet, name value))"));
-    }
-
-    @Test
-    public void testGoStructMethodWithFuncAsPartOfReturnCodeFragment() throws Exception {
-        final String code = "package main\ntype Person struct {  func (c *Person) SetGlobalNormalizationFunc(n int) (x int, func(f *flag.FlagSet, name value)) {} }";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/main/cherry.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.Person.SetGlobalNormalizationFunc(int) : (int, func(f *flag.FlagSet, name value))").get().codeFragment().equals(
-                "SetGlobalNormalizationFunc(int) : (int, func(f *flag.FlagSet, name value))"));
-    }
-
-    @Test
-    public void testGoStructMethodMultipleDeclarationReturnCodeFragment() throws Exception {
-        final String code = "package main\ntype Person struct {}";
-        final String codeB = "package main\n import tester \"main\" \n func (p tester.Person) x() (x,y int) {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/main/cherry.go", code));
-        rawData.insertFile(new RawFile("/src/com/cakes/test.go", codeB));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.Person.x() : (int, int)").get().codeFragment().equals("x() : (int, int)"));
-    }
-
-    @Test
-    public void testGoStructMethodMultipleIndividualDeclarationReturnCodeFragment() throws Exception {
-        final String code = "package main\ntype Person struct {}";
-        final String codeB = "package main\n import tester \"main\" \n func (p tester.Person) x() (x uint8,y int) {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/main/cherry.go", code));
-        rawData.insertFile(new RawFile("/src/com/cakes/test.go", codeB));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        System.out.println(generatedSourceModel.getComponent("main.Person.x() : (uint8, int)").get().codeFragment());
-        assertTrue(generatedSourceModel.getComponent("main.Person.x() : (uint8, int)").get().codeFragment().equals("x() : (uint8, int)"));
-    }
-
-    @Test
-    public void testGoStructMethodMultipleComplexDeclarationReturnCodeFragment() throws Exception {
-        final String code = "package main\ntype Person struct {}";
-        final String codeB = "package main\n import tester \"main\" \n func (p tester.Person) x() (x,z uint8, y int) {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/main/cherry.go", code));
-        rawData.insertFile(new RawFile("/src/com/cakes/test.go", codeB));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.Person.x() : (uint8, uint8, int)").get().codeFragment().equals("x() : (uint8, uint8, int)"));
-    }
-
-    @Test
-    public void testGoStructMethodMultipleReturnCodeFragment() throws Exception {
-        final String code = "package main\ntype Person struct {}";
-        final String codeB = "package main\n import tester \"main\" \n func (p tester.Person) x() (value, int) {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/main/cherry.go", code));
-        rawData.insertFile(new RawFile("/src/com/cakes/test.go", codeB));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.Person.x() : (value, int)").get().codeFragment().equals("x() : (value, int)"));
-    }
-
-    @Test
-    public void testGoNoReturnStructMethodCodeFragmentIsNull() throws Exception {
-        final String code = "package main\ntype Person struct {}";
-        final String codeB = "package main\n import tester \"main\" \n func (p main.Person) x() {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/main/cherry.go", code));
-        rawData.insertFile(new RawFile("/src/com/cakes/test.go", codeB));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        System.out.println(generatedSourceModel.getComponent("main.Person.x()").get().codeFragment());
-        assertTrue(generatedSourceModel.getComponent("main.Person.x()").get().codeFragment().equals("x()"));
+        assertTrue(generatedSourceModel.containsComponent("main.Person.x() : (int)"));
+        assertTrue(generatedSourceModel.containsComponent("main.Person"));
     }
 
     @Test
@@ -1213,132 +252,4 @@ public void structMethodInDifferentSourceFileInSamePackage() throws Exception {
         assertTrue(generatedSourceModel.containsComponent("main.Person.x(value) : ([]value)"));
         assertTrue(generatedSourceModel.containsComponent("main.Person.x(value) : ([]value).y"));
     }
-
-    @Test
-    public void testGoReturnStructMethodComplexCodeFragment() throws Exception {
-        final String code = "package main\ntype Person struct {}";
-        final String codeB = "package main\n import tester \"main\" \n func (p main.Person) x(args []value, x,y map[value]value, v, u value) (j,i []value, map[value]value.test)  {}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("/src/main/cherry.go", code));
-        rawData.insertFile(new RawFile("/src/com/cakes/test.go", codeB));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        System.out.println(generatedSourceModel.getComponent("main.Person.x([]value, map[value]value, map[value]value, value, value) : ([]value, []value, map[value]value.test)").get().codeFragment());
-        assertTrue(generatedSourceModel.getComponent("main.Person.x([]value, map[value]value, map[value]value, value, value) : ([]value, []value, map[value]value.test)").get().codeFragment().equals("x([]value, map[value]value, map[value]value, value, value) : ([]value, []value, map[value]value.test)"));
-        assertTrue(generatedSourceModel.getComponent("main.Person.x([]value, map[value]value, map[value]value, value, value) : ([]value, []value, map[value]value.test).u")
-                .get().parentUniqueName().equals("main.Person.x([]value, map[value]value, map[value]value, value, value) : ([]value, []value, map[value]value.test)"));
-        assertTrue(generatedSourceModel.getComponent("main.Person.x([]value, map[value]value, map[value]value, value, value) : ([]value, []value, map[value]value.test)")
-                .get().parentUniqueName().equals("main.Person"));
-    }
-
-    @Test
-    public void testGoMethodComplexity() throws Exception {
-        final String code = "package main\ntype person struct {} \n " +
-                "func (p person) x() int {" +
-                "    for i := 0; i < 10; i++ {\n" +
-                "      if 7%2 == 0 && true {\n" +
-                "        // && || \n" +
-                "        fmt.Println(\"7 is even\")\n" +
-                "    } else {\n" +
-                "        fmt.Println(\"7 is odd\")\n" +
-                "    } \n " +
-                "   }" +
-                "}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.x() : (int)").get().cyclo() == 4);
-    }
-
-    @Test
-    public void testGoInterfaceMethodComplexity() throws Exception {
-
-        final String code = "package main\n type person interface {\n area() float64 \n} type teacher struct{}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.area() : (float64)")
-                .get()
-                .cyclo() == 0);
-    }
-
-    @Test
-    public void testGoMethodExprSwitchComplexity() throws Exception {
-        final String code = "package main\ntype person struct {} \n func (p person) x() int { " +
-                "switch os := runtime.GOOS; os {\n" +
-                "case \"darwin\":\n" +
-                "fmt.Println(\"OS X.\")\n" +
-                "case \"linux\":\n" +
-                "fmt.Println(\"Linux.\")\n" +
-                "default:\n" +
-                "// freebsd, openbsd,\n" +
-                "// plan9, windows...\n" +
-                "fmt.Printf(\"%s.\", os)\n" +
-                "}" +
-                "}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.x() : (int)").get().cyclo() == 3);
-    }
-
-    @Test
-    public void testGoMethodTypeSwitchComplexity() throws Exception {
-        final String code = "package main\nimport \"fmt\"\ntype person struct {} \n func (p person) x() int { " +
-                "switch v := i.(type) {\n" +
-                "case int:\n" +
-                "fmt.Printf(\"Twice %v is %v\\n\", v, v*2)\n" +
-                "case string:\n" +
-                "fmt.Printf(\"%q is %v bytes long\\n\", v, len(v))\n" +
-                "default:\n" +
-                "fmt.Printf(\"I don't know about type %T!\\n\", v)\n" +
-                "}" +
-                "}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person.x() : (int)").get().cyclo() == 3);
-    }
-
-    @Test
-    public void testGoStructComplexity() throws Exception {
-        final String code = "package main\nimport \"fmt\"\ntype person struct {} \n " +
-                "func (p person) x() int { " +
-                "switch v := i.(type) {\n" +
-                "case int:\n" +
-                "fmt.Printf(\"Twice %v is %v\\n\", v, v*2)\n" +
-                "case string:\n" +
-                "fmt.Printf(\"%q is %v bytes long\\n\", v, len(v))\n" +
-                "default:\n" +
-                "fmt.Printf(\"I don't know about type %T!\\n\", v)\n" +
-                "}" +
-                "func (p person) z() int {" +
-                "    if 7%2 == 0 && true {\n" +
-                "        // && || \n" +
-                "        fmt.Println(\"7 is even\")\n" +
-                "    } else {\n" +
-                "        fmt.Println(\"7 is odd\")\n" +
-                "    } " +
-                "}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person").get().cyclo() == 3);
-    }
-
-    @Test
-    public void testGoEmptyStructComplexity() throws Exception {
-        final String code = "package main\nimport \"fmt\"\ntype person struct {} \n " +
-                "}";
-        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
-        rawData.insertFile(new RawFile("person.go", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("main.person").get().cyclo() == 0);
-    }
 }
diff --git a/clarpse/src/test/java/com/clarity/test/go/GoLangSmokeTest.java b/clarpse/src/test/java/com/clarity/test/go/GoLangSmokeTest.java
index c698c9b..0a801be 100644
--- a/clarpse/src/test/java/com/clarity/test/go/GoLangSmokeTest.java
+++ b/clarpse/src/test/java/com/clarity/test/go/GoLangSmokeTest.java
@@ -2,7 +2,7 @@
 
 import com.clarity.compiler.Lang;
 import com.clarity.sourcemodel.OOPSourceCodeModel;
-import com.clarity.sourcemodel.OOPSourceModelConstants.ComponentInvocations;
+import com.clarity.sourcemodel.OOPSourceModelConstants.TypeReferences;
 import com.clarity.test.ClarpseTestUtil;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -31,7 +31,7 @@ public void spotCheckIntefacev2() {
     @Test
     public void spotCheckStructImplementsInterface() {
         assertTrue(generatedSourceModel.getComponent("pilot.platform.eureka.serviceAccounts")
-                .get().componentInvocations(ComponentInvocations.IMPLEMENTATION).get(0).invokedComponent()
+                .get().references(TypeReferences.IMPLEMENTATION).get(0).invokedComponent()
                 .equals("pilot.model.ServiceAccounts"));
     }
 
@@ -77,20 +77,20 @@ public void spotCheckStructv2() {
     @Test
     public void spotCheckStructExtension() {
         assertTrue(generatedSourceModel.getComponent("tests.integration.environment.AppOnlyEnv")
-                .get().componentInvocations(ComponentInvocations.EXTENSION).get(0).invokedComponent()
+                .get().references(TypeReferences.EXTENSION).get(0).invokedComponent()
                 .equals("tests.integration.framework.TestEnv"));
     }
 
     @Test
-    public void spotCheckStructComponentInvocations() {
-        assertTrue(generatedSourceModel.getComponent("mixer.pkg.pool.GoroutinePool").get().invocations().toString().equals(
-                "[TypeDeclaration:mixer.pkg.pool.WorkFunc, TypeDeclaration:sync.WaitGroup, TypeDeclaration:bool, TypeDeclaration:int]"));
+    public void spotCheckStructcomponentReferences() {
+        assertTrue(generatedSourceModel.getComponent("mixer.pkg.pool.GoroutinePool").get().references().toString().equals(
+                "[SimpleTypeReference:mixer.pkg.pool.WorkFunc, SimpleTypeReference:sync.WaitGroup, SimpleTypeReference:bool, SimpleTypeReference:int]"));
     }
 
     @Test
-    public void spotCheckStructComponentInvocationsv2() {
-        assertTrue(generatedSourceModel.getComponent("mixer.pkg.aspect.quotasExecutor").get().invocations().toString().equals(
-                "[TypeDeclaration:mixer.pkg.aspect.quotasManager, TypeDeclaration:mixer.pkg.adapter.QuotasAspect, TypeDeclaration:string, TypeDeclaration:mixer.pkg.aspect.quotaInfo, TypeDeclaration:mixer.pkg.attribute.Bag, TypeDeclaration:mixer.pkg.expr.Evaluator, TypeDeclaration:mixer.pkg.aspect.QuotaMethodArgs, TypeDeclaration:mixer.pkg.adapter.QuotaResultLegacy, TypeImplementation:mixer.pkg.aspect.QuotaExecutor]"));
+    public void spotCheckStructcomponentReferencesv2() {
+        assertTrue(generatedSourceModel.getComponent("mixer.pkg.aspect.quotasExecutor").get().references().toString().equals(
+                "[SimpleTypeReference:mixer.pkg.aspect.quotasManager, SimpleTypeReference:mixer.pkg.adapter.QuotasAspect, SimpleTypeReference:string, SimpleTypeReference:mixer.pkg.aspect.quotaInfo, SimpleTypeReference:mixer.pkg.attribute.Bag, SimpleTypeReference:mixer.pkg.expr.Evaluator, SimpleTypeReference:mixer.pkg.aspect.QuotaMethodArgs, SimpleTypeReference:mixer.pkg.adapter.QuotaResultLegacy]"));
     }
 
     @Test
diff --git a/clarpse/src/test/java/com/clarity/test/go/InheritanceReferenceTest.java b/clarpse/src/test/java/com/clarity/test/go/InheritanceReferenceTest.java
new file mode 100644
index 0000000..21e026d
--- /dev/null
+++ b/clarpse/src/test/java/com/clarity/test/go/InheritanceReferenceTest.java
@@ -0,0 +1,78 @@
+package com.clarity.test.go;
+
+import com.clarity.compiler.ClarpseProject;
+import com.clarity.compiler.Lang;
+import com.clarity.compiler.RawFile;
+import com.clarity.compiler.SourceFiles;
+import com.clarity.sourcemodel.OOPSourceCodeModel;
+import com.clarity.sourcemodel.OOPSourceModelConstants;
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+
+/**
+ * Ensure component invocations for a given component are inherited by its
+ * parents.
+ */
+public class InheritanceReferenceTest {
+
+    @Test
+    public void StructInheritsFieldVarInvocations() throws Exception {
+        final String code = "package main\nimport \"test/math\"\ntype person struct {mathObj math.Person}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/plain.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0)
+                .invokedComponent().equals("test.math.Person"));
+    }
+
+    @Test
+    public void StructMethodInheritsLocalVarInvocations() throws Exception {
+        final String code = "package main\nimport \"test/math\"\ntype person struct {} func (p person) x() int {var mathObj math.Person}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/plain.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person.x() : (int)")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0)
+                .invokedComponent().equals("test.math.Person"));
+    }
+
+    @Test
+    public void StructMethodInheritsMethodParamInvocations() throws Exception {
+        final String code = "package main\nimport \"test/math\"\ntype person struct {} func (p person) x(mathObj math.Person) int {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/plain.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person.x(math.Person) : (int)")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0)
+                .invokedComponent().equals("test.math.Person"));
+    }
+
+    @Test
+    public void StructInheritsLocalVarInvocations() throws Exception {
+        final String code = "package main\nimport \"test/math\"\ntype person struct {} func (p person) x() int {var mathObj math.Person}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/plain.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0)
+                .invokedComponent().equals("test.math.Person"));
+    }
+
+    @Test
+    public void StructInheritsMethodParamInvocations() throws Exception {
+        final String code = "package main\nimport \"test/math\"\ntype person struct {} func (p person) x(mathObj math.Person) int {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/plain.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0)
+                .invokedComponent().equals("test.math.Person"));
+    }
+}
diff --git a/clarpse/src/test/java/com/clarity/test/go/PackageAttributeTest.java b/clarpse/src/test/java/com/clarity/test/go/PackageAttributeTest.java
new file mode 100644
index 0000000..dfb37fb
--- /dev/null
+++ b/clarpse/src/test/java/com/clarity/test/go/PackageAttributeTest.java
@@ -0,0 +1,70 @@
+package com.clarity.test.go;
+
+import com.clarity.compiler.ClarpseProject;
+import com.clarity.compiler.Lang;
+import com.clarity.compiler.RawFile;
+import com.clarity.compiler.SourceFiles;
+import com.clarity.sourcemodel.Component;
+import com.clarity.sourcemodel.OOPSourceCodeModel;
+import org.junit.Assert;
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+
+/**
+ * Tests to ensure package name attribute of parsed components are correct.
+ */
+public class PackageAttributeTest {
+
+    @Test
+    public void testGoStructMethodPackageName() throws Exception {
+        final String code = "package main\ntype person struct {} \n func (p person) x() int {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("src/main/person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person").get().packageName()
+                .equals(generatedSourceModel.getComponent("main.person.x() : (int)").get().packageName()));
+    }
+
+    @Test
+    public void testGoStructMethodParamPackageName() throws Exception {
+        final String code = "package main\ntype person struct {} \n func (p person) x(z int) int {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("src/main/person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person.x(int) : (int).z").get().packageName().equals("main"));
+    }
+
+    @Test
+    public void testGoStructMethodLocalVarPackageName() throws Exception {
+        final String code = "package main\ntype person struct {} \n func (p person) x() int {var z int}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("src/main/person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person.x() : (int).z").get().packageName().equals("main"));
+    }
+
+    @Test
+    public void testGoInterfacePackageName() throws Exception {
+        final String code = "package main\ntype person interface {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("src/main/person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person").get().packageName()
+                .equals("main"));
+    }
+
+    @Test
+    public void testGoStructPackageName() throws Exception {
+        final String code = "package main\ntype person struct {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person").get().packageName().equals("main"));
+    }
+}
diff --git a/clarpse/src/test/java/com/clarity/test/go/ResolveImportsTest.java b/clarpse/src/test/java/com/clarity/test/go/ResolveImportsTest.java
new file mode 100644
index 0000000..4f820ce
--- /dev/null
+++ b/clarpse/src/test/java/com/clarity/test/go/ResolveImportsTest.java
@@ -0,0 +1,54 @@
+package com.clarity.test.go;
+
+import com.clarity.compiler.ClarpseProject;
+import com.clarity.compiler.Lang;
+import com.clarity.compiler.RawFile;
+import com.clarity.compiler.SourceFiles;
+import com.clarity.sourcemodel.OOPSourceCodeModel;
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+
+public class ResolveImportsTest {
+    @Test
+    public void testShortImportType() throws Exception {
+        final String code = "package main\n import\"fmt\"\n type person struct {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person").get().imports().get(0).equals("fmt"));
+    }
+
+    @Test
+    public void testLongImportType() throws Exception {
+        final String code = "package main\n import m \"fmt\"\n type person struct {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person").get().imports().get(0).equals("fmt"));
+    }
+
+    @Test
+    public void testImportUsesFullUniquePathIfPossible() throws Exception {
+        final String code = "package main\n import g \"github\"\n type person struct {}";
+        final String codeB = "package github";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("/src/main/main.go", code));
+        rawData.insertFile(new RawFile("/src/http/cakes/github/person.go", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person").get().imports().get(0).equals("http.cakes.github"));
+    }
+
+    @Test
+    public void testDotImportType() throws Exception {
+        final String code = "package main\n import . \"fmt\"\n type person struct {}";
+        final SourceFiles rawData = new SourceFiles(Lang.GOLANG);
+        rawData.insertFile(new RawFile("person.go", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("main.person").get().imports().get(0).equals("fmt"));
+    }
+}
diff --git a/clarpse/src/test/java/com/clarity/test/java/AccessModifiersTest.java b/clarpse/src/test/java/com/clarity/test/java/AccessModifiersTest.java
index 40a9eb4..4c7c699 100644
--- a/clarpse/src/test/java/com/clarity/test/java/AccessModifiersTest.java
+++ b/clarpse/src/test/java/com/clarity/test/java/AccessModifiersTest.java
@@ -97,7 +97,7 @@ public void testFieldVarLevelModifier() throws Exception {
     }
 
     @Test
-    public void testLocalVarLevelModifier() throws Exception {
+    public void testMethodParamLevelModifier() throws Exception {
 
         final String code = "public class Test { Test(final String str){} }";
         final SourceFiles rawData = new SourceFiles(Lang.JAVA);
@@ -108,4 +108,28 @@ public void testLocalVarLevelModifier() throws Exception {
                 ((String) generatedSourceModel.getComponent("Test.Test(String).str").get().modifiers().toArray()[0])
                         .equalsIgnoreCase("final"));
     }
+
+    @Test
+    public void testMethodLocalVarLevelModifier() throws Exception {
+
+        final String code = "public class Test { Test(){ final String str;} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVA);
+        rawData.insertFile(new RawFile("file2.java", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(
+                generatedSourceModel.getComponent("Test.Test().str").get().modifiers().size() == 1);
+    }
+
+    @Test
+    public void testMethodLocalVarLevelNoModifier() throws Exception {
+
+        final String code = "public class Test { Test(){ String str;} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVA);
+        rawData.insertFile(new RawFile("file2.java", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(
+                generatedSourceModel.getComponent("Test.Test().str").get().modifiers().isEmpty());
+    }
 }
diff --git a/clarpse/src/test/java/com/clarity/test/java/AnnotationInvocationTest.java b/clarpse/src/test/java/com/clarity/test/java/AnnotationInvocationTest.java
deleted file mode 100644
index 4a1f837..0000000
--- a/clarpse/src/test/java/com/clarity/test/java/AnnotationInvocationTest.java
+++ /dev/null
@@ -1,166 +0,0 @@
-package com.clarity.test.java;
-
-import com.clarity.compiler.ClarpseProject;
-import com.clarity.compiler.Lang;
-import com.clarity.compiler.RawFile;
-import com.clarity.compiler.SourceFiles;
-import com.clarity.invocation.AnnotationInvocation;
-import com.clarity.invocation.ComponentInvocation;
-import com.clarity.sourcemodel.OOPSourceCodeModel;
-import com.clarity.sourcemodel.OOPSourceModelConstants.ComponentInvocations;
-import org.junit.Test;
-
-import static org.junit.Assert.assertTrue;
-
-public class AnnotationInvocationTest {
-
-    @Test
-    public void testClassAnnotationRegisteredInvokedComponent() throws Exception {
-
-        final String code = "@Deprecated public class test {}";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVA);
-        rawData.insertFile(new RawFile("file2", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        final ComponentInvocation invocation = (generatedSourceModel.getComponent("test").get().componentInvocations(
-                ComponentInvocations.ANNOTATION).get(0));
-        assertTrue(invocation.invokedComponent().equals("Deprecated"));
-        assertTrue(((AnnotationInvocation) invocation).annotations().get(0).getKey().equals("Deprecated"));
-        assertTrue(((AnnotationInvocation) invocation).annotations().get(0).getValue().isEmpty());
-    }
-
-    @Test
-    public void testClassSingleElementAnnotationRegisteredInvokedComponent() throws Exception {
-
-        final String code = "@Deprecated(\"lolcakes\") public class test {}";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVA);
-        rawData.insertFile(new RawFile("file2", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        final ComponentInvocation invocation = (generatedSourceModel.getComponent("test").get().componentInvocations(
-                ComponentInvocations.ANNOTATION).get(0));
-        assertTrue(invocation.invokedComponent().equals("Deprecated"));
-        System.out.println(((AnnotationInvocation) invocation).annotations().get(0).getValue().get("")
-                .equals("\"lolcakes\""));
-    }
-
-    @Test
-    public void testInterfaceAnnotationRegisteredInvokedComponent() throws Exception {
-
-        final String code = "@Deprecated public interface test {}";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVA);
-        rawData.insertFile(new RawFile("file2", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        final ComponentInvocation invocation = (generatedSourceModel.getComponent("test").get().componentInvocations(
-                ComponentInvocations.ANNOTATION).get(0));
-        assertTrue(invocation.invokedComponent().equals("Deprecated"));
-        assertTrue(((AnnotationInvocation) invocation).annotations().get(0).getKey().equals("Deprecated"));
-        assertTrue(((AnnotationInvocation) invocation).annotations().get(0).getValue().isEmpty());
-    }
-
-    @Test
-    public void testEnumAnnotationRegisteredInvokedComponent() throws Exception {
-
-        final String code = "@Deprecated public enum test {}";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVA);
-        rawData.insertFile(new RawFile("file2", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        final ComponentInvocation invocation = (generatedSourceModel.getComponent("test").get().componentInvocations(
-                ComponentInvocations.ANNOTATION).get(0));
-        assertTrue(invocation.invokedComponent().equals("Deprecated"));
-        assertTrue(((AnnotationInvocation) invocation).annotations().get(0).getKey().equals("Deprecated"));
-        assertTrue(((AnnotationInvocation) invocation).annotations().get(0).getValue().isEmpty());
-    }
-
-    @Test
-    public void testFieldVarAnnotationRegisteredInvokedComponent() throws Exception {
-
-        final String code = "import org.annotation.Autowired; public class Test { @Autowired static final String fieldVar; }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVA);
-        rawData.insertFile(new RawFile("file2", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        final ComponentInvocation invocation = (generatedSourceModel.getComponent("Test.fieldVar")
-                .get().componentInvocations(ComponentInvocations.ANNOTATION).get(0));
-        assertTrue(invocation.invokedComponent().equals("org.annotation.Autowired"));
-        assertTrue(((AnnotationInvocation) invocation).annotations().get(0).getKey().equals("org.annotation.Autowired"));
-        assertTrue(((AnnotationInvocation) invocation).annotations().get(0).getValue().isEmpty());
-    }
-
-    @Test
-    public void testMethodParamAnnotationRegisteredInvokedComponent() throws Exception {
-
-        final String code = "import org.annotation.Autowired; public class test { void aMethod(@Override String var){}}";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVA);
-        rawData.insertFile(new RawFile("file2", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        final ComponentInvocation invocation = (generatedSourceModel.getComponent("test.aMethod(String).var")
-                .get().componentInvocations(ComponentInvocations.ANNOTATION).get(0));
-        assertTrue(invocation.invokedComponent().equals("Override"));
-        assertTrue(((AnnotationInvocation) invocation).annotations().get(0).getKey().equals("Override"));
-        assertTrue(((AnnotationInvocation) invocation).annotations().get(0).getValue().isEmpty());
-    }
-
-    @Test
-    public void testInterfaceConstantAnnotationRegisteredInvokedComponent() throws Exception {
-
-        final String code = "import org.annotation.Autowired; public class test { @Autowired String fieldVar; }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVA);
-        rawData.insertFile(new RawFile("file2", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        final ComponentInvocation invocation = (generatedSourceModel.getComponent("test.fieldVar")
-                .get().componentInvocations(
-                        ComponentInvocations.ANNOTATION).get(0));
-        assertTrue(invocation.invokedComponent().equals("org.annotation.Autowired"));
-        assertTrue(((AnnotationInvocation) invocation).annotations().get(0).getKey().equals("org.annotation.Autowired"));
-        assertTrue(((AnnotationInvocation) invocation).annotations().get(0).getValue().isEmpty());
-    }
-
-    @Test
-    public void testMethodAnnotationRegisteredInvokedComponent() throws Exception {
-
-        final String code = "import org.springframework.RequestMapping;"
-                + "import org.springframework.RequestMethod;"
-                + " class test { "
-                + "     @RequestMapping(value = \"value1\", method = RequestMethod.GET) method(){}"
-                + " }";
-
-        final SourceFiles rawData = new SourceFiles(Lang.JAVA);
-        rawData.insertFile(new RawFile("file2", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        final ComponentInvocation invocation = (generatedSourceModel.getComponent("test.method()")
-                .get().componentInvocations(
-                        ComponentInvocations.ANNOTATION).get(0));
-        assertTrue(invocation.invokedComponent().equals("org.springframework.RequestMapping"));
-    }
-
-    @Test
-    public void testMethodAnnotationRegisteredValueList() throws Exception {
-
-        final String code = "import org.springframework.RequestMapping;"
-                + "import org.springframework.RequestMethod;"
-                + " public class test { "
-                + "     @RequestMapping(value = \"value1\", method = RequestMethod.GET) void method(){}"
-                + " }";
-
-        final SourceFiles rawData = new SourceFiles(Lang.JAVA);
-        rawData.insertFile(new RawFile("file2", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        final ComponentInvocation invocation = (generatedSourceModel.getComponent("test.method()")
-                .get().componentInvocations(
-                        ComponentInvocations.ANNOTATION).get(0));
-
-        assertTrue(((AnnotationInvocation) invocation).annotations().get(0).getValue().get("value")
-                .equals("\"value1\""));
-
-        assertTrue(((AnnotationInvocation) invocation).annotations().get(0).getValue().get("method")
-                .equals("RequestMethod.GET"));
-    }
-
-}
diff --git a/clarpse/src/test/java/com/clarity/test/java/ChildComponentsTest.java b/clarpse/src/test/java/com/clarity/test/java/ChildComponentsTest.java
index f2cb209..2c13e76 100644
--- a/clarpse/src/test/java/com/clarity/test/java/ChildComponentsTest.java
+++ b/clarpse/src/test/java/com/clarity/test/java/ChildComponentsTest.java
@@ -14,7 +14,6 @@
 
     @Test
     public void testClassHasMethodChild() throws Exception {
-
         final String code = "class Test { void method(){} }";
         final SourceFiles rawData = new SourceFiles(Lang.JAVA);
         rawData.insertFile(new RawFile("file2", code));
@@ -25,7 +24,6 @@ public void testClassHasMethodChild() throws Exception {
 
     @Test
     public void testClassHasFieldVarChild() throws Exception {
-
         final String code = "class Test { String fieldVar; }";
         final SourceFiles rawData = new SourceFiles(Lang.JAVA);
         rawData.insertFile(new RawFile("file2", code));
@@ -36,7 +34,6 @@ public void testClassHasFieldVarChild() throws Exception {
 
     @Test
     public void ignoreClassDeclaredWithinMethods() throws Exception {
-
         final String code = "class Test { void method() { class Tester {} } }";
         final SourceFiles rawData = new SourceFiles(Lang.JAVA);
         rawData.insertFile(new RawFile("file2", code));
@@ -48,7 +45,6 @@ public void ignoreClassDeclaredWithinMethods() throws Exception {
 
     @Test
     public void testIntefaceHasMethodChild() throws Exception {
-
         final String code = "interface Test { void method(); }";
         final SourceFiles rawData = new SourceFiles(Lang.JAVA);
         rawData.insertFile(new RawFile("file2", code));
@@ -58,8 +54,7 @@ public void testIntefaceHasMethodChild() throws Exception {
     }
 
     @Test
-    public void testMethodeHasMethodParamChild() throws Exception {
-
+    public void testMethodHasMethodParamChild() throws Exception {
         final String code = "class Test { void method(String str); }";
         final SourceFiles rawData = new SourceFiles(Lang.JAVA);
         rawData.insertFile(new RawFile("file2", code));
@@ -70,8 +65,7 @@ public void testMethodeHasMethodParamChild() throws Exception {
     }
 
     @Test
-    public void testIntefaceHasConstantFieldChild() throws Exception {
-
+    public void testInterfaceHasConstantFieldChild() throws Exception {
         final String code = "interface Test { String NEAR_TO_QUERY; }";
         final SourceFiles rawData = new SourceFiles(Lang.JAVA);
         rawData.insertFile(new RawFile("file2", code));
@@ -82,7 +76,6 @@ public void testIntefaceHasConstantFieldChild() throws Exception {
 
     @Test
     public void testClassHasNestedIntefaceChild() throws Exception {
-
         final String code = "class TestA { interface TestB { }}";
         final SourceFiles rawData = new SourceFiles(Lang.JAVA);
         rawData.insertFile(new RawFile("file2", code));
@@ -93,7 +86,6 @@ public void testClassHasNestedIntefaceChild() throws Exception {
 
     @Test
     public void testClassHasNestedEnumChild() throws Exception {
-
         final String code = "class TestA { enum TestB { }}";
         final SourceFiles rawData = new SourceFiles(Lang.JAVA);
         rawData.insertFile(new RawFile("file2", code));
@@ -104,7 +96,6 @@ public void testClassHasNestedEnumChild() throws Exception {
 
     @Test
     public void testEnumHasNestedConstantsChild() throws Exception {
-
         final String code = " enum TestA { A,B,C; }";
         final SourceFiles rawData = new SourceFiles(Lang.JAVA);
         rawData.insertFile(new RawFile("file2", code));
@@ -117,7 +108,6 @@ public void testEnumHasNestedConstantsChild() throws Exception {
 
     @Test
     public void testClassWithMultipleChildren() throws Exception {
-
         final String code = " class TestA { String fieldVar; String method(){} interface TestB {}}";
         final SourceFiles rawData = new SourceFiles(Lang.JAVA);
         rawData.insertFile(new RawFile("file2", code));
diff --git a/clarpse/src/test/java/com/clarity/test/java/CodeFragmentTest.java b/clarpse/src/test/java/com/clarity/test/java/CodeFragmentTest.java
index 42c0b8c..cde572a 100644
--- a/clarpse/src/test/java/com/clarity/test/java/CodeFragmentTest.java
+++ b/clarpse/src/test/java/com/clarity/test/java/CodeFragmentTest.java
@@ -13,7 +13,6 @@
 
     @Test
     public void classGenericsCodeFragmentTest() throws Exception {
-
         final String code = "class Test<List> {}";
         final SourceFiles rawData = new SourceFiles(Lang.JAVA);
         rawData.insertFile(new RawFile("file2", code));
@@ -24,7 +23,6 @@ public void classGenericsCodeFragmentTest() throws Exception {
 
     @Test
     public void classGenericsCodeFragmentTestv2() throws Exception {
-
         final String code = "class Test<T extends List> {}";
         final SourceFiles rawData = new SourceFiles(Lang.JAVA);
         rawData.insertFile(new RawFile("file2", code));
@@ -35,7 +33,6 @@ public void classGenericsCodeFragmentTestv2() throws Exception {
 
     @Test
     public void fieldVarCodeFragmentTest() throws Exception {
-
         final String code = "class Test {List<Integer, String> fieldVar, x;}";
         final SourceFiles rawData = new SourceFiles(Lang.JAVA);
         rawData.insertFile(new RawFile("file2", code));
@@ -47,7 +44,6 @@ public void fieldVarCodeFragmentTest() throws Exception {
 
     @Test
     public void fieldVarCodeFragmentTestComplex() throws Exception {
-
         final String code = "class Test {Map<String, List<Integer, String>> fieldVar, x;}";
         final SourceFiles rawData = new SourceFiles(Lang.JAVA);
         rawData.insertFile(new RawFile("file2", code));
@@ -59,7 +55,6 @@ public void fieldVarCodeFragmentTestComplex() throws Exception {
 
     @Test
     public void simpleMethodCodeFragmentTest() throws Exception {
-
         final String code = "class Test {Map<String, List<Integer, String>> sMethod() {}}";
         final SourceFiles rawData = new SourceFiles(Lang.JAVA);
         rawData.insertFile(new RawFile("file2", code));
@@ -70,7 +65,6 @@ public void simpleMethodCodeFragmentTest() throws Exception {
 
     @Test
     public void interfaceMethodCodeFragmentTest() throws Exception {
-
         final String code = "interface Test { Map<String, List<Integer, String>> sMethod();}";
         final SourceFiles rawData = new SourceFiles(Lang.JAVA);
         rawData.insertFile(new RawFile("file2", code));
@@ -81,7 +75,6 @@ public void interfaceMethodCodeFragmentTest() throws Exception {
 
     @Test
     public void complexMethodCodeFragmentTest() throws Exception {
-
         final String code = "class Test {Map<List<String>, String[]> sMethod(String s, int t) {}}";
         final SourceFiles rawData = new SourceFiles(Lang.JAVA);
         rawData.insertFile(new RawFile("file2", code));
@@ -90,6 +83,4 @@ public void complexMethodCodeFragmentTest() throws Exception {
         System.out.println(generatedSourceModel.getComponent("Test.sMethod(String, int)").get().codeFragment());
         assertTrue(generatedSourceModel.getComponent("Test.sMethod(String, int)").get().codeFragment().equals("sMethod(String, int) : Map<List<String>, String[]>"));
     }
-
-
 }
diff --git a/clarpse/src/test/java/com/clarity/test/java/CodeTest.java b/clarpse/src/test/java/com/clarity/test/java/CodeTest.java
deleted file mode 100644
index f099728..0000000
--- a/clarpse/src/test/java/com/clarity/test/java/CodeTest.java
+++ /dev/null
@@ -1,43 +0,0 @@
-package com.clarity.test.java;
-
-import com.clarity.compiler.ClarpseProject;
-import com.clarity.compiler.Lang;
-import com.clarity.compiler.RawFile;
-import com.clarity.compiler.SourceFiles;
-import com.clarity.sourcemodel.OOPSourceCodeModel;
-import org.junit.Test;
-
-import static junit.framework.Assert.assertTrue;
-
-public class CodeTest {
-
-    @Test
-    public void testMethodCode() throws Exception {
-
-        final String code = "@Deprecated public class test { \n static void aMethod (String a) { \n int x = 1; \n a = null; \n } \n }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVA);
-        rawData.insertFile(new RawFile("file2", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("test.aMethod(String)").get().code().equals(" static void aMethod (String a) { \n" +
-                " int x = 1; \n" +
-                " a = null; \n" +
-                " } "));
-    }
-
-    @Test
-    public void testClassCode() throws Exception {
-
-        final String code = "@Deprecated public class test { \n static void aMethod (String a) { \n int x = 1; \n a = null; \n } \n }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVA);
-        rawData.insertFile(new RawFile("file2", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("test").get().code().equals("@Deprecated public class test { \n" +
-                " static void aMethod (String a) { \n" +
-                " int x = 1; \n" +
-                " a = null; \n" +
-                " } \n" +
-                " }"));
-    }
-}
diff --git a/clarpse/src/test/java/com/clarity/test/java/CommentsParsingTest.java b/clarpse/src/test/java/com/clarity/test/java/CommentsParsingTest.java
index e06fb72..b67be58 100644
--- a/clarpse/src/test/java/com/clarity/test/java/CommentsParsingTest.java
+++ b/clarpse/src/test/java/com/clarity/test/java/CommentsParsingTest.java
@@ -24,7 +24,6 @@ public void testClassLevelComment() throws Exception {
                 " */\n"));
     }
 
-
     @Test
     public void testClassLevelNoComment() throws Exception {
 
diff --git a/clarpse/src/test/java/com/clarity/test/java/InvocationInheritanceTest.java b/clarpse/src/test/java/com/clarity/test/java/InvocationReferenceTest.java
similarity index 81%
rename from clarpse/src/test/java/com/clarity/test/java/InvocationInheritanceTest.java
rename to clarpse/src/test/java/com/clarity/test/java/InvocationReferenceTest.java
index 675c06b..c8c9ab4 100644
--- a/clarpse/src/test/java/com/clarity/test/java/InvocationInheritanceTest.java
+++ b/clarpse/src/test/java/com/clarity/test/java/InvocationReferenceTest.java
@@ -4,7 +4,7 @@
 import com.clarity.compiler.Lang;
 import com.clarity.compiler.RawFile;
 import com.clarity.compiler.SourceFiles;
-import com.clarity.invocation.ComponentInvocation;
+import com.clarity.reference.ComponentReference;
 import com.clarity.sourcemodel.OOPSourceCodeModel;
 import org.junit.Test;
 
@@ -14,7 +14,7 @@
  * Ensure component invocations for a given component are inherited by its
  * parents.
  */
-public class InvocationInheritanceTest {
+public class InvocationReferenceTest {
 
     @Test
     public void testClassInheritsFieldInvocations() throws Exception {
@@ -23,7 +23,7 @@ public void testClassInheritsFieldInvocations() throws Exception {
         rawData.insertFile(new RawFile("file2", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(((ComponentInvocation) generatedSourceModel.getComponent("Test").get().invocations().toArray()[0])
+        assertTrue(((ComponentReference) generatedSourceModel.getComponent("Test").get().references().toArray()[0])
                 .invokedComponent().equals("java.lang.String"));
     }
 
@@ -34,7 +34,7 @@ public void testClassInheritsMethodInvocations() throws Exception {
         rawData.insertFile(new RawFile("file2", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(((ComponentInvocation) generatedSourceModel.getComponent("Test").get().invocations().toArray()[0])
+        assertTrue(((ComponentReference) generatedSourceModel.getComponent("Test").get().references().toArray()[0])
                 .invokedComponent().equals("java.lang.String"));
     }
 
@@ -45,7 +45,7 @@ public void testClassInheritsLocalVarsInvocations() throws Exception {
         rawData.insertFile(new RawFile("file2", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(((ComponentInvocation) generatedSourceModel.getComponent("Test").get().invocations().toArray()[0])
+        assertTrue(((ComponentReference) generatedSourceModel.getComponent("Test").get().references().toArray()[0])
                 .invokedComponent().equals("java.lang.String"));
     }
 
@@ -56,7 +56,7 @@ public void testClassInheritsMethodParamsInvocations() throws Exception {
         rawData.insertFile(new RawFile("file2", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(((ComponentInvocation) generatedSourceModel.getComponent("Test").get().invocations().toArray()[0])
+        assertTrue(((ComponentReference) generatedSourceModel.getComponent("Test").get().references().toArray()[0])
                 .invokedComponent().equals("java.lang.String"));
     }
 
@@ -67,7 +67,7 @@ public void testClassInheritsNestedClassInvocations() throws Exception {
         rawData.insertFile(new RawFile("file2", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(((ComponentInvocation) generatedSourceModel.getComponent("Test").get().invocations().toArray()[0])
+        assertTrue(((ComponentReference) generatedSourceModel.getComponent("Test").get().references().toArray()[0])
                 .invokedComponent().equals("java.lang.String"));
     }
 
@@ -78,7 +78,7 @@ public void testClassDoesNotInheritExtendsAndImplementsInvocations() throws Exce
         rawData.insertFile(new RawFile("file2", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Test").get().invocations().isEmpty());
+        assertTrue(generatedSourceModel.getComponent("Test").get().references().isEmpty());
     }
 
     @Test
@@ -88,7 +88,7 @@ public void testInterfaceInheritsFieldInvocations() throws Exception {
         rawData.insertFile(new RawFile("file2", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(((ComponentInvocation) generatedSourceModel.getComponent("Test").get().invocations().toArray()[0])
+        assertTrue(((ComponentReference) generatedSourceModel.getComponent("Test").get().references().toArray()[0])
                 .invokedComponent().equals("java.lang.String"));
     }
 
@@ -99,7 +99,7 @@ public void testInterfaceInheritsMethodInvocations() throws Exception {
         rawData.insertFile(new RawFile("file2", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(((ComponentInvocation) generatedSourceModel.getComponent("Test").get().invocations().toArray()[0])
+        assertTrue(((ComponentReference) generatedSourceModel.getComponent("Test").get().references().toArray()[0])
                 .invokedComponent().equals("java.lang.String"));
     }
 
@@ -110,7 +110,7 @@ public void testInterfaceInheritsMethodParamsInvocations() throws Exception {
         rawData.insertFile(new RawFile("file2", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(((ComponentInvocation) generatedSourceModel.getComponent("Test").get().invocations().toArray()[0])
+        assertTrue(((ComponentReference) generatedSourceModel.getComponent("Test").get().references().toArray()[0])
                 .invokedComponent().equals("java.lang.String"));
     }
 
@@ -122,7 +122,7 @@ public void testMethodInheritsLocalVarsInvocations() throws Exception {
         final ClarpseProject parseService = new ClarpseProject(rawData);
         final OOPSourceCodeModel generatedSourceModel = parseService.result();
         assertTrue(
-                ((ComponentInvocation) generatedSourceModel.getComponent("Test.aMethod()").get().invocations().toArray()[0])
+                ((ComponentReference) generatedSourceModel.getComponent("Test.aMethod()").get().references().toArray()[0])
                         .invokedComponent().equals("java.lang.String"));
     }
 
@@ -133,7 +133,7 @@ public void testMethodInheritsMethodParamsInvocations() throws Exception {
         rawData.insertFile(new RawFile("file2", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(((ComponentInvocation) generatedSourceModel.getComponent("Test.aMethod(String)")
-                .get().invocations().toArray()[0]).invokedComponent().equals("java.lang.String"));
+        assertTrue(((ComponentReference) generatedSourceModel.getComponent("Test.aMethod(String)")
+                .get().references().toArray()[0]).invokedComponent().equals("java.lang.String"));
     }
 }
diff --git a/clarpse/src/test/java/com/clarity/test/java/JavaDocInvocationTest.java b/clarpse/src/test/java/com/clarity/test/java/JavaDocInvocationTest.java
deleted file mode 100644
index 525dc73..0000000
--- a/clarpse/src/test/java/com/clarity/test/java/JavaDocInvocationTest.java
+++ /dev/null
@@ -1,113 +0,0 @@
-package com.clarity.test.java;
-
-import com.clarity.compiler.ClarpseProject;
-import com.clarity.compiler.Lang;
-import com.clarity.compiler.RawFile;
-import com.clarity.compiler.SourceFiles;
-import com.clarity.invocation.ComponentInvocation;
-import com.clarity.sourcemodel.OOPSourceCodeModel;
-import com.clarity.sourcemodel.OOPSourceModelConstants.ComponentInvocations;
-import org.junit.Test;
-
-import static org.junit.Assert.assertTrue;
-
-/**
- * Ensure component invocation data of a given class is accurate.
- */
-public class JavaDocInvocationTest {
-
-    @Test
-    public void simpleJavaDocMentionComponentInvocation() throws Exception {
-
-        final String code = "package com; \n /**\n"
-                + " * The url argument must specify an absolute {@link URL}. The name\n"
-                + "\n*/\npublic class ClassA { }";
-        OOPSourceCodeModel generatedSourceModel;
-        final SourceFiles rawData = new SourceFiles(Lang.JAVA);
-        rawData.insertFile(new RawFile("file1", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        generatedSourceModel = parseService.result();
-        assertTrue(((ComponentInvocation) generatedSourceModel.getComponent("com.ClassA")
-                .get().componentInvocations(ComponentInvocations.DOC_MENTION).toArray()[0]).invokedComponent()
-                        .equals("com.URL"));
-    }
-
-    @Test
-    public void avoidMethodComponentJavaDocInvocations() throws Exception {
-
-        final String code = "package com; \n /**\n"
-                + " * The url argument must specify an absolute {@link URL#test()  }. The name\n"
-                + "\n*/\npublic class ClassA { }";
-        OOPSourceCodeModel generatedSourceModel;
-        final SourceFiles rawData = new SourceFiles(Lang.JAVA);
-        rawData.insertFile(new RawFile("file1", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("com.ClassA").get().componentInvocations().size() == 0);
-    }
-
-    @Test
-    public void resolveDocCommentShortLinkUsingImport() throws Exception {
-
-        final String code = "package com; \n import org.test.Junit;\n/**\n"
-                + " * The url argument must specify an absolute {  @linkplain Junit}. The name\n"
-                + "\n*/\npublic class ClassA { }";
-        OOPSourceCodeModel generatedSourceModel;
-        final SourceFiles rawData = new SourceFiles(Lang.JAVA);
-        rawData.insertFile(new RawFile("file1", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        generatedSourceModel = parseService.result();
-        assertTrue(
-                generatedSourceModel.getComponent("com.ClassA").get().componentInvocations(ComponentInvocations.DOC_MENTION)
-                        .get(0).invokedComponent().equals("org.test.Junit"));
-    }
-
-    @Test
-    public void resolveDocCommentLongLink() throws Exception {
-
-        final String code = "package com; \n/**\n"
-                + " * The url argument must specify an absolute {@linkplain org.test.Junit}. The name\n"
-                + "\n*/\npublic class ClassA { }";
-        OOPSourceCodeModel generatedSourceModel;
-        final SourceFiles rawData = new SourceFiles(Lang.JAVA);
-        rawData.insertFile(new RawFile("file1", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        generatedSourceModel = parseService.result();
-        assertTrue(
-                generatedSourceModel.getComponent("com.ClassA").get().componentInvocations(ComponentInvocations.DOC_MENTION)
-                        .get(0).invokedComponent().equals("org.test.Junit"));
-    }
-
-    @Test
-    public void resolveDocCommentLongLinkv2() throws Exception {
-
-        final String code = "package com; \n import org.test.Junit;\n/**\n"
-                + " * The url argument must specify an absolute {@linkplain org.test.Junit}. The name\n"
-                + "\n*/\npublic class ClassA { }";
-        OOPSourceCodeModel generatedSourceModel;
-        final SourceFiles rawData = new SourceFiles(Lang.JAVA);
-        rawData.insertFile(new RawFile("file1", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        generatedSourceModel = parseService.result();
-        assertTrue(
-                generatedSourceModel.getComponent("com.ClassA").get().componentInvocations(ComponentInvocations.DOC_MENTION)
-                        .get(0).invokedComponent().equals("org.test.Junit"));
-    }
-
-    @Test
-    public void resolveDocCommentLongLinkWithAlias() throws Exception {
-
-        final String code = "package com; \n import org.test.Junit;\n/**\n"
-                + " * The url argument must specify an absolute {  @link org.test.Junit   Junit  }. The name\n"
-                + "\n*/\npublic class ClassA { }";
-        OOPSourceCodeModel generatedSourceModel;
-        final SourceFiles rawData = new SourceFiles(Lang.JAVA);
-        rawData.insertFile(new RawFile("file1", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        generatedSourceModel = parseService.result();
-        assertTrue(
-                generatedSourceModel.getComponent("com.ClassA").get().componentInvocations(ComponentInvocations.DOC_MENTION)
-                        .get(0).invokedComponent().equals("org.test.Junit"));
-    }
-
-}
diff --git a/clarpse/src/test/java/com/clarity/test/java/LineNumberTest.java b/clarpse/src/test/java/com/clarity/test/java/LineNumberTest.java
deleted file mode 100644
index eda11e5..0000000
--- a/clarpse/src/test/java/com/clarity/test/java/LineNumberTest.java
+++ /dev/null
@@ -1,69 +0,0 @@
-package com.clarity.test.java;
-
-import com.clarity.compiler.ClarpseProject;
-import com.clarity.compiler.Lang;
-import com.clarity.compiler.RawFile;
-import com.clarity.compiler.SourceFiles;
-import com.clarity.sourcemodel.OOPSourceCodeModel;
-import org.junit.Test;
-
-import static org.junit.Assert.assertTrue;
-
-public class LineNumberTest {
-
-    @Test
-    public void testClassComponentLineNumber() throws Exception {
-
-        final String code = " public class Test {\n public Test(String test) {\n String tester;} }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVA);
-        rawData.insertFile(new RawFile("file2.java", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Test").get().line() == 1);
-    }
-
-    @Test
-    public void testMethodComponentLineNumber() throws Exception {
-
-        final String code = "public class Test {\n public Test(String test) {\n String tester;} }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVA);
-        rawData.insertFile(new RawFile("file2.java", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Test.Test(String)").get().line() == 2);
-    }
-
-    @Test
-    public void testFieldVarComponentLineNumber() throws Exception {
-
-        final String code = "public class Test {\n private String fieldVar;\n }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVA);
-        rawData.insertFile(new RawFile("file2.java", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Test.fieldVar").get().line() == 2);
-    }
-
-
-    @Test
-    public void testMethodParamComponentLineNumber() throws Exception {
-
-        final String code = "public class Test {\n public Test(\nString test) {\n String tester;} }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVA);
-        rawData.insertFile(new RawFile("file2.java", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Test.Test(String).test").get().line() == 3);
-    }
-
-    @Test
-    public void testLocalVarComponentLineNumber() throws Exception {
-
-        final String code = "public class Test {\n public Test(\nString test) {\nString tester;\n}\n}";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVA);
-        rawData.insertFile(new RawFile("file2.java", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Test.Test(String).tester").get().line() == 4);
-    }
-}
diff --git a/clarpse/src/test/java/com/clarity/test/java/TypeDeclarationTest.java b/clarpse/src/test/java/com/clarity/test/java/SimpleTypeReferenceTest.java
similarity index 81%
rename from clarpse/src/test/java/com/clarity/test/java/TypeDeclarationTest.java
rename to clarpse/src/test/java/com/clarity/test/java/SimpleTypeReferenceTest.java
index 50d859c..700b41d 100644
--- a/clarpse/src/test/java/com/clarity/test/java/TypeDeclarationTest.java
+++ b/clarpse/src/test/java/com/clarity/test/java/SimpleTypeReferenceTest.java
@@ -4,16 +4,16 @@
 import com.clarity.compiler.Lang;
 import com.clarity.compiler.RawFile;
 import com.clarity.compiler.SourceFiles;
-import com.clarity.invocation.ComponentInvocation;
+import com.clarity.reference.ComponentReference;
 import com.clarity.sourcemodel.OOPSourceCodeModel;
-import com.clarity.sourcemodel.OOPSourceModelConstants.ComponentInvocations;
+import com.clarity.sourcemodel.OOPSourceModelConstants.TypeReferences;
 import org.junit.Test;
 
 import java.util.ArrayList;
 
 import static org.junit.Assert.assertTrue;
 
-public class TypeDeclarationTest {
+public class SimpleTypeReferenceTest {
 
     @Test
     public void testFieldVarTypeDeclaration() throws Exception {
@@ -23,8 +23,8 @@ public void testFieldVarTypeDeclaration() throws Exception {
         rawData.insertFile(new RawFile("file2", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         OOPSourceCodeModel generatedSourceModel = parseService.result();
-        final ComponentInvocation invocation = (generatedSourceModel.getComponent("Test.fieldVar")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).get(0));
+        final ComponentReference invocation = (generatedSourceModel.getComponent("Test.fieldVar")
+                .get().references(TypeReferences.SIMPLE).get(0));
         assertTrue(invocation.invokedComponent().equals("java.lang.String"));
     }
 
@@ -37,7 +37,7 @@ public void testFieldVarTypeDeclarationListSize() throws Exception {
         final ClarpseProject parseService = new ClarpseProject(rawData);
         OOPSourceCodeModel generatedSourceModel = parseService.result();
         assertTrue(generatedSourceModel.getComponent("Test.fieldVar")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).size() == 1);
+                .get().references(TypeReferences.SIMPLE).size() == 1);
     }
 
     @Test
@@ -48,7 +48,7 @@ public void testClassExpressionsNotCountedAsTypeDeclaration() throws Exception {
         rawData.insertFile(new RawFile("file2", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Test.log").get().componentInvocations(ComponentInvocations.DECLARATION)
+        assertTrue(generatedSourceModel.getComponent("Test.log").get().references(TypeReferences.SIMPLE)
                 .size() == 1);
     }
 
@@ -61,10 +61,10 @@ public void testMethodParamTypeDeclaration() throws Exception {
         final ClarpseProject parseService = new ClarpseProject(rawData);
         OOPSourceCodeModel generatedSourceModel = parseService.result();
         assertTrue(generatedSourceModel.getComponent("Test.method(String, int).s1")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).get(0).invokedComponent()
+                .get().references(TypeReferences.SIMPLE).get(0).invokedComponent()
                 .equals("java.lang.String"));
         assertTrue(generatedSourceModel.getComponent("Test.method(String, int).s2")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).get(0).invokedComponent()
+                .get().references(TypeReferences.SIMPLE).get(0).invokedComponent()
                 .equals("java.lang.Integer"));
     }
 
@@ -77,9 +77,9 @@ public void testMethodParamTypeDeclarationListSize() throws Exception {
         final ClarpseProject parseService = new ClarpseProject(rawData);
         OOPSourceCodeModel generatedSourceModel = parseService.result();
         assertTrue(generatedSourceModel.getComponent("Test.method(String, int).s1")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).size() == 1);
+                .get().references(TypeReferences.SIMPLE).size() == 1);
         assertTrue(generatedSourceModel.getComponent("Test.method(String, int).s2")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).size() == 1);
+                .get().references(TypeReferences.SIMPLE).size() == 1);
     }
 
     @Test
@@ -91,7 +91,7 @@ public void testMethodLocalVarTypeDeclaration() throws Exception {
         final ClarpseProject parseService = new ClarpseProject(rawData);
         OOPSourceCodeModel generatedSourceModel = parseService.result();
         assertTrue(generatedSourceModel.getComponent("Test.method().s")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).get(0).invokedComponent()
+                .get().references(TypeReferences.SIMPLE).get(0).invokedComponent()
                 .equals("java.lang.String"));
     }
 
@@ -104,7 +104,7 @@ public void testMethodLocalVarTypeDeclarationListSize() throws Exception {
         final ClarpseProject parseService = new ClarpseProject(rawData);
         OOPSourceCodeModel generatedSourceModel = parseService.result();
         assertTrue(generatedSourceModel.getComponent("Test.method().s")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).size() == 1);
+                .get().references(TypeReferences.SIMPLE).size() == 1);
     }
 
     @Test
@@ -116,6 +116,6 @@ public void TypeDeclarationArrayList() throws Exception {
         reqCon.insertFile(file);
         reqCons.add(reqCon);
         final OOPSourceCodeModel codeModel = new ClarpseProject(reqCon).result();
-        assertTrue(codeModel.getComponent("com.sample.ClassA.b").get().invocations().size() == 4);
+        assertTrue(codeModel.getComponent("com.sample.ClassA.b").get().references().size() == 4);
     }
 }
diff --git a/clarpse/src/test/java/com/clarity/test/java/TypeExtensionTest.java b/clarpse/src/test/java/com/clarity/test/java/TypeExtensionReferenceTest.java
similarity index 81%
rename from clarpse/src/test/java/com/clarity/test/java/TypeExtensionTest.java
rename to clarpse/src/test/java/com/clarity/test/java/TypeExtensionReferenceTest.java
index 8f90c21..d430f7d 100644
--- a/clarpse/src/test/java/com/clarity/test/java/TypeExtensionTest.java
+++ b/clarpse/src/test/java/com/clarity/test/java/TypeExtensionReferenceTest.java
@@ -4,7 +4,7 @@
 import com.clarity.compiler.Lang;
 import com.clarity.compiler.RawFile;
 import com.clarity.compiler.SourceFiles;
-import com.clarity.invocation.ComponentInvocation;
+import com.clarity.reference.ComponentReference;
 import com.clarity.sourcemodel.OOPSourceCodeModel;
 import org.junit.Assert;
 import org.junit.Test;
@@ -12,57 +12,53 @@
 /**
  * Ensure component type extensions invocations are accurate.
  */
-public class TypeExtensionTest {
+public class TypeExtensionReferenceTest {
 
     @Test
     public void testAccurateExtendedTypes() throws Exception {
-
         final String code = "package com; \n public class ClassA extends ClassD<?> { }";
         OOPSourceCodeModel generatedSourceModel;
         final SourceFiles rawData = new SourceFiles(Lang.JAVA);
         rawData.insertFile(new RawFile("file1", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         generatedSourceModel = parseService.result();
-        Assert.assertTrue(((ComponentInvocation) generatedSourceModel.getComponent("com.ClassA").get().componentInvocations()
+        Assert.assertTrue(((ComponentReference) generatedSourceModel.getComponent("com.ClassA").get().references()
                 .toArray()[0]).invokedComponent().equals("com.ClassD"));
     }
 
     @Test
     public void testAccurateExtendedTypesSize() throws Exception {
-
         final String code = "package com; \n public class ClassA extends ClassD { }";
         OOPSourceCodeModel generatedSourceModel;
         final SourceFiles rawData = new SourceFiles(Lang.JAVA);
         rawData.insertFile(new RawFile("file1", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         generatedSourceModel = parseService.result();
-        Assert.assertTrue(generatedSourceModel.getComponent("com.ClassA").get().componentInvocations().size() == 1);
+        Assert.assertTrue(generatedSourceModel.getComponent("com.ClassA").get().references().size() == 1);
     }
 
     @Test
     public void testAccurateExtendedTypesForNestedClass() throws Exception {
-
         final String code = "package com; \n public class ClassA { public class ClassB extends ClassD{} }";
         OOPSourceCodeModel generatedSourceModel;
         final SourceFiles rawData = new SourceFiles(Lang.JAVA);
         rawData.insertFile(new RawFile("file1", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         generatedSourceModel = parseService.result();
-        Assert.assertTrue(((ComponentInvocation) generatedSourceModel.getComponent("com.ClassA.ClassB")
-                .get().componentInvocations().toArray()[0]).invokedComponent().equals("com.ClassD"));
+        Assert.assertTrue(((ComponentReference) generatedSourceModel.getComponent("com.ClassA.ClassB")
+                .get().references().toArray()[0]).invokedComponent().equals("com.ClassD"));
 
-        Assert.assertTrue(generatedSourceModel.getComponent("com.ClassA.ClassB").get().componentInvocations().size() == 1);
+        Assert.assertTrue(generatedSourceModel.getComponent("com.ClassA.ClassB").get().references().size() == 1);
     }
 
     @Test
     public void testAccurateExtendedTypesSizeForNestedClass() throws Exception {
-
         final String code = "package com; \n public class ClassA { public class ClassB extends ClassD{} }";
         OOPSourceCodeModel generatedSourceModel;
         final SourceFiles rawData = new SourceFiles(Lang.JAVA);
         rawData.insertFile(new RawFile("file1", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         generatedSourceModel = parseService.result();
-        Assert.assertTrue(generatedSourceModel.getComponent("com.ClassA.ClassB").get().componentInvocations().size() == 1);
+        Assert.assertTrue(generatedSourceModel.getComponent("com.ClassA.ClassB").get().references().size() == 1);
     }
 }
diff --git a/clarpse/src/test/java/com/clarity/test/java/TypeImplementationTest.java b/clarpse/src/test/java/com/clarity/test/java/TypeImplementationReferenceTest.java
similarity index 76%
rename from clarpse/src/test/java/com/clarity/test/java/TypeImplementationTest.java
rename to clarpse/src/test/java/com/clarity/test/java/TypeImplementationReferenceTest.java
index b9281b8..e1e9d46 100644
--- a/clarpse/src/test/java/com/clarity/test/java/TypeImplementationTest.java
+++ b/clarpse/src/test/java/com/clarity/test/java/TypeImplementationReferenceTest.java
@@ -4,9 +4,9 @@
 import com.clarity.compiler.Lang;
 import com.clarity.compiler.RawFile;
 import com.clarity.compiler.SourceFiles;
-import com.clarity.invocation.ComponentInvocation;
+import com.clarity.reference.ComponentReference;
 import com.clarity.sourcemodel.OOPSourceCodeModel;
-import com.clarity.sourcemodel.OOPSourceModelConstants.ComponentInvocations;
+import com.clarity.sourcemodel.OOPSourceModelConstants.TypeReferences;
 import org.junit.Test;
 
 import static org.junit.Assert.assertTrue;
@@ -14,7 +14,7 @@
 /**
  * Ensure component invocation data of a given class is accurate.
  */
-public class TypeImplementationTest {
+public class TypeImplementationReferenceTest {
 
     @Test
     public void testAccurateImplementedTypes() throws Exception {
@@ -25,9 +25,9 @@ public void testAccurateImplementedTypes() throws Exception {
         rawData.insertFile(new RawFile("file1", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         generatedSourceModel = parseService.result();
-        assertTrue(((ComponentInvocation) generatedSourceModel.getComponent("com.ClassA").get().componentInvocations()
+        assertTrue(((ComponentReference) generatedSourceModel.getComponent("com.ClassA").get().references()
                 .toArray()[0]).invokedComponent().equals("com.ClassD"));
-        assertTrue(generatedSourceModel.getComponent("com.ClassA").get().componentInvocations().size() == 1);
+        assertTrue(generatedSourceModel.getComponent("com.ClassA").get().references().size() == 1);
     }
 
     @Test
@@ -39,11 +39,11 @@ public void testAccurateMultipleImplementedTypes() throws Exception {
         rawData.insertFile(new RawFile("file1", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         generatedSourceModel = parseService.result();
-        assertTrue(((ComponentInvocation) generatedSourceModel.getComponent("com.ClassA")
-                .get().componentInvocations(ComponentInvocations.IMPLEMENTATION).toArray()[0]).invokedComponent()
+        assertTrue(((ComponentReference) generatedSourceModel.getComponent("com.ClassA")
+                .get().references(TypeReferences.IMPLEMENTATION).toArray()[0]).invokedComponent()
                         .equals("com.ClassD"));
-        assertTrue(((ComponentInvocation) generatedSourceModel.getComponent("com.ClassA")
-                .get().componentInvocations(ComponentInvocations.IMPLEMENTATION).toArray()[1]).invokedComponent()
+        assertTrue(((ComponentReference) generatedSourceModel.getComponent("com.ClassA")
+                .get().references(TypeReferences.IMPLEMENTATION).toArray()[1]).invokedComponent()
                         .equals("com.ClassE"));
     }
 
@@ -56,7 +56,7 @@ public void testAccurateImplementedTypesSize() throws Exception {
         rawData.insertFile(new RawFile("file1", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("com.ClassA").get().componentInvocations().size() == 1);
+        assertTrue(generatedSourceModel.getComponent("com.ClassA").get().references().size() == 1);
     }
 
     @Test
@@ -68,7 +68,7 @@ public void testAccurateMultipleImplementedTypesSize() throws Exception {
         rawData.insertFile(new RawFile("file1", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("com.ClassA").get().componentInvocations().size() == 2);
+        assertTrue(generatedSourceModel.getComponent("com.ClassA").get().references().size() == 2);
     }
 
     @Test
@@ -80,10 +80,10 @@ public void testAccurateImplementedTypesForNestedClass() throws Exception {
         rawData.insertFile(new RawFile("file1", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         generatedSourceModel = parseService.result();
-        assertTrue(((ComponentInvocation) generatedSourceModel.getComponent("com.ClassA.ClassB")
-                .get().componentInvocations().toArray()[0]).invokedComponent().equals("com.ClassD"));
+        assertTrue(((ComponentReference) generatedSourceModel.getComponent("com.ClassA.ClassB")
+                .get().references().toArray()[0]).invokedComponent().equals("com.ClassD"));
 
-        assertTrue(generatedSourceModel.getComponent("com.ClassA.ClassB").get().componentInvocations().size() == 1);
+        assertTrue(generatedSourceModel.getComponent("com.ClassA.ClassB").get().references().size() == 1);
     }
 
     @Test
@@ -95,6 +95,6 @@ public void testAccurateImplementedTypesSizeForNestedClass() throws Exception {
         rawData.insertFile(new RawFile("file1", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("com.ClassA.ClassB").get().componentInvocations().size() == 1);
+        assertTrue(generatedSourceModel.getComponent("com.ClassA.ClassB").get().references().size() == 1);
     }
 }
diff --git a/clarpse/src/test/java/com/clarity/test/javascript/AccessModifiersTest.java b/clarpse/src/test/java/com/clarity/test/javascript/AccessModifiersTest.java
new file mode 100644
index 0000000..a2fb8a0
--- /dev/null
+++ b/clarpse/src/test/java/com/clarity/test/javascript/AccessModifiersTest.java
@@ -0,0 +1,73 @@
+package com.clarity.test.javascript;
+
+import com.clarity.compiler.ClarpseProject;
+import com.clarity.compiler.Lang;
+import com.clarity.compiler.RawFile;
+import com.clarity.compiler.SourceFiles;
+import com.clarity.sourcemodel.OOPSourceCodeModel;
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+
+public class AccessModifiersTest {
+
+    @Test
+    public void ES6StaticInstanceMethodAccessModifier() throws Exception {
+        final String code = "class Polygon { static say() {} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.say").get().modifiers().contains("static"));
+    }
+
+    @Test
+    public void ES6ClassAccessModifier() throws Exception {
+        final String code = "class Polygon { }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon").get().modifiers().isEmpty());
+    }
+
+    @Test
+    public void ES6InstanceMethodVarAccessModifier() throws Exception {
+        final String code = "class Polygon { say() { let test = 4; } }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.say.test").get().modifiers().isEmpty());
+    }
+
+    @Test
+    public void ES6ClassFieldAccessModifier() throws Exception {
+        final String code = "class Polygon { constructor() {this.height = 4;} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.height").get().modifiers().contains("private"));
+    }
+
+    @Test
+    public void ES6ClassConstructorAccessModifier() throws Exception {
+        final String code = "class Polygon { constructor() {} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.constructor").get().modifiers().isEmpty());
+    }
+
+    @Test
+    public void ES6StaticConstantModifier() throws Exception {
+        final String code = "class Polygon { static constant1 = 33; }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.constant1").get().modifiers().contains("static"));
+    }
+}
diff --git a/clarpse/src/test/java/com/clarity/test/javascript/ChildComponentsTest.java b/clarpse/src/test/java/com/clarity/test/javascript/ChildComponentsTest.java
new file mode 100644
index 0000000..0911593
--- /dev/null
+++ b/clarpse/src/test/java/com/clarity/test/javascript/ChildComponentsTest.java
@@ -0,0 +1,89 @@
+package com.clarity.test.javascript;
+
+import com.clarity.compiler.ClarpseProject;
+import com.clarity.compiler.Lang;
+import com.clarity.compiler.RawFile;
+import com.clarity.compiler.SourceFiles;
+import com.clarity.sourcemodel.OOPSourceCodeModel;
+import org.junit.Test;
+
+import static junit.framework.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public class ChildComponentsTest {
+
+    @Test
+    public void ES6InstanceMethodParamComponentIsChildOfInstanceMethod() throws Exception {
+        final String code = "class Polygon { constructor() {} say(height, length) {} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.say").get().children().contains("Polygon.say.height"));
+        assertTrue(generatedSourceModel.getComponent("Polygon.say").get().children().contains("Polygon.say.length"));
+    }
+
+    @Test
+    public void ES6GetterIsChildOfParentClass() throws Exception {
+        final String code = "class Polygon { get height() {} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon").get().children().get(0).equals("Polygon.get_height"));
+    }
+
+    @Test
+    public void ES6FieldVariableIsChildOfClass() throws Exception {
+        final String code = "class Polygon { constructor() {this.height = 4;} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon").get().children().get(1).equals("Polygon.height"));
+    }
+
+    @Test
+    public void ES6ConstructorIsChildOfParentClass() throws Exception {
+        final String code = "class Polygon { constructor() {} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon").get().children().get(0).equals("Polygon.constructor"));
+    }
+
+    @Test
+    public void ES6InstanceMethodIsChildOfParentClass() throws Exception {
+        final String code = "class Polygon { say() {} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon").get().children().get(0).equals("Polygon.say"));
+    }
+
+    @Test
+    public void ES6ConstructorParamComponentsIsChildOfConstructor() throws Exception {
+        final String code = "class Polygon { constructor(height, length) {} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.constructor").get().children().get(0)
+                .equals("Polygon.constructor.height"));
+        assertTrue(generatedSourceModel.getComponent("Polygon.constructor").get().children().get(1)
+                .equals("Polygon.constructor.length"));
+    }
+
+    @Test
+    public void ES6LocalVariableIsChildOfParentMethod() throws Exception {
+        final String code = "class Polygon { say() { var test = new React(); var lol = 4; }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.say").get().children().size() == 2);
+        assertTrue(generatedSourceModel.getComponent("Polygon.say").get().children().get(1).equals("Polygon.say.lol"));
+    }
+}
diff --git a/clarpse/src/test/java/com/clarity/test/javascript/CodeFragmentTest.java b/clarpse/src/test/java/com/clarity/test/javascript/CodeFragmentTest.java
new file mode 100644
index 0000000..2bbd5ea
--- /dev/null
+++ b/clarpse/src/test/java/com/clarity/test/javascript/CodeFragmentTest.java
@@ -0,0 +1,159 @@
+package com.clarity.test.javascript;
+
+import com.clarity.compiler.ClarpseProject;
+import com.clarity.compiler.Lang;
+import com.clarity.compiler.RawFile;
+import com.clarity.compiler.SourceFiles;
+import com.clarity.sourcemodel.OOPSourceCodeModel;
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+
+public class CodeFragmentTest {
+
+    @Test
+    public void ES6FieldVariableMultipleComponentTypes() throws Exception {
+        final String code = "class Polygon { constructor() {this.height = 4; this.width = false;} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.containsComponent("Polygon.height")
+                && generatedSourceModel.containsComponent("Polygon.width"));
+        assertTrue(generatedSourceModel.getComponent("Polygon.width").get().codeFragment()
+                .equals("width : Boolean"));
+    }
+
+    @Test
+    public void ES6FieldVariableBooleanValue() throws Exception {
+        final String code = "class Polygon { constructor(height) {this.height = true;} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.height").get().codeFragment()
+                .equals("height : Boolean"));
+    }
+
+    @Test
+    public void ES6FieldVariableStringValue() throws Exception {
+        final String code = "class Polygon { constructor(height) {this.height = \"test\";} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.height").get().codeFragment()
+                .equals("height : String"));
+    }
+
+    @Test
+    public void ES6FieldVariableNumberValue() throws Exception {
+        final String code = "class Polygon { constructor(height) {this.height = { num: 24 }} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.height").get().codeFragment()
+                .equals("height : Object"));
+    }
+
+    @Test
+    public void ES6FieldVariableTypeInstantiation() throws Exception {
+        final String code = "class React() {} class Polygon { constructor(height) {this.height = new React();} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.height").get().codeFragment()
+                .equals("height : React"));
+    }
+
+    @Test
+    public void ES6FieldVariableTypeInstantiationWithValues() throws Exception {
+        final String code = "class React() {} class Polygon { constructor(height) {this.height = new React(2,4,\"fe\");} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.height").get().codeFragment()
+                .equals("height : React"));
+    }
+
+    @Test
+    public void ES6FieldVariableNoTypeCodeFragment() throws Exception {
+        final String code = "class Polygon { constructor(someVar) {this.height = someVar;} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.height").get().codeFragment()
+                .equals("height"));
+    }
+
+    @Test
+    public void ES6ClassConstructorCodeFragment() throws Exception {
+        final String code = "class Polygon { constructor(height) {this.height = height;} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.constructor").get().codeFragment()
+                .equals("constructor(height)"));
+    }
+
+    @Test
+    public void ES6ClassMethodCodeFragment() throws Exception {
+        final String code = "class Polygon { walk(height) {} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.walk").get().codeFragment()
+                .equals("walk(height)"));
+    }
+
+    @Test
+    public void ES6ClassMethodMultipleParamsWithNoSpacesCodeFragment() throws Exception {
+        final String code = "class Polygon { walk(height,length) {} }"; // no space b/w params
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.walk").get().codeFragment()
+                .equals("walk(height, length)")); // Code fragment has space b/w params.
+    }
+
+    @Test
+    public void ES6ClassMethodParamWithDefaultValueCodeFragment() throws Exception {
+        final String code = "class Polygon { walk(height = 4) {} }"; // no space b/w params
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.walk").get().codeFragment()
+                .equals("walk(height)")); // Code fragment has space b/w params.
+    }
+
+    @Test
+    public void ES6ClassGetterMethodCodeFragment() throws Exception {
+        final String code = "class Polygon extends Test {get prop() {return 'getter'; }}";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.get_prop").get().codeFragment()
+                .equals("get_prop()"));
+    }
+
+    @Test
+    public void ES6ClassSetterMethodCodeFragment() throws Exception {
+        final String code = "class Polygon extends Test { constructor() {this.fieldVar = 4;} set prop(newVal) " +
+                "{this.fieldVar = newVal; }}";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.set_prop").get().codeFragment()
+                .equals("set_prop(newVal)"));
+    }
+}
diff --git a/clarpse/src/test/java/com/clarity/test/javascript/CommentsParsingTest.java b/clarpse/src/test/java/com/clarity/test/javascript/CommentsParsingTest.java
new file mode 100644
index 0000000..8c2d1b3
--- /dev/null
+++ b/clarpse/src/test/java/com/clarity/test/javascript/CommentsParsingTest.java
@@ -0,0 +1,66 @@
+package com.clarity.test.javascript;
+
+import com.clarity.compiler.ClarpseProject;
+import com.clarity.compiler.Lang;
+import com.clarity.compiler.RawFile;
+import com.clarity.compiler.SourceFiles;
+import com.clarity.sourcemodel.OOPSourceCodeModel;
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+
+public class CommentsParsingTest {
+
+    @Test
+    public void ES6ClassDoc() throws Exception {
+        final String code = "/**Test*/ class Polygon extends Test {get prop() {return 'getter'; }}";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon").get().comment().equals("/**Test*/"));
+    }
+
+    @Test
+    public void ES6InstanceMethodDoc() throws Exception {
+        final String code = "class Polygon { /** say doc \n comment */ say() {} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.say").get().comment().equals("/** say doc \n comment */"));
+    }
+
+    @Test
+    public void ES6ClassFieldVarDoc() throws Exception {
+        final String code = "class Polygon { constructor() {/** the height of /n some stuff \n */ \nthis.height = 4;} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.height").get().comment().equals("/** the height of /n some stuff \n" +
+                " */"));
+    }
+
+    @Test
+    public void ES6LocalVarDoc() throws Exception {
+        final String code = "class Polygon { constructor() { /** some local var docs */ \n var test;} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.constructor.test").get().comment().equals(
+                "/** some local var docs */"));
+    }
+
+    @Test
+    public void ES6ConstructorDoc() throws Exception {
+        final String code = "class Polygon { /** constructor doc */ constructor() {} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.constructor").get().comment().equals(
+                "/** constructor doc */"));
+    }
+}
diff --git a/clarpse/src/test/java/com/clarity/test/javascript/ComponentSourceFilePathTest.java b/clarpse/src/test/java/com/clarity/test/javascript/ComponentSourceFilePathTest.java
new file mode 100644
index 0000000..64e87c6
--- /dev/null
+++ b/clarpse/src/test/java/com/clarity/test/javascript/ComponentSourceFilePathTest.java
@@ -0,0 +1,59 @@
+package com.clarity.test.javascript;
+
+
+import com.clarity.compiler.ClarpseProject;
+import com.clarity.compiler.Lang;
+import com.clarity.compiler.RawFile;
+import com.clarity.compiler.SourceFiles;
+import com.clarity.sourcemodel.Component;
+import com.clarity.sourcemodel.OOPSourceCodeModel;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+
+/**
+ * Ensure components are displaying the correct associated source file path.
+ */
+public class ComponentSourceFilePathTest {
+
+    @Test
+    public void ES6ClassHasCorrectSourceFileAttr() throws Exception {
+        final String code = "class Polygon {}";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon").get().sourceFile().equals("polygon.js"));
+    }
+
+    @Test
+    public void ES6ClassMethodHasCorrectSourceFileAttr() throws Exception {
+        final String code = "class Polygon { say() {}}";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.say").get().sourceFile().equals("polygon.js"));
+    }
+
+    @Test
+    public void ES6ClassConstructorHasCorrectSourceFileAttr() throws Exception {
+        final String code = "class Polygon { constructor() {}}";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.constructor").get().sourceFile().equals("polygon.js"));
+    }
+
+    @Test
+    public void ES6ClassFieldVarHasCorrectSourceFileAttr() throws Exception {
+        final String code = "class Polygon { constructor() {this.height = 4;}}";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.height").get().sourceFile().equals("polygon.js"));
+    }
+}
diff --git a/clarpse/src/test/java/com/clarity/test/javascript/ComponentTypeTest.java b/clarpse/src/test/java/com/clarity/test/javascript/ComponentTypeTest.java
new file mode 100644
index 0000000..fb1e5b7
--- /dev/null
+++ b/clarpse/src/test/java/com/clarity/test/javascript/ComponentTypeTest.java
@@ -0,0 +1,123 @@
+package com.clarity.test.javascript;
+
+import com.clarity.ClarpseUtil;
+import com.clarity.compiler.ClarpseProject;
+import com.clarity.compiler.Lang;
+import com.clarity.compiler.RawFile;
+import com.clarity.compiler.SourceFiles;
+import com.clarity.sourcemodel.Component;
+import com.clarity.sourcemodel.OOPSourceCodeModel;
+import com.clarity.sourcemodel.OOPSourceModelConstants;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import java.util.Optional;
+
+import static org.junit.Assert.assertTrue;
+
+/**
+ * Tests to ensure component type attribute of parsed components are accurate.
+ */
+public class ComponentTypeTest {
+
+    @Test
+    public void ES6ClassHasCorrectComponentType() throws Exception {
+        final String code = "\n\n class Polygon { }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon").get()
+                .componentType() == OOPSourceModelConstants.ComponentType.CLASS);
+    }
+
+    @Test
+    public void testParsedES6InstanceMethodParamComponentType() throws Exception {
+        final String code = "class Polygon { constructor() {} say(height) {}}";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.say.height")
+                .get().componentType() == OOPSourceModelConstants.ComponentType.METHOD_PARAMETER_COMPONENT);
+    }
+
+    @Test
+    public void ES6ConstructorComponentTypeIsCorrect() throws Exception {
+        final String code = "class Polygon { constructor() {} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(
+                generatedSourceModel.getComponent("Polygon.constructor").get()
+                        .componentType() == OOPSourceModelConstants.ComponentType.CONSTRUCTOR);
+    }
+
+    @Test
+    public void ES6LocalVariableComponentType() throws Exception {
+        final String code = "class Polygon { say() { var test = new React(); }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.say.test").get()
+                .componentType() == OOPSourceModelConstants.ComponentType.LOCAL);
+    }
+
+    @Test
+    public void ES6LocalLetVariableComponentType() throws Exception {
+        final String code = "class Polygon { say() { let test = new React(); }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.say.test")
+                .get().componentType() == OOPSourceModelConstants.ComponentType.LOCAL);
+    }
+
+    @Test
+    public void ES6FieldVariableComponentType() throws Exception {
+        final String code = "class Polygon { constructor() {this.height = 4;} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.height")
+                .get().componentType() == OOPSourceModelConstants.ComponentType.FIELD);
+    }
+
+    @Test
+    public void ES6SetterMethodComponentTypeIsCorrect() throws Exception {
+        final String code = "class Polygon { set height(value) {} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.set_height").get()
+                .componentType() == OOPSourceModelConstants.ComponentType.METHOD);
+    }
+
+    @Test
+    public void testParsedES6ConstructorParamComponentType() throws Exception {
+        final String code = "class Polygon { constructor(height) {} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.constructor.height")
+                .get().componentType() == OOPSourceModelConstants.ComponentType.CONSTRUCTOR_PARAMETER_COMPONENT);
+    }
+
+    @Test
+    public void ES6InstanceMethodComponentTypeIsCorrect() throws Exception {
+        final String code = "class Polygon { say() {} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.say").get()
+                .componentType() == OOPSourceModelConstants.ComponentType.METHOD);
+    }
+}
diff --git a/clarpse/src/test/java/com/clarity/test/javascript/CycloTest.java b/clarpse/src/test/java/com/clarity/test/javascript/CycloTest.java
new file mode 100644
index 0000000..d408e9d
--- /dev/null
+++ b/clarpse/src/test/java/com/clarity/test/javascript/CycloTest.java
@@ -0,0 +1,83 @@
+package com.clarity.test.javascript;
+
+import com.clarity.compiler.ClarpseProject;
+import com.clarity.compiler.Lang;
+import com.clarity.compiler.RawFile;
+import com.clarity.compiler.SourceFiles;
+import com.clarity.sourcemodel.OOPSourceCodeModel;
+import com.clarity.sourcemodel.OOPSourceModelConstants;
+import org.junit.Assert;
+import org.junit.Test;
+
+import static junit.framework.Assert.assertTrue;
+
+/**
+ * Tests accuracy of Component cyclomatic complexity attribute. See {@link com.clarity.sourcemodel.Component}.
+ */
+public class CycloTest {
+
+    @Test
+    public void testES6AndIfCyclo() throws Exception {
+        final String code = "class Polygon { constructor() {  if (true == false && false == true || true) {} } }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("/src/test/polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        Assert.assertTrue(generatedSourceModel.getComponent("src.test.Polygon.constructor")
+                .get().cyclo() == 4);
+    }
+
+    @Test
+    public void testES6HookCyclo() throws Exception {
+        final String code = "class Polygon { constructor() {  x = true ? true : false } }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("/src/test/polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        Assert.assertTrue(generatedSourceModel.getComponent("src.test.Polygon.constructor")
+                .get().cyclo() == 2);
+    }
+
+    @Test
+    public void testEmptyMethodCyclo() throws Exception {
+        final String code = "class Polygon { constructor() { } }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("/src/test/polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        Assert.assertTrue(generatedSourceModel.getComponent("src.test.Polygon")
+                .get().cyclo() == 1);
+    }
+
+    @Test
+    public void testES6ClassCyclo() throws Exception {
+        final String code = "class Polygon { say() {  if (true == false && false == true || true) {} }  " +
+                "bye() {  x = true ? true : false } }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("/src/test/polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        Assert.assertTrue(generatedSourceModel.getComponent("src.test.Polygon")
+                .get().cyclo() == 3);
+    }
+
+    @Test
+    public void testES6SwitchStatementCyclo() throws Exception {
+        final String code = "class Polygon { say() {  switch(expression) {\n" +
+                "  case x:\n" +
+                "    // code block\n" +
+                "    break;\n" +
+                "  case y:\n" +
+                "    // code block\n" +
+                "    break;\n" +
+                "  default:\n" +
+                "    // code block\n" +
+                "} } }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("/src/test/polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        Assert.assertTrue(generatedSourceModel.getComponent("src.test.Polygon.say")
+                .get().cyclo() == 4);
+    }
+}
diff --git a/clarpse/src/test/java/com/clarity/test/javascript/InvocationInheritanceTest.java b/clarpse/src/test/java/com/clarity/test/javascript/InvocationInheritanceTest.java
new file mode 100644
index 0000000..263bbb4
--- /dev/null
+++ b/clarpse/src/test/java/com/clarity/test/javascript/InvocationInheritanceTest.java
@@ -0,0 +1,65 @@
+package com.clarity.test.javascript;
+
+import com.clarity.compiler.ClarpseProject;
+import com.clarity.compiler.Lang;
+import com.clarity.compiler.RawFile;
+import com.clarity.compiler.SourceFiles;
+import com.clarity.sourcemodel.OOPSourceCodeModel;
+import com.clarity.sourcemodel.OOPSourceModelConstants;
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+
+/**
+ * Ensure component invocations for a given component are inherited by its
+ * parents.
+ */
+public class InvocationInheritanceTest {
+
+    @Test
+    public void ES6ClassInheritsFieldVarInvocations() throws Exception {
+        final String code = "import React from 'react'; \nclass Polygon { constructor() {this.height = new React();} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0)
+                .invokedComponent().equals("React"));
+    }
+
+    @Test
+    public void ES6ClassInheritsMethodLocalVarInvocations() throws Exception {
+        final String code = "import React from 'react'; \nclass Polygon { test() { let height = new React();} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.test")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0)
+                .invokedComponent().equals("React"));
+    }
+
+    @Test
+    public void ES6ConstructorDoesNotInheritFieldVarInvocations() throws Exception {
+        final String code = "import React from 'react'; \nclass Polygon { constructor() {this.height = new React();} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.constructor")
+                .get().references().size() == 0);
+    }
+
+    @Test
+    public void ES6ClassInheritsGetterMethodInvocations() throws Exception {
+        final String code = "import React from 'react'; \nclass Polygon { get test() {var height = new React();} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.get_test")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0)
+                .invokedComponent().equals("React"));
+    }
+}
diff --git a/clarpse/src/test/java/com/clarity/test/javascript/JavaScriptSmokeTest.java b/clarpse/src/test/java/com/clarity/test/javascript/JavaScriptSmokeTest.java
index 8267096..f8f6795 100644
--- a/clarpse/src/test/java/com/clarity/test/javascript/JavaScriptSmokeTest.java
+++ b/clarpse/src/test/java/com/clarity/test/javascript/JavaScriptSmokeTest.java
@@ -5,7 +5,7 @@
 import com.clarity.compiler.RawFile;
 import com.clarity.compiler.SourceFiles;
 import com.clarity.sourcemodel.OOPSourceCodeModel;
-import com.clarity.sourcemodel.OOPSourceModelConstants.ComponentInvocations;
+import com.clarity.sourcemodel.OOPSourceModelConstants.TypeReferences;
 import org.apache.commons.io.IOUtils;
 import org.junit.BeforeClass;
 import org.junit.Ignore;
@@ -13,7 +13,6 @@
 
 import static org.junit.Assert.assertTrue;
 
-@Ignore
 public class JavaScriptSmokeTest {
 
 	private static OOPSourceCodeModel generatedSourceModel;
@@ -60,7 +59,7 @@ public void TestAllMethodsWereParsed() {
 
 	@Test
 	public void testSquareExtendsPolygon() {
-		assertTrue(generatedSourceModel.getComponent("Square").get().componentInvocations(ComponentInvocations.EXTENSION)
+		assertTrue(generatedSourceModel.getComponent("Square").get().references(TypeReferences.EXTENSION)
 				.get(0).invokedComponent().equals("Polygon"));
 	}
 
diff --git a/clarpse/src/test/java/com/clarity/test/javascript/JavascriptParseTest.java b/clarpse/src/test/java/com/clarity/test/javascript/JavascriptParseTest.java
index f9679fc..1f7cba3 100644
--- a/clarpse/src/test/java/com/clarity/test/javascript/JavascriptParseTest.java
+++ b/clarpse/src/test/java/com/clarity/test/javascript/JavascriptParseTest.java
@@ -5,19 +5,16 @@
 import com.clarity.compiler.RawFile;
 import com.clarity.compiler.SourceFiles;
 import com.clarity.sourcemodel.OOPSourceCodeModel;
-import com.clarity.sourcemodel.OOPSourceModelConstants.ComponentInvocations;
-import com.clarity.sourcemodel.OOPSourceModelConstants.ComponentType;
+import com.clarity.sourcemodel.OOPSourceModelConstants.TypeReferences;
 import org.junit.Ignore;
 import org.junit.Test;
 
 import static org.junit.Assert.assertTrue;
 
-@Ignore
 public class JavascriptParseTest {
 
     @Test
     public void ES6ClassExists() throws Exception {
-
         final String code = "class Polygon extends Test {get prop() {return 'getter'; }}";
         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
         rawData.insertFile(new RawFile("polygon.js", code));
@@ -27,19 +24,7 @@ public void ES6ClassExists() throws Exception {
     }
 
     @Test
-    public void ES6ClassDoc() throws Exception {
-
-        final String code = "/**Test*/ class Polygon extends Test {get prop() {return 'getter'; }}";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon").get().comment().equals("/**Test*/"));
-    }
-
-    @Test
-    public void ES6ClassesExists() throws Exception {
-
+    public void ClassesExists() throws Exception {
         final String code = "class Polygon {} class LolCakes{}";
         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
         rawData.insertFile(new RawFile("polygon.js", code));
@@ -50,8 +35,7 @@ public void ES6ClassesExists() throws Exception {
     }
 
     @Test
-    public void ES6ClassExpressionComponentExists() throws Exception {
-
+    public void ClassExpressionComponentExists() throws Exception {
         final String code = "const test = class Polygon {};";
         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
         rawData.insertFile(new RawFile("polygon.js", code));
@@ -61,64 +45,7 @@ public void ES6ClassExpressionComponentExists() throws Exception {
     }
 
     @Test
-    public void ES6ClassHasCorrectSourceFileAttr() throws Exception {
-
-        final String code = "class Polygon {}";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon").get().sourceFile().equals("polygon.js"));
-    }
-
-    @Test
-    public void ES6ClassHasCorrectComponentType() throws Exception {
-
-        final String code = "\n\n class Polygon { }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon").get().componentType() == ComponentType.CLASS);
-    }
-
-    @Test
-    public void testIfParseES6ClassHasCorrectExtendsAttr() throws Exception {
-
-        final String code = "class Polygon extends Shape { }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        // assert the Polygon class component has one type extension component
-        // invocation
-        assertTrue(generatedSourceModel.getComponent("Polygon").get().componentInvocations(ComponentInvocations.EXTENSION)
-                .size() == 1);
-        // assert the component being extended is the Shape class
-        assertTrue(generatedSourceModel.getComponent("Polygon").get().componentInvocations(ComponentInvocations.EXTENSION)
-                .get(0).invokedComponent().equals("Shape"));
-    }
-
-    @Test
-    public void testIfParseES6ClassHasCorrectExtendsAttrComplex() throws Exception {
-
-        final String code = "import { Shape as Shape} from 'shape.js' \n class Polygon extends Shape { }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        // assert the Polygon class component has one type extension component
-        // invocation
-        assertTrue(generatedSourceModel.getComponent("Polygon").get().componentInvocations(ComponentInvocations.EXTENSION)
-                .size() == 1);
-        // assert the component being extended is the Shape class
-        assertTrue(generatedSourceModel.getComponent("Polygon").get().componentInvocations(ComponentInvocations.EXTENSION)
-                .get(0).invokedComponent().equals("Shape"));
-    }
-
-    @Test
-    public void ES6ConstructorFunctionExists() throws Exception {
-
+    public void ConstructorFunctionExists() throws Exception {
         final String code = "class Polygon { constructor() {} }";
         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
         rawData.insertFile(new RawFile("polygon.js", code));
@@ -128,30 +55,7 @@ public void ES6ConstructorFunctionExists() throws Exception {
     }
 
     @Test
-    public void ES6ConstructorDoc() throws Exception {
-
-        final String code = "class Polygon { /** constructor doc */ constructor() {} }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon.constructor").get().comment().equals("/** constructor doc */"));
-    }
-
-    @Test
-    public void ES6ConstructorIsChildOfParentClass() throws Exception {
-
-        final String code = "class Polygon { constructor() {} }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon").get().children().get(0).equals("Polygon.constructor"));
-    }
-
-    @Test
-    public void ES6ConstructorFunctionNameIsCorrect() throws Exception {
-
+    public void ConstructorFunctionNameIsCorrect() throws Exception {
         final String code = "class Polygon { constructor() {} }";
         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
         rawData.insertFile(new RawFile("polygon.js", code));
@@ -161,32 +65,7 @@ public void ES6ConstructorFunctionNameIsCorrect() throws Exception {
     }
 
     @Test
-    public void lineNumberTest() {
-    }
-
-    @Test
-    public void fieldComponentValue() {
-    }
-
-    @Test
-    public void methodComponentValue() {
-    }
-
-    @Test
-    public void ES6ConstructorComponentTypeIsCorrect() throws Exception {
-
-        final String code = "class Polygon { constructor() {} }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(
-                generatedSourceModel.getComponent("Polygon.constructor").get().componentType() == ComponentType.CONSTRUCTOR);
-    }
-
-    @Test
-    public void ES6ConstructorParamComponentExists() throws Exception {
-
+    public void ConstructorParamComponentExists() throws Exception {
         final String code = "class Polygon { constructor(height) {call();} }";
         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
         rawData.insertFile(new RawFile("polygon.js", code));
@@ -196,8 +75,7 @@ public void ES6ConstructorParamComponentExists() throws Exception {
     }
 
     @Test
-    public void ES6ConstructorParamComponentsExists() throws Exception {
-
+    public void ConstructorParamComponentsExists() throws Exception {
         final String code = "class Polygon { constructor(height, length, width) {call();} }";
         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
         rawData.insertFile(new RawFile("polygon.js", code));
@@ -209,34 +87,7 @@ public void ES6ConstructorParamComponentsExists() throws Exception {
     }
 
     @Test
-    public void ES6ConstructorParamComponentsIsChildOfConstructor() throws Exception {
-
-        final String code = "class Polygon { constructor(height, length) {} }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon.constructor").get().children().get(0)
-                .equals("Polygon.constructor.height"));
-        assertTrue(generatedSourceModel.getComponent("Polygon.constructor").get().children().get(1)
-                .equals("Polygon.constructor.length"));
-    }
-
-    @Test
-    public void testParsedES6ConstructorParamComponentType() throws Exception {
-
-        final String code = "class Polygon { constructor(height) {} }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon.constructor.height")
-                .get().componentType() == ComponentType.CONSTRUCTOR_PARAMETER_COMPONENT);
-    }
-
-    @Test
-    public void ES6InstanceMethodExists() throws Exception {
-
+    public void InstanceMethodExists() throws Exception {
         final String code = "class Polygon { say() {} }";
         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
         rawData.insertFile(new RawFile("polygon.js", code));
@@ -246,30 +97,7 @@ public void ES6InstanceMethodExists() throws Exception {
     }
 
     @Test
-    public void ES6InstanceMethodDoc() throws Exception {
-
-        final String code = "class Polygon { /** say doc \n comment */ say() {} }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon.say").get().comment().equals("/** say doc \n comment */"));
-    }
-
-    @Test
-    public void ES6InstanceMethodIsChildOfParentClass() throws Exception {
-
-        final String code = "class Polygon { say() {} }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon").get().children().get(0).equals("Polygon.say"));
-    }
-
-    @Test
-    public void ES6InstanceMethodNameIsCorrect() throws Exception {
-
+    public void InstanceMethodNameIsCorrect() throws Exception {
         final String code = "class Polygon { say() {} }";
         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
         rawData.insertFile(new RawFile("polygon.js", code));
@@ -279,19 +107,7 @@ public void ES6InstanceMethodNameIsCorrect() throws Exception {
     }
 
     @Test
-    public void ES6InstanceMethodComponentTypeIsCorrect() throws Exception {
-
-        final String code = "class Polygon { say() {} }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon.say").get().componentType() == ComponentType.METHOD);
-    }
-
-    @Test
-    public void ES6StaticInstanceMethodExists() throws Exception {
-
+    public void StaticInstanceMethodExists() throws Exception {
         final String code = "class Polygon { static say() {} }";
         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
         rawData.insertFile(new RawFile("polygon.js", code));
@@ -301,30 +117,7 @@ public void ES6StaticInstanceMethodExists() throws Exception {
     }
 
     @Test
-    public void ES6StaticInstanceMethodAccessModifier() throws Exception {
-
-        final String code = "class Polygon { static say() {} }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon.say").get().modifiers().contains("static"));
-    }
-
-    @Test
-    public void ES6StaticConstantModifier() throws Exception {
-
-        final String code = "class Polygon { static constant1 = 33; }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon.constant1").get().modifiers().contains("static"));
-    }
-
-    @Test
-    public void ES6AsyncInstanceMethodExists() throws Exception {
-
+    public void AsyncInstanceMethodExists() throws Exception {
         final String code = "class Polygon { static say() {} }";
         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
         rawData.insertFile(new RawFile("polygon.js", code));
@@ -334,8 +127,7 @@ public void ES6AsyncInstanceMethodExists() throws Exception {
     }
 
     @Test
-    public void ES6InstanceMethodParamComponentExists() throws Exception {
-
+    public void InstanceMethodParamComponentExists() throws Exception {
         final String code = "class Polygon { constructor() {} call(height) {} }";
         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
         rawData.insertFile(new RawFile("polygon.js", code));
@@ -345,8 +137,7 @@ public void ES6InstanceMethodParamComponentExists() throws Exception {
     }
 
     @Test
-    public void ES6InstanceMethodParamComponentsExists() throws Exception {
-
+    public void InstanceMethodParamComponentsExists() throws Exception {
         final String code = "class Polygon { constructor() {} call(height, length, width) {} }";
         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
         rawData.insertFile(new RawFile("polygon.js", code));
@@ -358,32 +149,7 @@ public void ES6InstanceMethodParamComponentsExists() throws Exception {
     }
 
     @Test
-    public void ES6InstanceMethodParamComponentIsChildOfInstanceMethod() throws Exception {
-
-        final String code = "class Polygon { constructor() {} say(height, length) {} }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon.say").get().children().get(0).equals("Polygon.say.height"));
-        assertTrue(generatedSourceModel.getComponent("Polygon.say").get().children().get(1).equals("Polygon.say.length"));
-    }
-
-    @Test
-    public void testParsedES6InstanceMethodParamComponentType() throws Exception {
-
-        final String code = "class Polygon { constructor() {} say(height) {}}";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon.say.height")
-                .get().componentType() == ComponentType.METHOD_PARAMETER_COMPONENT);
-    }
-
-    @Test
-    public void ES6GetterMethodExists() throws Exception {
-
+    public void GetterMethodExists() throws Exception {
         final String code = "class Polygon { get height() {} }";
         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
         rawData.insertFile(new RawFile("polygon.js", code));
@@ -393,30 +159,7 @@ public void ES6GetterMethodExists() throws Exception {
     }
 
     @Test
-    public void ES6GetterIsChildOfParentClass() throws Exception {
-
-        final String code = "class Polygon { get height() {} }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon").get().children().get(0).equals("Polygon.get_height"));
-    }
-
-    @Test
-    public void ES6SetterMethodComponentTypeIsCorrect() throws Exception {
-
-        final String code = "class Polygon { set height(value) {} }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon.set_height").get().componentType() == ComponentType.METHOD);
-    }
-
-    @Test
-    public void ES6SetterMethodExists() throws Exception {
-
+    public void SetterMethodExists() throws Exception {
         final String code = "class Polygon { set height(str) {} }";
         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
         rawData.insertFile(new RawFile("polygon.js", code));
@@ -426,8 +169,7 @@ public void ES6SetterMethodExists() throws Exception {
     }
 
     @Test
-    public void ES6FieldVariableComponentExists() throws Exception {
-
+    public void FieldVariableComponentExists() throws Exception {
         final String code = "class Polygon { constructor() {this.height = 4;} }";
         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
         rawData.insertFile(new RawFile("polygon.js", code));
@@ -437,8 +179,7 @@ public void ES6FieldVariableComponentExists() throws Exception {
     }
 
     @Test
-    public void ES6FieldVariableComponentName() throws Exception {
-
+    public void FieldVariableComponentName() throws Exception {
         final String code = "class Polygon { constructor() {this.height = 4;} }";
         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
         rawData.insertFile(new RawFile("polygon.js", code));
@@ -448,143 +189,7 @@ public void ES6FieldVariableComponentName() throws Exception {
     }
 
     @Test
-    public void ES6FieldVariableComponentType() throws Exception {
-
-        final String code = "class Polygon { constructor() {this.height = 4;} }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon.height").get().componentType() == ComponentType.FIELD);
-    }
-
-    @Test
-    public void ES6FieldVariableMultipleComponentTypes() throws Exception {
-
-        final String code = "class Polygon { constructor() {this.height = 4; this.width = false;} }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.containsComponent("Polygon.height")
-                && generatedSourceModel.containsComponent("Polygon.width"));
-
-        assertTrue(generatedSourceModel.getComponent("Polygon.width").get().codeFragment().equals("Boolean"));
-    }
-
-    @Test
-    public void ES6FieldVariableIsChildOfClass() throws Exception {
-
-        final String code = "class Polygon { constructor() {this.height = 4;} }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon").get().children().get(1).equals("Polygon.height"));
-    }
-
-    @Test
-    public void ES6FieldVariableBooleanValue() throws Exception {
-
-        final String code = "class Polygon { constructor(height) {this.height = true;} }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon.height").get().codeFragment().equals("true"));
-    }
-
-    @Test
-    public void ES6FieldVariableStringValue() throws Exception {
-
-        final String code = "class Polygon { constructor(height) {this.height = \"test\";} }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon.height").get().codeFragment().equals("test"));
-    }
-
-    @Test
-    public void ES6FieldVariableNumberValue() throws Exception {
-
-        final String code = "class Polygon { constructor(height) {this.height = 56;} }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon.height").get().codeFragment().equals("56"));
-    }
-
-    @Test
-    public void ES6FieldVariableNumberDeclarationTypeSnippet() throws Exception {
-
-        final String code = "class Polygon { constructor(height) {this.height = 56;} }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon.height").get().codeFragment().equals("Number"));
-    }
-
-    @Test
-    public void ES6FieldVariableStringDeclarationTypeSnippet() throws Exception {
-
-        final String code = "class Polygon { constructor(height) {this.height = \"test\";} }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon.height").get().codeFragment().equals("String"));
-    }
-
-    @Test
-    public void ES6FieldVariableBooleanDeclarationTypeSnippet() throws Exception {
-
-        final String code = "class Polygon { constructor(height) {this.height = false;} }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon.height").get().codeFragment().equals("Boolean"));
-    }
-
-    @Test
-    public void ES6FieldVariableTypeInstantiation() throws Exception {
-
-        final String code = "class React() {} class Polygon { constructor(height) {this.height = new React();} }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon.height").get().codeFragment().equals("React"));
-    }
-
-    @Test
-    public void ES6FieldVariablePackageName() throws Exception {
-
-        final String code = "class React() {} class Polygon { constructor(height) {this.height = new React();} }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("/github/http/polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("github.http.Polygon.height").get().packageName().equals("github.http"));
-    }
-
-    @Test
-    public void ES6FieldVariableTypeInstantiationWithValues() throws Exception {
-
-        final String code = "class React() {} class Polygon { constructor(height) {this.height = new React(2,4,\"fe\");} }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon.height").get().codeFragment().equals("React"));
-    }
-
-    @Test
-    public void ES6LocalVariableExists() throws Exception {
-
+    public void LocalVariableExists() throws Exception {
         final String code = "class React() {} class Polygon { say() { var test = new React(); }";
         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
         rawData.insertFile(new RawFile("polygon.js", code));
@@ -594,30 +199,7 @@ public void ES6LocalVariableExists() throws Exception {
     }
 
     @Test
-    public void ES6LocalVariableComponentType() throws Exception {
-
-        final String code = "class Polygon { say() { var test = new React(); }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon.say.test").get().componentType() == ComponentType.LOCAL);
-    }
-
-    @Test
-    public void ES6LocalLetVariableComponentType() throws Exception {
-
-        final String code = "class Polygon { say() { let test = new React(); }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon.say.test").get().componentType() == ComponentType.LOCAL);
-    }
-
-    @Test
-    public void ES6LocalLetVariableComponentExists() throws Exception {
-
+    public void LocalLetVariableComponentExists() throws Exception {
         final String code = "class Polygon { say() { let test = new React(); }";
         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
         rawData.insertFile(new RawFile("polygon.js", code));
@@ -627,55 +209,7 @@ public void ES6LocalLetVariableComponentExists() throws Exception {
     }
 
     @Test
-    public void ES6LocalLetVariableTypeDeclaration() throws Exception {
-
-        final String code = "class Polygon { say() { let test = new React(); }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon.say.test")
-                .get().componentInvocations(ComponentInvocations.INSTANTIATION).get(0).invokedComponent().equals("React"));
-    }
-
-    @Test
-    public void ES6LocalVariableIsChildOfParentMethod() throws Exception {
-
-        final String code = "class Polygon { say() { var test = new React(); var lol = 4; }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon.say").get().children().size() == 2);
-        assertTrue(generatedSourceModel.getComponent("Polygon.say").get().children().get(1).equals("Polygon.say.lol"));
-    }
-
-    @Test
-    public void ES6LocalVariableTypeInstantiation() throws Exception {
-
-        final String code = "class Polygon { say() { var test = new React(); var lol = 4; }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon.say.test")
-                .get().componentInvocations(ComponentInvocations.INSTANTIATION).get(0).invokedComponent().equals("React"));
-    }
-
-    @Test
-    public void ES6LocalVariablePackageName() throws Exception {
-
-        final String code = "class Polygon { say() { var test = new React(); var lol = 4; }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("src/polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon.say.test").get().packageName().equals(""));
-    }
-
-    @Test
-    public void MultipleES6LocalVariables() throws Exception {
-
+    public void MultipleLocalVariables() throws Exception {
         final String code = "class Polygon { say() { var test = new React(); var lol = 4; }";
         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
         rawData.insertFile(new RawFile("polygon.js", code));
@@ -687,18 +221,16 @@ public void MultipleES6LocalVariables() throws Exception {
 
     @Test
     public void testDefaultExportClassHasCorrectUniqueName() throws Exception {
-
         final String code = "export default class { }";
         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
         rawData.insertFile(new RawFile("/src/github/test.js", code));
         final ClarpseProject parseService = new ClarpseProject(rawData);
         final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.containsComponent("github.test"));
+        assertTrue(generatedSourceModel.containsComponent("src.github.test"));
     }
 
     @Test
-    public void ES6ConstructorLocalVar() throws Exception {
-
+    public void ConstructorLocalVar() throws Exception {
         final String code = "class Polygon { constructor() {  this.width = 4;  var test = new React(); } }";
         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
         rawData.insertFile(new RawFile("polygon.js", code));
@@ -706,72 +238,4 @@ public void ES6ConstructorLocalVar() throws Exception {
         final OOPSourceCodeModel generatedSourceModel = parseService.result();
         assertTrue(generatedSourceModel.containsComponent("Polygon.constructor.test"));
     }
-
-    @Test
-    public void ES6MethodTypeDeclaration() throws Exception {
-
-        final String code = "class Polygon { constructor() {  new React().test(); } }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("Polygon.constructor")
-                .get().componentInvocations(ComponentInvocations.INSTANTIATION).get(0).invokedComponent().equals("React"));
-    }
-
-    @Test
-    public void ES6MethodPackageName() throws Exception {
-
-        final String code = "class Polygon { constructor() {  new React().test(); } }";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("/github/polygon.js", code));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("github.Polygon.constructor").get().packageName().equals("github"));
-    }
-
-    @Test
-    public void ES6MethodTypeDeclarationFromStaticMethodCall() throws Exception {
-
-        final String code = "import { React } from \'github/react.js\'; \n class Polygon { constructor() {  React.test(); } }";
-        final String codeB = "class React {}";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("/src/test/polygon.js", code));
-        rawData.insertFile(new RawFile("/src/test/github/react.js", codeB));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("test.Polygon.constructor")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).get(0).invokedComponent()
-                .equals("test.github.React"));
-    }
-
-    @Test
-    public void testResolvingOfAbsoluteImportPath() throws Exception {
-
-        final String code = "import { React } from \'/src/test/github/react.js\'; \n class Polygon { constructor() {  React.test(); } }";
-        final String codeB = "class React {}";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("/src/test/polygon.js", code));
-        rawData.insertFile(new RawFile("/src/test/github/react.js", codeB));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("test.Polygon.constructor")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).get(0).invokedComponent()
-                .equals("test.github.React"));
-    }
-
-    @Test
-    public void testResolvingOfAliasImportType() throws Exception {
-
-        final String code = "import { LoL as React } from \'/src/test/github/react.js\'; \n class Polygon { constructor() {  LoL.test(); } }";
-        final String codeB = "class React {}";
-        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
-        rawData.insertFile(new RawFile("/src/test/polygon.js", code));
-        rawData.insertFile(new RawFile("/src/test/github/react.js", codeB));
-        final ClarpseProject parseService = new ClarpseProject(rawData);
-        final OOPSourceCodeModel generatedSourceModel = parseService.result();
-        assertTrue(generatedSourceModel.getComponent("test.Polygon.constructor")
-                .get().componentInvocations(ComponentInvocations.DECLARATION).get(0).invokedComponent()
-                .equals("test.github.React"));
-    }
 }
diff --git a/clarpse/src/test/java/com/clarity/test/javascript/PackageAttributeTest.java b/clarpse/src/test/java/com/clarity/test/javascript/PackageAttributeTest.java
new file mode 100644
index 0000000..99b650a
--- /dev/null
+++ b/clarpse/src/test/java/com/clarity/test/javascript/PackageAttributeTest.java
@@ -0,0 +1,68 @@
+package com.clarity.test.javascript;
+
+import com.clarity.compiler.ClarpseProject;
+import com.clarity.compiler.Lang;
+import com.clarity.compiler.RawFile;
+import com.clarity.compiler.SourceFiles;
+import com.clarity.sourcemodel.Component;
+import com.clarity.sourcemodel.OOPSourceCodeModel;
+import org.junit.Assert;
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+
+/**
+ * Tests to ensure package name attribute of parsed components are correct.
+ */
+public class PackageAttributeTest {
+
+    @Test
+    public void ES6FieldVariablePackageName() throws Exception {
+        final String code = "class React() {} class Polygon { constructor(height) {this.height = new React();} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("/github/http/polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("github.http.Polygon.height").get().packageName().equals("github.http"));
+    }
+
+    @Test
+    public void ES6ClassPackageName() throws Exception {
+        final String code = "class React() {} class Polygon { constructor(height) {this.height = new React();} }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("/github/http/polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("github.http.Polygon").get().packageName().equals("github.http"));
+    }
+
+    @Test
+    public void ES6LocalVariablePackageName() throws Exception {
+        final String code = "class Polygon { say() { var test = new React(); var lol = 4; }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("src/polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("src.Polygon.say.test").get().packageName().equals("src"));
+    }
+
+    @Test
+    public void ES6MethodParamPackageName() throws Exception {
+        final String code = "class Polygon { say(x) {}";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("src/cupcake/polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("src.cupcake.Polygon.say.x").get().packageName().equals("src.cupcake"));
+    }
+
+    @Test
+    public void ES6MethodPackageName() throws Exception {
+        final String code = "class Polygon { constructor() {  new React().test(); } }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("/github/polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("github.Polygon.constructor").get().packageName().equals("github"));
+    }
+}
diff --git a/clarpse/src/test/java/com/clarity/test/javascript/ResolveImportsTest.java b/clarpse/src/test/java/com/clarity/test/javascript/ResolveImportsTest.java
new file mode 100644
index 0000000..c961d2b
--- /dev/null
+++ b/clarpse/src/test/java/com/clarity/test/javascript/ResolveImportsTest.java
@@ -0,0 +1,272 @@
+package com.clarity.test.javascript;
+
+import com.clarity.compiler.ClarpseProject;
+import com.clarity.compiler.Lang;
+import com.clarity.compiler.RawFile;
+import com.clarity.compiler.SourceFiles;
+import com.clarity.sourcemodel.OOPSourceCodeModel;
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+
+ /**
+ * Tests to ensure module imports are resolved properly.
+ */
+public class ResolveImportsTest {
+
+    /**
+    * Test case:
+    *   Exporting Module: export class export1 {}
+    *   Importing Module: import { export1 } from "module-name/path/to/specific/un-exported/file";
+    */
+    @Test
+    public void SingleNamedLocalImportTest() throws Exception {
+        final String codeA = "export class Polygon { }";
+        final String codeB = "import { Polygon } from \'../shapes/polygon\'; \n class Cake { }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("com/shapes/polygon.js", codeA));
+        rawData.insertFile(new RawFile("com/types/cake.js", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("com.types.Cake").get().imports().contains("com.shapes.Polygon"));
+    }
+
+     /**
+      * Test case:
+      *     Exporting Module: class export1 {} export { export1 as export2}
+      *     Importing Module: import { export2 } from "/../file";
+      */
+     @Test
+     public void AliasExportAndNamedLocalImportTest() throws Exception {
+         final String codeA = "class Polygon { } export { Polygon as Triangle };";
+         final String codeB = "import { Triangle } from \'../shapes/polygon\'; \n class Cake { }";
+         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+         rawData.insertFile(new RawFile("com/shapes/polygon.js", codeA));
+         rawData.insertFile(new RawFile("com/types/cake.js", codeB));
+         final ClarpseProject parseService = new ClarpseProject(rawData);
+         final OOPSourceCodeModel generatedSourceModel = parseService.result();
+         assertTrue(generatedSourceModel.getComponent("com.types.Cake").get().imports().contains("com.shapes.Polygon"));
+     }
+
+
+     /**
+      * Test case:
+      *     Exporting Module: export default class {}
+      *     Importing Module: import export2 from "/../file";
+      */
+     @Test
+     public void UnnamedDefaultExport() throws Exception {
+         final String code = "export default class { }";
+         final String codeB = "import Cakes from \'./test\'; class Muffin {}";
+         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+         rawData.insertFile(new RawFile("/src/github/test.js", code));
+         rawData.insertFile(new RawFile("/src/github/muffin.js", codeB));
+         final ClarpseProject parseService = new ClarpseProject(rawData);
+         final OOPSourceCodeModel generatedSourceModel = parseService.result();
+         assertTrue(generatedSourceModel.getComponent("src.github.Muffin").get().imports()
+         .contains("src.github.test"));
+     }
+
+     /**
+      * Test case
+      *     *   Exporting Module: export class export1 {} export class export2 {}
+      *     *   Importing Module: import { export1, .. } from ".././file";
+      */
+     @Test
+     public void MultipleNamedLocalImportTest() throws Exception {
+         final String codeA = "export class Polygon { }; \n export class Cuppy {};";
+         final String codeB = "import { Polygon, Cuppy } from \'polygon.js\';  \n class Cake { }";
+         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+         rawData.insertFile(new RawFile("polygon.js", codeA));
+         rawData.insertFile(new RawFile("cake.js", codeB));
+         final ClarpseProject parseService = new ClarpseProject(rawData);
+         final OOPSourceCodeModel generatedSourceModel = parseService.result();
+         assertTrue(generatedSourceModel.getComponent("Cake").get().imports().contains("Polygon"));
+         assertTrue(generatedSourceModel.getComponent("Cake").get().imports().contains("Cuppy"));
+     }
+
+     /**
+      * Test case
+      *     *   Exporting Module: class export1 {} class export2 {} export {export1, export2 as export3, export4}
+      *     *   Importing Module: import { export3, export4 } from ".././file";
+      */
+     @Test
+     public void AliasExportAndMultipleNamedLocalImportTest() throws Exception {
+         final String codeA = "class Lemo { } class Choco {} export {Lemo as Nade, Choco as Late};";
+         final String codeB = "import { Nade, Late } from \'polygon.js\';  \n class Cake { }";
+         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+         rawData.insertFile(new RawFile("polygon.js", codeA));
+         rawData.insertFile(new RawFile("cake.js", codeB));
+         final ClarpseProject parseService = new ClarpseProject(rawData);
+         final OOPSourceCodeModel generatedSourceModel = parseService.result();
+         assertTrue(generatedSourceModel.getComponent("Cake").get().imports().contains("Lemo"));
+         assertTrue(generatedSourceModel.getComponent("Cake").get().imports().contains("Choco"));
+     }
+
+     @Test
+     public void MultipleSimilarNamedLocalImportTest() throws Exception {
+         final String codeA = "export class Polygon { };";
+         final String codeB = "import { Polygon } from \'test/polygon.js\';  \n class Cake { }";
+         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+         rawData.insertFile(new RawFile("/test/polygon.js", codeA));
+         rawData.insertFile(new RawFile("test/test/polygon.js", codeA));
+         rawData.insertFile(new RawFile("cake.js", codeB));
+         final ClarpseProject parseService = new ClarpseProject(rawData);
+         final OOPSourceCodeModel generatedSourceModel = parseService.result();
+         assertTrue(generatedSourceModel.getComponent("Cake").get().imports().contains("test.Polygon"));
+         assertTrue(!generatedSourceModel.getComponent("Cake").get().imports().contains("test.test.Polygon"));
+     }
+
+     /**
+      * Test case
+      *     *   Importing Module: import { export1, export2 } from "module-name";
+      */
+     @Test
+     public void SimpleNamedExternalImportTest() throws Exception {
+         final String codeB = "import Button from \'components/Button\'; \n class Cake { }";
+         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+         rawData.insertFile(new RawFile("cake.js", codeB));
+         final ClarpseProject parseService = new ClarpseProject(rawData);
+         final OOPSourceCodeModel generatedSourceModel = parseService.result();
+         assertTrue(generatedSourceModel.getComponent("Cake").get().imports().contains("components.Button"));
+     }
+
+     /**
+      * Test case
+      *     *   Importing Module: import defaultExport, {export1 as alias1} from "module-name";
+      */
+     @Test
+     public void DefaultImportWithNamedImportWithAliasTest() throws Exception {
+         final String codeB = "import Coin, { Button as button } from \'components/Button\'; \n class Cake { }";
+         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+         rawData.insertFile(new RawFile("cake.js", codeB));
+         final ClarpseProject parseService = new ClarpseProject(rawData);
+         final OOPSourceCodeModel generatedSourceModel = parseService.result();
+         assertTrue(generatedSourceModel.getComponent("Cake").get().imports().contains("components.Button"));
+         assertTrue(generatedSourceModel.getComponent("Cake").get().imports().contains("components.Coin"));
+     }
+
+     /**
+      * Test case
+      *     *   Exporting Module: export default class export1 {}
+      *     *   Importing Module: import export2 from "module-name";
+      */
+     @Test
+     public void DefaultExportAliasImportTest() throws Exception {
+         final String codeB = "export default class Cake { };";
+         final String codeC = "import Muffin from \'tester/ingredients/cake.js\' class Dessert { }";
+         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+         rawData.insertFile(new RawFile("tester/ingredients/cake.js", codeB));
+         rawData.insertFile(new RawFile("dessert.js", codeC));
+         final ClarpseProject parseService = new ClarpseProject(rawData);
+         final OOPSourceCodeModel generatedSourceModel = parseService.result();
+         assertTrue(generatedSourceModel.getComponent("Dessert").get().imports().contains("tester.ingredients.Cake"));
+     }
+
+     /**
+      * Test case
+      *     *   Importing Module: import defaultExport from "module-name";
+      */
+     @Test
+     public void DefaultImportTest() throws Exception {
+         final String codeB = "import Coin from \'components/Button\'; \n class Cake { }";
+         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+         rawData.insertFile(new RawFile("cake.js", codeB));
+         final ClarpseProject parseService = new ClarpseProject(rawData);
+         final OOPSourceCodeModel generatedSourceModel = parseService.result();
+         assertTrue(generatedSourceModel.getComponent("Cake").get().imports().contains("components.Coin"));
+     }
+
+     /**
+      * Test case
+      *     *   Exporting Module: export export1
+      *     *   Importing Module: import { export1 as alias1 } from "module-name";
+      */
+     @Test
+     public void NamedImportWithAliasTest() throws Exception {
+         final String codeB = "import { Button as button } from \'components/Button\'; \n class Cake { }";
+         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+         rawData.insertFile(new RawFile("cake.js", codeB));
+         final ClarpseProject parseService = new ClarpseProject(rawData);
+         final OOPSourceCodeModel generatedSourceModel = parseService.result();
+         assertTrue(generatedSourceModel.getComponent("Cake").get().imports().contains("components.Button"));
+     }
+
+     /**
+      * Test case
+      *     *   Exporting Module: class export1{} export { export1 as default}
+      *     *   Importing Module: import export2 from "module-name";
+      */
+     @Test
+     public void ComplexDefaultExportAndImportTest() throws Exception {
+         final String codeB = "class Cake { } \n export { Cake as default } ";
+         final String codeC = "import Muffin from \'cake.js\' class Dessert { }";
+         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+         rawData.insertFile(new RawFile("cake.js", codeB));
+         rawData.insertFile(new RawFile("dessert.js", codeC));
+         final ClarpseProject parseService = new ClarpseProject(rawData);
+         final OOPSourceCodeModel generatedSourceModel = parseService.result();
+         assertTrue(generatedSourceModel.getComponent("Dessert").get().imports().contains("Cake"));
+     }
+
+     /**
+      * Test case
+      *     *   Exporting Module: export export1
+      *     *   Importing Module: import { export1 , export2 as alias2 , [...] } from "module-name";
+      */
+     @Test
+     public void NamedImportsWithAndWithoutAliasTest() throws Exception {
+         final String codeB = "import { CuppyCake, Button as button } from \'components/Button\'; \n class Cake { }";
+         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+         rawData.insertFile(new RawFile("cake.js", codeB));
+         final ClarpseProject parseService = new ClarpseProject(rawData);
+         final OOPSourceCodeModel generatedSourceModel = parseService.result();
+         assertTrue(generatedSourceModel.getComponent("Cake").get().imports().contains("components.Button"));
+         assertTrue(generatedSourceModel.getComponent("Cake").get().imports().contains("components.CuppyCake"));
+     }
+
+     /**
+      * Test case
+      *     *   Exporting Module:
+      *     *   Importing Module: import * from "module-name";
+      */
+     @Test
+     public void AsteriskImportNotSupportedTest() throws Exception {
+         final String codeB = "import * from \'components/Button\'; \n class Cake { }";
+         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+         rawData.insertFile(new RawFile("cake.js", codeB));
+         final ClarpseProject parseService = new ClarpseProject(rawData);
+         final OOPSourceCodeModel generatedSourceModel = parseService.result();
+         assertTrue(generatedSourceModel.getComponent("Cake").get().imports().size() == 0);
+     }
+
+     /**
+      * Test case
+      *     *   Exporting Module: export export1
+      *     *   Importing Module: import * as name from "module-name";
+      */
+     @Test
+     public void AliasedAsteriskImportNotSupportedTest() throws Exception {
+         final String codeB = "import * as Test from \'components/Button\'; \n class Cake { }";
+         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+         rawData.insertFile(new RawFile("cake.js", codeB));
+         final ClarpseProject parseService = new ClarpseProject(rawData);
+         final OOPSourceCodeModel generatedSourceModel = parseService.result();
+         assertTrue(generatedSourceModel.getComponent("Cake").get().imports().size() == 0);
+     }
+
+     /**
+      * Test case
+      *     *   Exporting Module: export export1
+      *     *   Importing Module: import "module-name";
+      */
+     @Test
+     public void ModuleImportOnlyNotSupportedTest() throws Exception {
+         final String codeB = "import \'components/Button\'; \n class Cake { }";
+         final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+         rawData.insertFile(new RawFile("cake.js", codeB));
+         final ClarpseProject parseService = new ClarpseProject(rawData);
+         final OOPSourceCodeModel generatedSourceModel = parseService.result();
+         assertTrue(generatedSourceModel.getComponent("Cake").get().imports().size() == 0);
+     }
+}
diff --git a/clarpse/src/test/java/com/clarity/test/javascript/SimpleTypeReferenceTest.java b/clarpse/src/test/java/com/clarity/test/javascript/SimpleTypeReferenceTest.java
new file mode 100644
index 0000000..ac01c36
--- /dev/null
+++ b/clarpse/src/test/java/com/clarity/test/javascript/SimpleTypeReferenceTest.java
@@ -0,0 +1,208 @@
+package com.clarity.test.javascript;
+
+import com.clarity.compiler.ClarpseProject;
+import com.clarity.compiler.Lang;
+import com.clarity.compiler.RawFile;
+import com.clarity.compiler.SourceFiles;
+import com.clarity.sourcemodel.OOPSourceCodeModel;
+import com.clarity.sourcemodel.OOPSourceModelConstants;
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+
+/**
+* Tests to ensure module imports are resolved properly.
+*/
+public class SimpleTypeReferenceTest {
+
+    /**
+     * Simple type reference from single named import
+     */
+   @Test
+   public void ConstructorMethodCallTest() throws Exception {
+       final String codeA = "export class Polygon { }";
+       final String codeB = "import { Polygon } from \'../shapes/polygon\'; \n class Cake { constructor() {  Polygon.test(); } }";
+       final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+       rawData.insertFile(new RawFile("com/shapes/polygon.js", codeA));
+       rawData.insertFile(new RawFile("com/types/cake.js", codeB));
+       final ClarpseProject parseService = new ClarpseProject(rawData);
+       final OOPSourceCodeModel generatedSourceModel = parseService.result();
+       assertTrue(generatedSourceModel.getComponent("com.types.Cake.constructor").get()
+               .references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0).invokedComponent()
+               .equals("com.shapes.Polygon"));
+   }
+
+    /**
+     * Simple type reference from double named import
+     */
+    @Test
+    public void ConstructorMethodCallComplexTest() throws Exception {
+        final String codeA = "export class Polygon { }; \n export class Cuppy {};";
+        final String codeB = "import { Polygon, Cuppy } from \'polygon.js\';  \n class Cake { constructor() {  Polygon.test(); }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", codeA));
+        rawData.insertFile(new RawFile("cake.js", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Cake.constructor").get()
+                .references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0).invokedComponent()
+                .equals("Polygon"));
+    }
+
+    /**
+     * Test case: import { export1, export2 } from "module-name";
+     */
+    @Test
+    public void ES6SimpleNamedExternalImportTest() throws Exception {
+        final String codeB = "import Button from \'components/Button\'; \n class Cake { }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("cake.js", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Cake").get().imports().contains("components.Button"));
+    }
+
+    /**
+     * Test case: import defaultExport, {export1 as alias1} from "module-name";
+     */
+    @Test
+    public void ES6DefaultImportWithNamedImportWithAliasTest() throws Exception {
+        final String codeB = "import Coin, { Button as button } from \'components/Button\'; \n class Cake { }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("cake.js", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Cake").get().imports().contains("components.Button"));
+        assertTrue(generatedSourceModel.getComponent("Cake").get().imports().contains("components.Coin"));
+    }
+
+    /**
+     * Test case: import { export1 as alias1 } from "module-name";
+     */
+    @Test
+    public void ES6NamedImportWithAliasTest() throws Exception {
+        final String codeB = "import { Button as button } from \'components/Button\'; \n class Cake { }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("cake.js", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Cake").get().imports().contains("components.Button"));
+    }
+
+    /**
+     * Test case: import { export1 , export2 as alias2 , [...] } from "module-name";
+     */
+    @Test
+    public void ES6NamedImportsWithAndWithoutAliasTest() throws Exception {
+        final String codeB = "import { CuppyCake, Button as button } from \'components/Button\'; \n class Cake { }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("cake.js", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Cake").get().imports().contains("components.Button"));
+        assertTrue(generatedSourceModel.getComponent("Cake").get().imports().contains("components.CuppyCake"));
+    }
+
+    /**
+     * Test case: import * from "module-name";
+     */
+    @Test
+    public void ES6AsteriskImportNotSupportedTest() throws Exception {
+        final String codeB = "import * from \'components/Button\'; \n class Cake { }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("cake.js", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Cake").get().imports().size() == 0);
+    }
+
+    /**
+     * Test case: import * as name from "module-name";
+     */
+    @Test
+    public void ES6AliasedAsteriskImportNotSupportedTest() throws Exception {
+        final String codeB = "import * as Test from \'components/Button\'; \n class Cake { }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("cake.js", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Cake").get().imports().size() == 0);
+    }
+
+    /**
+     * Test case: import "module-name";
+     */
+    @Test
+    public void ES6ModuleImportOnlyNotSupportedTest() throws Exception {
+        final String codeB = "import \'components/Button\'; \n class Cake { }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("cake.js", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Cake").get().imports().size() == 0);
+    }
+
+    @Test
+    public void LocalLetVariableTypeDeclaration() throws Exception {
+        final String code = "class Polygon { say() { let test = new React(); }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.say.test")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0).invokedComponent().equals("React"));
+    }
+
+    @Test
+    public void LocalVariableTypeInstantiation() throws Exception {
+        final String code = "class Polygon { say() { var test = new React(); var lol = 4; }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("Polygon.say.test")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0).invokedComponent().equals("React"));
+    }
+
+    @Test
+    public void MethodTypeDeclarationFromStaticMethodCall() throws Exception {
+        final String code = "import { React } from \'github/react.js\'; \n class Polygon { constructor() {  React.test(); } }";
+        final String codeB = "class React {}";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("/src/test/polygon.js", code));
+        rawData.insertFile(new RawFile("/src/test/github/react.js", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("src.test.Polygon.constructor")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0).invokedComponent()
+                .equals("src.test.github.React"));
+    }
+
+    @Test
+    public void testResolvingOfAbsoluteImportPath() throws Exception {
+        final String code = "import { React } from \'/src/test/github/react.js\'; \n class Polygon { constructor() {  React.test(); } }";
+        final String codeB = "class React {}";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("/src/test/polygon.js", code));
+        rawData.insertFile(new RawFile("/src/test/github/react.js", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("src.test.Polygon.constructor")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0).invokedComponent()
+                .equals("src.test.github.React"));
+    }
+
+    @Test
+    public void testResolvingOfAliasImportType() throws Exception {
+        final String code = "import { React as LoL } from \'/src/test/github/react.js\'; \n class Polygon { constructor() {  LoL.test(); } }";
+        final String codeB = "class React {}";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("/src/test/polygon.js", code));
+        rawData.insertFile(new RawFile("/src/test/github/react.js", codeB));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        assertTrue(generatedSourceModel.getComponent("src.test.Polygon.constructor")
+                .get().references(OOPSourceModelConstants.TypeReferences.SIMPLE).get(0).invokedComponent()
+                .equals("src.test.github.React"));
+    }
+}
diff --git a/clarpse/src/test/java/com/clarity/test/javascript/TypeExtensionReferenceTest.java b/clarpse/src/test/java/com/clarity/test/javascript/TypeExtensionReferenceTest.java
new file mode 100644
index 0000000..4ceddf6
--- /dev/null
+++ b/clarpse/src/test/java/com/clarity/test/javascript/TypeExtensionReferenceTest.java
@@ -0,0 +1,52 @@
+package com.clarity.test.javascript;
+
+import com.clarity.compiler.ClarpseProject;
+import com.clarity.compiler.Lang;
+import com.clarity.compiler.RawFile;
+import com.clarity.compiler.SourceFiles;
+import com.clarity.reference.ComponentReference;
+import com.clarity.sourcemodel.OOPSourceCodeModel;
+import com.clarity.sourcemodel.OOPSourceModelConstants;
+import org.junit.Assert;
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+
+/**
+ * Ensure component type extensions invocations are accurate.
+ */
+public class TypeExtensionReferenceTest {
+
+    @Test
+    public void testIfParseClassHasCorrectExtendsAttr() throws Exception {
+        final String code = "class Polygon extends Shape { }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        // assert the Polygon class component has one type extension component
+        // invocation
+        assertTrue(generatedSourceModel.getComponent("Polygon").get().references(OOPSourceModelConstants.TypeReferences.EXTENSION)
+                .size() == 1);
+        // assert the component being extended is the Shape class
+        assertTrue(generatedSourceModel.getComponent("Polygon").get().references(OOPSourceModelConstants.TypeReferences.EXTENSION)
+                .get(0).invokedComponent().equals("Shape"));
+    }
+
+    @Test
+    public void testIfParseClassHasCorrectExtendsAttrComplex() throws Exception {
+        final String code = "import { Shape as Shape} from 'test/shape' \n class Polygon extends Shape { }";
+        final SourceFiles rawData = new SourceFiles(Lang.JAVASCRIPT);
+        rawData.insertFile(new RawFile("polygon.js", code));
+        final ClarpseProject parseService = new ClarpseProject(rawData);
+        final OOPSourceCodeModel generatedSourceModel = parseService.result();
+        // assert the Polygon class component has one type extension component
+        // invocation
+        assertTrue(generatedSourceModel.getComponent("Polygon").get().references(OOPSourceModelConstants.TypeReferences.EXTENSION)
+                .size() == 1);
+        // assert the component being extended is the Shape class
+        assertTrue(generatedSourceModel.getComponent("Polygon").get().references(OOPSourceModelConstants.TypeReferences.EXTENSION)
+                .get(0).invokedComponent().equals("test.Shape"));
+    }
+
+}
diff --git a/settings.xml b/settings.xml
index 39810d6..2696494 100644
--- a/settings.xml
+++ b/settings.xml
@@ -22,7 +22,7 @@
           </snapshots>
           <id>central</id>
           <name>libs-release</name>
-          <url>http://ec2-35-163-144-148.us-west-2.compute.amazonaws.com/artifactory/libs-release</url>
+          <url>http://artifactory.clarity-bot.com/artifactory/libs-release</url>
         </repository>
       </repositories>
       <id>artifactory</id>
